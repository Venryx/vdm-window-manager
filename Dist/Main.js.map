{"version":3,"file":"Main.js","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./Source/General/ClassExtensions/CE_General.ts","webpack:///./Source/General/Logging.ts","webpack:///./Source/General/Start_0.ts","webpack:///./Source/General/Windows.ts","webpack:///./Source/Input/ExtraKeys.ts","webpack:///./Source/Main.ts","webpack:///./Source/Scripts/General.ts","webpack:///./Source/Utils/Bridge/Bridge_VDesktop.ts","webpack:///./node_modules/js-vextensions/Dist/ClassExtensions/CE_Array.js","webpack:///./node_modules/js-vextensions/Dist/ClassExtensions/CE_Auto.js","webpack:///./node_modules/js-vextensions/Dist/ClassExtensions/CE_Element.js","webpack:///./node_modules/js-vextensions/Dist/ClassExtensions/CE_Number.js","webpack:///./node_modules/js-vextensions/Dist/ClassExtensions/CE_Object.js","webpack:///./node_modules/js-vextensions/Dist/ClassExtensions/CE_Others.js","webpack:///./node_modules/js-vextensions/Dist/ClassExtensions/CE_String.js","webpack:///./node_modules/js-vextensions/Dist/JSVE.js","webpack:///./node_modules/js-vextensions/Dist/Utils/Assert.js","webpack:///./node_modules/js-vextensions/Dist/Utils/Bridge.js","webpack:///./node_modules/js-vextensions/Dist/Utils/Changes.js","webpack:///./node_modules/js-vextensions/Dist/Utils/General.js","webpack:///./node_modules/js-vextensions/Dist/Utils/Timers.js","webpack:///./node_modules/js-vextensions/Dist/Utils/Types.js","webpack:///./node_modules/js-vextensions/Dist/Utils/URLs.js","webpack:///./node_modules/js-vextensions/Dist/Utils/VCache.js","webpack:///./node_modules/js-vextensions/Dist/Utils/VectorStructs.js","webpack:///./node_modules/js-vextensions/Dist/index.js","webpack:///./node_modules/js-vextensions/Helpers/@ApplyCECode.js","webpack:///external \"babel-polyfill\"","webpack:///external \"death\"","webpack:///external \"ffi\"","webpack:///external \"iohook\"","webpack:///external \"process\"","webpack:///external \"ref\"","webpack:///external \"ref-struct\"","webpack:///external \"win32-api\""],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"http://localhost:8080/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","interface Array<T> { SequenceEquals(otherArray: any[], equalsFunc?: (a, b)=>boolean): boolean; }\r\nArray.prototype._AddFunction_Inline = function SequenceEquals(this: any[], otherArray: any[], equalsFunc = ((a, b)=>a == b)) {\r\n\tif (this.length != otherArray.length) return false;\r\n\treturn this.every((item, index)=> {\r\n\t\treturn equalsFunc(item, otherArray[index]);\r\n\t});\r\n};","import \"./Logging\";\r\n\r\nG({Log}); declare global { function Log(...args); }\r\nfunction Log(...args) {\r\n\treturn console.log(...args);\r\n}","import \"./Start_0\"; // fake/empty import, so this module is correctly seen as module (rather than raw js script)\r\n\r\n// special, early, definitely-safe codes\r\n//var g = window as any;\r\ndeclare global { const g; } global[\"g\"] = global;\r\n\r\ndeclare global { function G(...globalHolders); } g.G = G;\r\nfunction G(...globalHolders) {\r\n\tfor (let globalHolder of globalHolders) {\r\n\t\tg.Extend(globalHolder);\r\n\t}\r\n}","import {User32, DTypes, DModel} from 'win32-api';\r\nimport ffi from \"ffi\";\r\nimport ref, {alloc} from \"ref\";\r\nimport {VRect, GetTreeNodesInObjTree, ToJSON, CE} from 'js-vextensions';\r\nimport Struct from 'ref-struct';\r\n\r\n// mod win32-api to use number-based handles (instead of Buffers)\r\n// ==========\r\n\r\n// make-so any parameter or return type set to W.HWND (\"HANDLE\"), gets replaced with \"int\"\r\n// For more info, see: https://github.com/waitingsong/node-win32-api/issues/16#issuecomment-540887760\r\n/*let replacements = [\r\n\t{key: \"HWND\", oldValue: null, newValue: \"int\"},\r\n];\r\nreplacements.forEach(a=> {\r\n\ta.oldValue = W[a.key];\r\n\tW[a.key] = a.newValue;\r\n});*/\r\nlet replacements = [\r\n\t//{oldValue: \"HANDLE\", newValue: \"int32\"},\r\n\t{oldValue: \"uint64*\", newValue: \"int32\"}, // I thought the lib source-code specified \"HANDLE\", but apparently it gets converted into \"uint64*\" at some point (perhaps in gen_api_opts)\r\n\r\n\t//{oldValue: \"uint16*\", newValue: \"string\"},\r\n];\r\nfor (let pair of CE(User32.apiDef).Pairs()) {\r\n\tlet definitionArray = pair.value;\r\n\t//Log(`Name(${pair.key}) Returns(${pair.value[0]}) Arguments(${pair.value[1]})`);\r\n\r\n\tlet nodes = GetTreeNodesInObjTree(definitionArray);\r\n\tfor (let node of nodes) {\r\n\t\tfor (let replacement of replacements) {\r\n\t\t\tif (node.Value === replacement.oldValue) {\r\n\t\t\t\tnode.Value = replacement.newValue;\r\n\t\t\t\t//Log(`Replacing ${replacement.oldValue} with ${replacement.newValue}... @Path(${node.PathStr})`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t//Log(`New Name(${pair.key}) Returns(${pair.value[0]}) Arguments(${pair.value[1]})`);\r\n}\r\n\r\n/*let functionReplacements = [\r\n\t{name: \"GetWindowTextW\", value: []}\r\n]\r\nfunctionReplacements.ForEach((replacement, {index, Break, Continue})=> {\r\n\tU.apiDef[replacement.name] = value;\r\n});*/\r\n//U.apiDef.GetWindowTextW = [\"int32\", [\"int32\", ref.refType(\"string\") as any, \"int32\"]];\r\n/*U.apiDef.Pairs().forEach(pair=> {\r\n\tif (pair.key != \"EnumWindows\")\r\n\tdelete U.apiDef[pair.key];\r\n})\r\nU.apiDef.VSet({\r\n\t...U.apiDef.Including(\"EnumWindows\"),\r\n\tGetWindowTextA: [\"int32\", [\"int32\", \"string\", \"int32\"]],\r\n} as any);*/\r\n//U.apiDef.GetWindowTextA = [\"int32\", [\"int32\", \"string\", \"int32\"]];\r\n\r\nexport const user32 = User32.load() as User32.Win32Fns;\r\n\r\n// create extension of user32, which uses type \"number\" for each param that was of type \"Buffer\"\r\n/*declare type ConvertModelFuncParams<T> = {\r\n\t//[K in keyof T]: T[K] extends (...args: any) => any ? (...args: ConvertFuncParams<T[K]>) => any : T[K];\r\n\t[K in keyof T]: T[K] extends (...args: any) => any ? ConvertFuncParams<T[K]> : T[K];\r\n};\r\ntype ConvertFuncParams<\r\n\tT extends (...args: any) => any\r\n> =\r\n\t//T extends (...args: (infer P)[]) => any ? (P extends Buffer ? number : P)[] : never;\r\n\tT extends (...args: (infer P)[]) => any ? (...args: (P extends Buffer ? number : P)[]) => any : never;\r\n//type Test1 = ()=>Buffer;\r\n/*type Test1 = typeof user32.GetWindowTextW;\r\ntype Test2 = ConvertFuncParams<Test1>;*#/\r\nconst user32_numbers = user32 as any as ConvertModelFuncParams<typeof user32>;\r\nuser32.GetWindowTextW();\r\nuser32_numbers.GetWindowTextW();*/\r\n\r\n// add Typescript overloads for the functions which were modified to send/receive number-handles instead of Buffer-handles\r\n/*declare module \"win32-api/dist/lib/user32/api\" {\r\n\texport interface Win32Fns {\r\n\t\tGetWindowTextW(hWnd: number, lpString: Buffer, nMaxCount: number): number\r\n\t}\r\n}\r\nuser32.GetWindowTextW();*/\r\n\r\n// add Typescript overloads for the functions which were modified to send/receive number-handles instead of Buffer-handles\r\n/*declare module \"win32-api/dist/lib/user32/api\" {\r\n\texport namespace M {\r\n\t\texport type HWND = number;\r\n\t}\r\n}*/\r\ntype RealBuffer = Buffer;\r\n//declare module \"win32-api/node_modules/win32-def/dist/lib/win-model/common\" {\r\ndeclare module \"win32-def/dist/lib/win-model/common\" {\r\n\t//type HWND = number;\r\n\t//type Buffer = number;\r\n\ttype Buffer = number | RealBuffer;\r\n}\r\n//user32.GetWindowTextW();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// general\r\n// ==========\r\n//var voidPtr = ref.refType(ref.types.void);\r\n//var stringPtr = ref.refType(ref.types.CString);\r\n\r\n/*declare global {\r\n\tinterface Buffer { Int(): number; }\r\n\tinterface Number { Buf(): Buffer; }\r\n}\r\nObject.prototype[\"Int\"] = function() {\r\n\t// convert\r\n\tif (this instanceof Buffer) {\r\n\t\t//return ref.address(this);\r\n\t\tthis[\"type\"] = ref.types.int64;\r\n\t\treturn temp1[\"deref\"]();\r\n\t}\r\n\r\n\t//if (typeof this == \"number\")\r\n\treturn this; // handle is already number -- just return\r\n}\r\nObject.prototype[\"Buf\"] = function() {\r\n\t//if (typeof this == \"number\") return ...; // convert (don't know how)\r\n\t//if (typeof this == \"number\")\r\n\treturn this; // handle is already number (matching modified definition-array) -- just return\r\n}*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nexport interface Point {\r\n\tx: number;\r\n\ty: number;\r\n}\r\nexport const POINT = Struct({\r\n\t'x': 'long',\r\n\t'y': 'long',\r\n});\r\nexport interface Rect {\r\n\tleft: number;\r\n\ttop: number;\r\n\tright: number;\r\n\tbottom: Point;\r\n}\r\nexport const RECT = Struct({\r\n\t'left': 'long',\r\n\t'top': 'long',\r\n\t'right': 'long',\r\n\t'bottom': 'long',\r\n});\r\nexport interface WindowPlacement {\r\n\tlength: number;\r\n\tflags: number;\r\n\tshowCmd: number;\r\n\tptMinPosition: Point;\r\n\tptMaxPosition: Point;\r\n\trcNormalPosition: Rect;\r\n}\r\nexport const WINDOWPLACEMENT = Struct({\r\n\t'length': 'uint',\r\n\t'flags': 'uint',\r\n\t'showCmd': 'uint',\r\n\t'ptMinPosition': POINT,\r\n\t'ptMaxPosition': POINT,\r\n\t'rcNormalPosition': RECT,\r\n});\r\n//var WINDOWPLACEMENT_REF = ref.refType(WINDOWPLACEMENT);\r\n\r\n// flags\r\nexport const WPF_ASYNCWINDOWPLACEMENT = 4;\r\n\r\n// showCmd (from: https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-windowplacement)\r\nexport const SW_HIDE = 0;\r\nexport const SW_MAXIMIZE = 3;\r\nexport const SW_MINIMIZE = 6;\r\nexport const SW_RESTORE = 9;\r\nexport const SW_SHOW = 5;\r\n//export const SW_SHOWMAXIMIZED = 3; // duplicate of SW_MAXIMIZE?\r\nexport const SW_SHOWMINIMIZED = 2;\r\nexport const SW_SHOWMINNOACTIVE = 7;\r\nexport const SW_SHOWNA = 8;\r\nexport const SW_SHOWNOACTIVATE = 4;\r\nexport const SW_SHOWNORMAL = 1;\r\n\r\nexport const user32_extra = new ffi.Library(\"user32\", {\r\n\t//EnumWindows: ['bool', [voidPtr, 'int32']],\r\n\t//GetForegroundWindow: [\"int32\", []],\r\n\tGetWindowTextA: [\"int32\", [\"int32\", \"string\", \"int32\"]],\r\n\t//GetWindowTextA : ['long', ['long', stringPtr, 'long']]\r\n\t//GetWindowTextW: [\"int32\", [\"int32\", ref.refType(\"string\"), \"int32\"]],\r\n\tGetWindowTextLengthW: [\"int32\", [\"int32\"]],\r\n\tGetWindowRect: ['bool', ['int32', \"pointer\"]],\r\n\r\n\tGetWindowPlacement: [\"bool\", [\"int32\", ref.refType(WINDOWPLACEMENT)]],\r\n\tSetWindowPlacement: [\"bool\", [\"int32\", ref.refType(WINDOWPLACEMENT)]],\r\n\tShowWindow: ['bool', ['int32', 'int32']],\r\n});\r\n\r\nexport class WindowInfo {\r\n\thandle: number;\r\n\tlParam: number;\r\n}\r\nexport function GetWindowHandles() {\r\n\tlet result = [] as number[];\r\n\tlet onFoundWindow = ffi.Callback('bool', ['long', 'int32'], (handle: number, lParam: number) => {\r\n\t\tresult.push(handle);\r\n\t\treturn true;\r\n\t});\r\n\tuser32.EnumWindows(onFoundWindow, 0);\r\n\treturn result;\r\n}\r\n/*export function GetWindowHandles() {\r\n\tlet result = [] as DModel.HWND[];\r\n\tlet onFoundWindow = ffi.Callback(W.BOOL, [W.HWND, W.LPARAM], (handle: DModel.HWND, lParam: number)=> {\r\n\t\tresult.push(handle);\r\n\t\treturn true;\r\n\t});\r\n\tuser32.EnumWindows(onFoundWindow, 0);\r\n\treturn result;\r\n}*/\r\n\r\nexport function GetForegroundWindowHandle() {\r\n\t//return user32.GetForegroundWindow().Int();\r\n\treturn user32.GetForegroundWindow() as number;\r\n\t//return user32.GetForegroundWindow() as any as number;\r\n}\r\nexport function GetForegroundWindowText() {\r\n\tvar handle = GetForegroundWindowHandle();\r\n\treturn GetWindowText(handle);\r\n}\r\n\r\n// Note: This function can cause an info-less crash, if: 1) using the W variant, 2) the buffer length is in a certain range [~8-280], 3) the program is launched using \"node --inspect\"\r\nexport function GetWindowText(handle: number) {\r\n\t//let length = user32_extra.GetWindowTextLengthW(handle as any);\r\n\t//let bufferSize = 256;\r\n\tlet bufferSize = 512;\r\n\tvar buffer = new Buffer(bufferSize);\r\n\t//buffer.type = ref.types.CString;\r\n\t//let length = user32.GetWindowTextW(user32.GetForegroundWindow(), buffer, bufferSize);\r\n\t//let length = user32_extra.GetWindowTextA(handle, buffer, bufferSize);\r\n\t//let length = user32.GetWindowTextA(handle, buffer, bufferSize);\r\n\t//let length = user32.GetWindowTextW(handle.Buf(), buffer, bufferSize);\r\n\tlet length = user32.GetWindowTextW(handle, buffer, bufferSize);\r\n\t//let length = user32.GetWindowTextW(handle as any, buffer, bufferSize);\r\n\t//return ref.readCString(buffer, 0);\r\n\t//return buffer.toString().substr(0, length as any);\r\n\treturn buffer.toString('ucs2').replace(/\\0+$/, '');\r\n}\r\n\r\nexport function GetWindowRect(handle: number) {\r\n\t//var rect = new rectStruct();\r\n\t//var rectPointer = ref.alloc(rectStructPointer);\r\n\tvar rectPointer: Buffer = Buffer.alloc(4 * 4);\r\n\t//Log(\"Address: \" + ref.address(handle));\r\n\t//var success = user32_extra.GetWindowRect(handle, rect);\r\n\t//var success = user32_extra.GetWindowRect(ref.address(handle), repbuffer);\r\n\tvar success = user32_extra.GetWindowRect(handle, rectPointer);\r\n\tif (!success) return null;\r\n\r\n\t//let rect = ref.get(rectPointer, 0, rectStructPointer).deref();\r\n\t//let rect = ref.get(rectPointer.buffer, 0, rectStructPointer).deref();\r\n\t//var repbuffer = new Buffer(4 * 4);\r\n\r\n\tlet rect = RectPointerToRect(rectPointer);\r\n\t//Log(\"Rect: \" + ToJSON(rect) + \";\" + success);\r\n\treturn RectToVRect(rect);\r\n}\r\n\r\nexport function GetWindowPlacement(handle: number) {\r\n\tlet placementRef = ref.alloc(WINDOWPLACEMENT);\r\n\tuser32_extra.GetWindowPlacement(handle, placementRef);\r\n\treturn placementRef.deref() as WindowPlacement;\r\n}\r\nexport function SetWindowPlacement(handle: number, placement: WindowPlacement) {\r\n\t/*var placementRef = ref.alloc(WINDOWPLACEMENT);\r\n\tplacementRef.writeObject(0, state.placement);*/\r\n\tvar placementRef = ref.alloc(WINDOWPLACEMENT, placement);\r\n\treturn user32_extra.SetWindowPlacement(handle, placementRef);\r\n}\r\n\r\nfunction RectPointerToRect(rectPointer: Buffer) {\r\n\tlet rect = {} as any;\r\n\trect.left = rectPointer.readUInt32LE(0);\r\n\trect.top = rectPointer.readUInt32LE(4);\r\n\trect.right = rectPointer.readUInt32LE(8);\r\n\trect.bottom = rectPointer.readUInt32LE(12);\r\n\treturn rect;\r\n}\r\nfunction RectToVRect(rect: {left, top, right, bottom}) {\r\n\treturn new VRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);\r\n}\r\n\r\nexport enum SuspendState {\r\n\tSleep,\r\n}\r\n\r\nvar powrprof = ffi.Library('powrprof.dll', {\r\n\tSetSuspendState: ['int', ['int', 'int', 'int']]\r\n});\r\nexport function SetSuspendState(state: SuspendState) {\r\n\tif (state == SuspendState.Sleep) {\r\n\t\tpowrprof.SetSuspendState(0, 0, 0);\r\n\t}\r\n}","// full list here: http://cherrytree.at/misc/vk.htm\r\nexport const extraKeys = {\r\n\tleftShift: 160,\r\n\trightShift: 161,\r\n\tleftControl: 162,\r\n\trightControl: 163,\r\n\tleftAlt: 164,\r\n\trightAlt: 165,\r\n\r\n\tmeta_windows: 91,\r\n\r\n\t// custom\r\n\tmouseLeft: 1000 + 1,\r\n\tmouseRight: 1000 + 2,\r\n\tmouseMiddle: 1000 + 3,\r\n\tmouseForward: 1000 + 4,\r\n\tmouseBackward: 1000 + 5,\r\n\tmouseWheelUp: 1000 + 6,\r\n\tmouseWheelDown: 1000 + 7,\r\n\r\n\t// number row\r\n\tN1: 49,\r\n\r\n\t// slashes and such\r\n\t/*slash: 191,\r\n\tbackslash: 220,*/\r\n\r\n\tvolumeDown: 174, //0xAE,\r\n\tvolumeUp: 175, //0xAF,\r\n\r\n\t// numpad keys\r\n\t// All of these, except for numpadCenter, are in regular keycode collection, but kept here too since naming is confusing.\r\n\t// (For example, [numpad insert] is same as [insert], but [numpad +] is not same as [+].)\r\n\t// ==========\r\n\r\n\t// 0-9\r\n\tnumpadInsert: 45,\r\n\tnumpadEnd: 35,\r\n\tnumpadDown: 40,\r\n\tnumpadPageDown: 34,\r\n\tnumpadLeft: 37,\r\n\tnumpadCenter: 12, // not sure real name\r\n\tnumpadRight: 39,\r\n\tnumpadHome: 36,\r\n\tnumpadUp: 38,\r\n\tnumpadPageUp: 33,\r\n\r\n\t// others, clockwise from top-left\r\n\tnumpadDivide: 111,\r\n\tnumpadMultiply: 106,\r\n\tnumpadSubtract: 109,\r\n\tnumpadAdd: 107,\r\n\tnumpadEnter: 108,\r\n};\r\n\r\n// smaller copy sets\r\nexport enum MouseButton {\r\n\tLeft = extraKeys.mouseLeft,\r\n\tRight = extraKeys.mouseRight,\r\n\tMiddle = extraKeys.mouseMiddle,\r\n\tForward = extraKeys.mouseForward,\r\n\tBackward = extraKeys.mouseBackward,\r\n}","// \"static\" imports\nimport \"./General/Start_0\";\n//import \"js-vextensions/Helpers/@ApplyCETypes.d.ts\";\ntype __ = typeof import(\"../node_modules/js-vextensions/Helpers/@ApplyCETypes\");\nimport \"js-vextensions/Helpers/@ApplyCECode.js\";\nimport \"./General/ClassExtensions/CE_General\";\nimport \"./General/Logging\";\n//import \"babel-core/register\";\nimport \"babel-polyfill\";\n\nimport OnDeath from \"death\";\nimport process from \"process\";\n//import { StartEventLoop, StopEventLoop } from \"./Input/EventLoop\";\n\n//let addHotkeySystem = !process.argv.Contains(\"noHotkey\");\n\nrequire(\"./Utils/Bridge/Bridge_VDesktop\");\n\n// subscripts\n// ==========\n\nrequire(\"./Scripts/General\");\n\n// shutdown\n// ==========\n\n//OnDeath({uncaughtException: true, exit: true})((signal, error)=> {\nvar OffDeath = OnDeath({uncaughtException: true, exit: true})((signal, error)=> {\n\tShutDown(signal, error);\n\tOffDeath();\n});\nfunction ShutDown(signal: string, error: Error) {\n\tconsole.log(`Signal: ${signal} Error: ${error}`);\n\t//StopEventLoop();\n\t//RemoveHooks();\n}\n// PreExit message is sent by venryx-desktop just before it closes (so we have chance to clean up) \nprocess.on(\"message\", message=> {\n\tif (message == \"PreExit\") {\n\t\tShutDown(\"PreExit\", null);\n\t}\n});\n\n// launch\n// ==========\n\n/*if (addHotkeySystem) {\n\tAddHook();\n}*/\n//StartEventLoop();","import ioHook from \"iohook\";\nimport {extraKeys} from \"../Input/ExtraKeys\";\nimport {GetWindowHandles, GetWindowText, GetWindowRect, GetForegroundWindowText, user32, user32_extra, WINDOWPLACEMENT, WindowPlacement, GetWindowPlacement, SetWindowPlacement, SW_SHOWMINIMIZED, SW_RESTORE, SW_SHOW, SW_HIDE, SW_MINIMIZE, SW_SHOWNA, SW_SHOWMINNOACTIVE, WPF_ASYNCWINDOWPLACEMENT, SW_SHOWNOACTIVATE, SW_MAXIMIZE, SW_SHOWNORMAL} from \"../General/Windows\";\nimport {VRect, ToJSON, E, Clone} from \"js-vextensions\";\n\nlet windowTitlesToIgnore = [\n\t// never visible (as real window)\n\t\"Program Manager\",\n\t// not really visible (at least usually -- and for me)\n\t\"Microsoft Text Input Application\", \"Backup and Sync\", \"Settings\", \"Microsoft Edge\",\n\t// not needing placement-restoring, for other reasons\n\t\"Venryx Overlay\",\n];\n\nexport class WindowState {\n\tconstructor(initialData: Partial<WindowState>) {\n\t\tthis.Extend(initialData);\n\t}\n\trect: VRect;\n\ttext: string;\n\tplacement: WindowPlacement;\n}\nlet windowStates = {} as {[key: string]: WindowState};\n\nexport function StoreStates() {\n\twindowStates = {};\n\n\tlet windows = GetWindowHandles();\n\twindows.forEach(handle => {\n\t\tif (!user32.IsWindowVisible(handle)) return;\n\n\t\tlet text = GetWindowText(handle);\n\t\tif (text.length == 0) return;\n\t\tif (windowTitlesToIgnore.Contains(text)) return;\n\n\t\tlet rect = GetWindowRect(handle);\n\t\tlet placement = GetWindowPlacement(handle);\n\t\t//Log(`Found window. @Handle(${handle}) @Title(${text}) @Rect(${rect})`);\n\n\t\tlet state = new WindowState({rect, text, placement});\n\t\twindowStates[handle] = state;\n\t});\n\tLog(`States stored for ${windowStates.Pairs().length} windows.`);\n}\nexport function ShowStoredStates() {\n\tfor (let {key: handle, value: state} of windowStates.Pairs()) {\n\t\tLog(`Window state: @Handle(${handle}) @Title(${state.text}) @Rect(${state.rect}) @Placement(${ToJSON(state.placement)})`);\n\t}\n}\nexport function RestoreStates() {\n\tlet restoredWindows = 0;\n\tfor (let {keyNum: handle, value: state} of windowStates.Pairs()) {\n\t\tlet placement = GetWindowPlacement(handle);\n\t\t// if placement is exactly the same as before, don't do anything\n\t\tif (ToJSON(placement) == ToJSON(state.placement)) continue;\n\n\t\t/*user32.ShowWindow(handle, SW_HIDE); // first, hide window (this seems to make the following steps get applied more quickly graphically)\n\t\t//user32.ShowWindow(handle, SW_SHOWMINNOACTIVE); // set show-state to \"minimized\", since maximized windows otherwise refuse to change screen\n\t\tuser32.ShowWindow(handle, SW_RESTORE); // set show-state to \"restored\", since maximized windows otherwise refuse to change screen\n\t\t//user32.ShowWindow(handle, SW_SHOWNOACTIVATE); // set show-state to \"restored\", since maximized windows otherwise refuse to change screen\n\t\t//SetWindowPlacement(handle, E(state.placement, {showCmd: SW_RESTORE})); // apply old-placement, except have show-state be \"restored\", since most reliable for getting on correct screen\n\t\tSetWindowPlacement(handle, state.placement); // now that in \"moveable\" state, apply old-placement\n\t\t//SetWindowPlacement(handle, E(state.placement, {flags: WPF_ASYNCWINDOWPLACEMENT})); // now that in \"moveable\" state, apply old-placement*/\n\n\t\t// in case the window just changed screens, have taskbar entry moved to match\n\t\t/*user32.ShowWindow(handle, SW_HIDE);\n\t\tuser32.ShowWindow(handle, SW_SHOWNA);*/\n\t\t//user32.ShowWindow(handle, SW_SHOWNA);\n\n\t\t//let finalPlacement = E(state.placement);\n\t\t// state.placement is an instance of a WindowPlacement class (node-ffi created; not the interface defined in Windows.ts), with the props as prototype getters (accessing the \"ref.buffer\" backing); thus, must use Clone to copy the values\n\t\tlet finalPlacement = Clone(state.placement);\n\t\tfinalPlacement.flags |= WPF_ASYNCWINDOWPLACEMENT;\n\n\t\t// first, set show-state to \"restored\" on the correct screen (fixes taskbar-entry being on wrong screen (todo: confirm), and maximized windows refusing to change screen)\n\t\t//let restorePlacement = E(finalPlacement, {showCmd: SW_SHOWNOACTIVATE}); // this seems to sometimes make window really small, and not maximize from next command\n\t\tlet restorePlacement = E(finalPlacement, {showCmd: SW_RESTORE});\n\t\tSetWindowPlacement(handle, restorePlacement);\n\n\t\t// modify show-command to be the non-activating variant\n\t\t/*if (finalPlacement.showCmd == SW_MAXIMIZE) {\n\t\t\t// first, set show-state to \"restored\", since maximized windows otherwise refuse to change screen\n\t\t\t//let restorePlacement = E(finalPlacement, {showCmd: SW_SHOWNOACTIVATE}); // this seems to sometimes make window really small, and not maximize from next command\n\t\t\t/*let restorePlacement = E(finalPlacement, {showCmd: SW_RESTORE});\n\t\t\tSetWindowPlacement(handle, restorePlacement);*#/\n\n\t\t\tfinalPlacement.showCmd = SW_MAXIMIZE;\n\t\t} else*/ if (finalPlacement.showCmd == SW_MINIMIZE || finalPlacement.showCmd == SW_SHOWMINIMIZED) {\n\t\t\tfinalPlacement.showCmd = SW_SHOWMINNOACTIVE;\n\t\t} else if (finalPlacement.showCmd == SW_SHOWNORMAL) {\n\t\t\tfinalPlacement.showCmd = SW_SHOWNOACTIVATE;\n\t\t}\n\n\t\t// apply final placement\n\t\tSetWindowPlacement(handle, finalPlacement);\n\n\t\trestoredWindows++;\n\t}\n\tLog(`States restored for ${restoredWindows} windows.`);\n}\n\n// hotkeys\n// ==========\n\n// If using iohook turns out insufficient (eg. not being able to capture keypresses for a desired hotkey), try using the Windows RegisterHotKey function:\n// * https://stackoverflow.com/questions/14799035/node-webkit-winapi/58314436#58314436\n// * https://www.fluxbytes.com/csharp/how-to-register-a-global-hotkey-for-your-application-in-c\n// If that doesn't work, I guess you'll have the use the node-ffi hook approach, even though I think it causes more overhead/delay. (see HotkeyManager.ts)\n\nioHook.useRawcode(true); // use rawcodes for shortcuts/hotkeys\n\n// logging\n/*ioHook.on('keydown', event => {\n\tconsole.log(event); // { type: 'mousemove', x: 700, y: 400 }\n});*/\n\nioHook.registerShortcut([extraKeys.leftControl, extraKeys.leftAlt, extraKeys.numpadEnd], (keys) => StoreStates());\nioHook.registerShortcut([extraKeys.leftControl, extraKeys.leftAlt, extraKeys.numpadDown], (keys) => ShowStoredStates());\nioHook.registerShortcut([extraKeys.leftControl, extraKeys.leftAlt, extraKeys.numpadPageDown], (keys) => RestoreStates());\n\n// register and start hook\nioHook.start(false);\nLog(\"Added listeners\");\n\n// might as well store the window-states at module launch (no real negative, and helps for cases where forget to store states manually, since pre-sleep listener not yet developed)\nStoreStates();","import {Bridge} from \"js-vextensions\";\n\nexport function InDesktopApp() {\n\t//return window.top != window && window.top.name == \"Venryx Desktop\";\n\t//return window.top != window;\n\t//return inElectron;\n\treturn process.argv[2] && process.argv[2] == \"asVDM\";\n}\n\nexport const desktopBridge = new Bridge({\n\treceiveChannelMessageFunc_adder: receiveChannelMessageFunc=>{\n\t\tif (!InDesktopApp()) return;\n\t\tprocess.on(\"message\", channelMessage=> {\n\t\t\treceiveChannelMessageFunc(channelMessage);\n\t\t});\n\t},\n\tsendChannelMessageFunc: channelMessage=>{\n\t\tif (!InDesktopApp()) return;\n\t\tprocess.send(channelMessage);\n\t},\n\t//channel_stringifyChannelMessageObj: false,\n});\n\n// for module system\n// ==========\n\nexport let sideScreen = false;\ndesktopBridge.RegisterFunction(\"SetSideScreen\", val=> {\n\tLog(\"SideScreen value received in window-manager module! Val: \" + val);\n\tsideScreen = val;\n});","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { StableSort, Compare, CreateProxyForClassExtensions, WithFuncsStandalone } from \"../Utils/General\";\r\nimport { Assert } from \"../Utils/Assert\";\r\nexport class ForEachControlOp {\r\n    constructor(type, returnValue) {\r\n        this.type = type;\r\n        this.returnValue = returnValue;\r\n    }\r\n}\r\nexport function Break() {\r\n    return new ForEachControlOp(\"break\");\r\n}\r\nexport function Continue() {\r\n    return new ForEachControlOp(\"continue\");\r\n}\r\nexport function Return(returnVal) {\r\n    return new ForEachControlOp(\"return\", returnVal);\r\n}\r\nexport const ArrayCE_funcs = {\r\n    /* interface Array<T> { /** Same as forEach, except breaks the loop when \"true\" is returned. *#/ forEach_break(callbackfn: (value: any, index: number, array: any[]) => boolean, thisArg?: any); }\r\n    forEach_break(...args) { return this.some(...args); } */\r\n    /*ForEach<T, T2>(this: T[], func: (item: T, index: number, array: T[])=>T2): T2 {\r\n        //this.forEach((item, index, array)=> {\r\n        for (const [index, item] of this.entries()) {\r\n            let subResult = func(item, index, this);\r\n            if (subResult == \"break\") break;\r\n            else if (subResult == \"continue\") continue;\r\n            else if (subResult !== undefined) return subResult;\r\n        }\r\n    }*/\r\n    ForEach(func) {\r\n        let extras = {\r\n            array: this,\r\n            index: null,\r\n            controlOp: null,\r\n            Break() { extras.controlOp = new ForEachControlOp(\"break\"); },\r\n            Continue() { extras.controlOp = new ForEachControlOp(\"continue\"); },\r\n            Return(returnVal) { extras.controlOp = new ForEachControlOp(\"return\", returnVal); }\r\n        };\r\n        for (let i = 0; i < this.length; i++) {\r\n            extras.index = i;\r\n            extras.controlOp = null;\r\n            let subResult = func(this[i], i, extras);\r\n            let controlOp = subResult instanceof ForEachControlOp ? subResult : extras.controlOp;\r\n            if (controlOp) {\r\n                if (subResult.type == \"break\")\r\n                    break;\r\n                if (subResult.type == \"continue\")\r\n                    continue;\r\n                if (subResult.type == \"return\")\r\n                    return subResult.returnValue;\r\n            }\r\n        }\r\n    },\r\n    ForEachAsync(func) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let extras = {\r\n                array: this,\r\n                index: null,\r\n                controlOp: null,\r\n                Break() { extras.controlOp = new ForEachControlOp(\"break\"); },\r\n                Continue() { extras.controlOp = new ForEachControlOp(\"continue\"); },\r\n                Return(returnVal) { extras.controlOp = new ForEachControlOp(\"return\", returnVal); }\r\n            };\r\n            for (let i = 0; i < this.length; i++) {\r\n                extras.index = i;\r\n                extras.controlOp = null;\r\n                let subResult = yield func(this[i], extras);\r\n                let controlOp = subResult instanceof ForEachControlOp ? subResult : extras.controlOp;\r\n                if (controlOp) {\r\n                    if (subResult.type == \"break\")\r\n                        break;\r\n                    if (subResult.type == \"continue\")\r\n                        continue;\r\n                    if (subResult.type == \"return\")\r\n                        return subResult.returnValue;\r\n                }\r\n            }\r\n        });\r\n    },\r\n    /*declare global { interface Array<T> { ForEachAsyncParallel(func: (value: T, index: number, array: T[])): Promise<void>; } }\r\n    Array.prototype.ForEachAsync_Parallel = async function (this: Array<any>, fn) {\r\n        await Promise.all(this.map(fn));\r\n    },*/\r\n    Contains(item) {\r\n        return this.indexOf(item) != -1;\r\n    },\r\n    ContainsAny(...items) {\r\n        for (const item of items) {\r\n            if (this.indexOf(item) != -1) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n    // for some reason, this platform doesn't have entries() defined\r\n    /*entries() {\r\n        var result = [];\r\n        for (var i = 0; i < this.length; i++)\r\n            result.push([i, this[i]]);\r\n        return result;\r\n    };*/\r\n    Prepend(...newItems) {\r\n        this.splice(0, 0, ...newItems);\r\n    },\r\n    Add(item) {\r\n        return this.push(item);\r\n    },\r\n    CAdd(item) {\r\n        this.push(item);\r\n        return this;\r\n    },\r\n    TAdd(item) {\r\n        this.push(item);\r\n        return item;\r\n    },\r\n    AddRange(array) {\r\n        //this.push(...array);\r\n        // use loop, since sending them all as arguments fails when there are ~10000+ items\r\n        for (const item of array) {\r\n            this.push(item);\r\n        }\r\n        return this;\r\n    },\r\n    Remove(item) {\r\n        var itemIndex = this.indexOf(item);\r\n        if (itemIndex == -1)\r\n            return false;\r\n        this.splice(itemIndex, 1);\r\n        return true;\r\n    },\r\n    RemoveAll(items) {\r\n        for (let item of items) {\r\n            ArrayCES.Remove(this, item);\r\n        }\r\n    },\r\n    RemoveAt(index) {\r\n        return this.splice(index, 1)[0];\r\n    },\r\n    Insert(index, obj) {\r\n        this.splice(index, 0, obj);\r\n    },\r\n    SetItems(items) {\r\n        this.splice(0, this.length, ...items);\r\n        return this;\r\n    },\r\n    Reversed() {\r\n        var clone = this.slice();\r\n        clone.reverse();\r\n        return clone;\r\n    },\r\n    //Object.prototype._AddFunction_Inline = function AsRef() { return new NodeReference_ByPath(this); }\r\n    // Linq replacements\r\n    // ----------\r\n    Any(matchFunc) {\r\n        for (let [index, item] of this.entries()) {\r\n            if (matchFunc == null || matchFunc.call(item, item, index)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n    All(matchFunc) {\r\n        for (let [index, item] of this.entries()) {\r\n            if (!matchFunc.call(item, item, index)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    Where(matchFunc) {\r\n        var result = [];\r\n        for (let [index, item] of this.entries()) {\r\n            if (matchFunc.call(item, item, index)) { // call, having the item be \"this\", as well as the first argument\r\n                result.push(item);\r\n            }\r\n        }\r\n        return result;\r\n    },\r\n    Select(selectFunc) {\r\n        var result = [];\r\n        for (let [index, item] of this.entries()) {\r\n            result.push(selectFunc.call(item, item, index));\r\n        }\r\n        return result;\r\n    },\r\n    SelectMany(selectFunc) {\r\n        //return [...this.entries()].reduce((acc, [index, item])=>acc.concat(selectFunc.call(item, item, index)), []);\r\n        var result = [];\r\n        for (let [index, item] of this.entries()) {\r\n            ArrayCES.AddRange(result, selectFunc.call(item, item, index));\r\n        }\r\n        return result;\r\n    },\r\n    //Count(matchFunc) { return this.Where(matchFunc).length; };\r\n    //Count(matchFunc) { return this.Where(matchFunc).length; }; // needed for items to be added properly to custom classes that extend Array\r\n    // needed for items to be added properly to custom classes that extend Array\r\n    Count() {\r\n        return this.length;\r\n    },\r\n    VCount(matchFunc) {\r\n        return ArrayCES.Where(this, matchFunc).length;\r\n    },\r\n    Clear() {\r\n        /*while (this.length > 0)\r\n            this.pop();*/\r\n        this.splice(0, this.length);\r\n    },\r\n    First(matchFunc) {\r\n        var result = ArrayCES.FirstOrX(this, matchFunc);\r\n        if (result == null) {\r\n            throw new Error(\"Matching item not found.\");\r\n        }\r\n        return result;\r\n    },\r\n    FirstOrX(matchFunc, x = null) {\r\n        if (matchFunc) {\r\n            for (let [index, item] of this.entries()) {\r\n                if (matchFunc.call(item, item, index)) {\r\n                    return item;\r\n                }\r\n            }\r\n        }\r\n        else if (this.length > 0) {\r\n            return this[0];\r\n        }\r\n        return x;\r\n    },\r\n    //FirstWithPropValue(propName, propValue) { return this.Where(function() { return this[propName] == propValue; })[0]; };\r\n    FirstWith(propName, propValue) {\r\n        return ArrayCES.Where(this, function () { return this[propName] == propValue; })[0];\r\n    },\r\n    Last(matchFunc) {\r\n        var result = ArrayCES.LastOrX(this, matchFunc);\r\n        if (result === undefined) {\r\n            throw new Error(\"Matching item not found.\");\r\n        }\r\n        return result;\r\n    },\r\n    LastOrX(matchFunc, x = null) {\r\n        if (matchFunc) {\r\n            for (var i = this.length - 1; i >= 0; i--) {\r\n                if (matchFunc.call(this[i], this[i], i)) {\r\n                    return this[i];\r\n                }\r\n            }\r\n        }\r\n        else if (this.length > 0) {\r\n            return this[this.length - 1];\r\n        }\r\n        return x;\r\n    },\r\n    XFromLast(x) {\r\n        return this[(this.length - 1) - x];\r\n    },\r\n    Move(item, newIndex, newIndexAsPreRemovalIndexVSFinalIndex = false) {\r\n        var oldIndex = this.indexOf(item);\r\n        /*if (oldIndex != -1) {\r\n            this.RemoveAt(oldIndex);\r\n            // New-index is understood to be the position-in-list to move the item to, as seen before the item started being moved.\r\n            // So compensate for remove-from-old-position list modification.\r\n            if (shiftInsertPointToPreserveFinalNeighbors && oldIndex < newIndex) {\r\n                newIndex--;\r\n            }\r\n        }\r\n        this.Insert(newIndex, item);*/\r\n        if (newIndexAsPreRemovalIndexVSFinalIndex) {\r\n            ArrayCES.Insert(this, newIndex, item);\r\n            if (oldIndex != -1) {\r\n                let oldEntry_currentIndex = newIndex <= oldIndex ? oldIndex + 1 : oldIndex; // if we just inserted the new version before the old entry, fix the old-entry's index by adding 1\r\n                ArrayCES.RemoveAt(this, oldEntry_currentIndex);\r\n            }\r\n        }\r\n        else {\r\n            if (oldIndex != -1) {\r\n                ArrayCES.RemoveAt(this, oldIndex);\r\n            }\r\n            ArrayCES.Insert(this, newIndex, item);\r\n        }\r\n        return oldIndex;\r\n    },\r\n    //ToList<T>(this: T[], itemType = null) { return [].concat(this); }\r\n    /*ToDictionary(keyFunc, valFunc) {\r\n        var result = new Dictionary();\r\n        for (var i in this)\r\n            result.Add(keyFunc(this[i]), valFunc(this[i]));\r\n        return result;\r\n    }*/\r\n    ToMap(keyFunc, valFunc) {\r\n        var result = {};\r\n        for (let [index, item] of this.entries()) {\r\n            result[keyFunc(item, index)] = valFunc(item, index);\r\n        }\r\n        return result;\r\n    },\r\n    Skip(count) {\r\n        var result = [];\r\n        for (let i = count; i < this.length; i++) {\r\n            result.push(this[i]);\r\n        }\r\n        return result;\r\n    },\r\n    Take(count) {\r\n        var result = [];\r\n        for (let i = 0; i < count && i < this.length; i++) {\r\n            result.push(this[i]);\r\n        }\r\n        return result;\r\n    },\r\n    TakeLast(count) {\r\n        var result = [];\r\n        for (var i = 0; i < count && (this.length - 1) - i >= 0; i++) {\r\n            result.push(this[(this.length - 1) - i]);\r\n        }\r\n        return result;\r\n    },\r\n    FindIndex(matchFunc) {\r\n        for (let [index, item] of this.entries()) {\r\n            if (matchFunc.call(item, item, index)) { // call, having the item be \"this\", as well as the first argument\r\n                return index;\r\n            }\r\n        }\r\n        return -1;\r\n    },\r\n    /*FindIndex(matchFunc: (item: T)=>boolean) {\r\n        for (let [index, item] of this.entries())\r\n            if (matchFunc.call(item, item))\r\n                    return index;\r\n        return -1;\r\n    };*/\r\n    OrderBy(valFunc = (item, index) => item) {\r\n        /*var temp = this.ToList();\r\n        temp.sort((a, b)=>V.Compare(valFunc(a), valFunc(b)));\r\n        return temp;*/\r\n        return StableSort(this, (a, b, aIndex, bIndex) => Compare(valFunc(a, aIndex), valFunc(b, bIndex)));\r\n    },\r\n    OrderByDescending(valFunc = (item, index) => item) {\r\n        return ArrayCES.OrderBy(this, (item, index) => -valFunc(item, index));\r\n    },\r\n    Distinct() {\r\n        const result = [];\r\n        /*for (const i in this) {\r\n            if (!this.hasOwnProperty(i)) continue;*/\r\n        for (let i = 0; i < this.length; i++) {\r\n            if (!ArrayCES.Contains(result, this[i])) {\r\n                result.push(this[i]);\r\n            }\r\n        }\r\n        return result;\r\n    },\r\n    Except: (function (...args) {\r\n        let opt, excludeItems;\r\n        if (args[0] && \"excludeEachOnlyOnce\" in args[0])\r\n            [opt, excludeItems] = args;\r\n        else\r\n            excludeItems = args;\r\n        if (opt && opt.excludeEachOnlyOnce) {\r\n            const result = this.slice();\r\n            for (const excludeItem of excludeItems) {\r\n                ArrayCES.Remove(result, excludeItem);\r\n            }\r\n            return result;\r\n        }\r\n        return this.filter(a => !ArrayCES.Contains(excludeItems, a));\r\n    }),\r\n    IfEmptyThen(valIfSelfIsEmpty) {\r\n        return this.length == 0 ? valIfSelfIsEmpty : this;\r\n    },\r\n    //JoinUsing(separator) { return this.join(separator);};\r\n    Min(valFunc, asNumbers = false) {\r\n        // only set asNumbers to true if providing a number[] array\r\n        if (asNumbers) {\r\n            /*const values = valFunc ? this.map(valFunc) : this;\r\n            return Math.min(...values);*/\r\n            Assert(valFunc == null, \"Cannot use valFunc if asNumbers is set to true.\");\r\n            return Math.min(...this);\r\n        }\r\n        return ArrayCES.OrderBy(this, valFunc)[0];\r\n    },\r\n    Max(valFunc, asNumbers = false) {\r\n        // only set asNumbers to true if providing a number[] array\r\n        if (asNumbers) {\r\n            /*const values = valFunc ? this.map(valFunc) : this;\r\n            return Math.max(...values);*/\r\n            Assert(valFunc == null, \"Cannot use valFunc if asNumbers is set to true.\");\r\n            return Math.max(...this);\r\n        }\r\n        return ArrayCES.LastOrX(ArrayCES.OrderBy(this, valFunc));\r\n    },\r\n    Sum() {\r\n        let total = 0;\r\n        for (const item of this) {\r\n            total += item;\r\n        }\r\n        return total;\r\n    },\r\n    Average() {\r\n        const total = ArrayCES.Sum(this);\r\n        return total / this.length;\r\n    },\r\n    Median() {\r\n        const ordered = ArrayCES.OrderBy(this, a => a);\r\n        if (this.length % 2 == 0) { // if even number of elements, average two middlest ones\r\n            return ordered[(this.length / 2) - 1] + ordered[this.length / 2];\r\n        }\r\n        return ordered[this.length / 2]; // otherwise, return the exactly-middle one\r\n    },\r\n    Random() {\r\n        let index = Math.floor(Math.random() * this.length);\r\n        return this[index];\r\n    },\r\n    //oldJoin: [].join,\r\n    Join(separator = \",\") {\r\n        if (this.length == 0)\r\n            return \"\";\r\n        //let result = \"\" + this[0];\r\n        let result = this[0] != null ? \"\" + this[0] : \"\"; // to match behavior of native join\r\n        for (var i = 1, len = this.length; i < len; i++) {\r\n            result += separator;\r\n            result += this[i] != null ? \"\" + this[i] : \"\";\r\n        }\r\n        /*let oldResult = oldJoin.apply(this, arguments);\r\n        if (oldResult != result) debugger;*/\r\n        return result;\r\n    },\r\n};\r\nexport const ArrayCE = CreateProxyForClassExtensions(ArrayCE_funcs);\r\nexport const ArrayCES = WithFuncsStandalone(ArrayCE_funcs);\r\n/*var ArrayIterator = [].entries().constructor;\r\nexport class ArrayIteratorCEProxy {\r\n    ToArray(this: ArrayIterator) {\r\n        return Array.from(this);\r\n    }\r\n}\r\nexport const ArrayIteratorCE = CreateProxyForClassExtensions(ArrayIteratorCEProxy);*/\r\n/*export class NodeListCEProxy {\r\n    ToArray(this: NodeList) {\r\n        return Array.from(this);\r\n    }\r\n}\r\nexport const NodeListCE = CreateProxyForClassExtensions(NodeListCEProxy);*/ \r\n//# sourceMappingURL=CE_Array.js.map","import { ArrayCE } from \"./CE_Array\";\r\nimport { NumberCE } from \"./CE_Number\";\r\nimport { ObjectCE } from \"./CE_Object\";\r\nimport { StringCE } from \"./CE_String\";\r\nimport { ElementCE } from \"..\";\r\nimport { IsString, IsNumber, IsFunction, IsArray } from \"../Utils/Types\";\r\nimport { DateCE, FunctionCE } from \"./CE_Others\";\r\n/*interface CE_Auto_I {\r\n    (obj: Array<any>): typeof ArrayCE;\r\n    (obj: Element): typeof ElementCE;\r\n    (obj: number): typeof NumberCE;\r\n    (obj: Object): typeof ObjectCE;\r\n    (obj: string): typeof StringCE;\r\n}\r\n\r\nexport const CE_Auto = ((obj)=> {\r\n}) as CE_Auto_I;*/\r\nlet classExtensionMap = {\r\n    Number: NumberCE,\r\n    String: StringCE,\r\n    Date: DateCE,\r\n    Element: ElementCE,\r\n    Function: FunctionCE,\r\n    Array: ArrayCE,\r\n    Object: ObjectCE,\r\n};\r\nexport function CE(obj, checkForUncommonDerived = false) {\r\n    // first, try to get class-extension func based on direct constructor name (most common case)\r\n    let typeName = obj.constructor ? obj.constructor.name : null;\r\n    if (typeName && classExtensionMap[typeName]) {\r\n        return classExtensionMap[typeName](obj);\r\n    }\r\n    // else, check each option using \"instanceof\" and such (needed for derived classes)\r\n    if (checkForUncommonDerived) {\r\n        if (IsNumber(obj, true))\r\n            return NumberCE(obj);\r\n        if (IsString(obj, true))\r\n            return StringCE(obj);\r\n        if (obj instanceof Date)\r\n            return DateCE(obj);\r\n        if (IsFunction(obj))\r\n            return FunctionCE(obj);\r\n        if (IsArray(obj))\r\n            return ArrayCE(obj);\r\n    }\r\n    if (obj instanceof Element)\r\n        return ElementCE(obj);\r\n    /*if (IsObject(obj)) return ObjectCE(obj);\r\n    throw new Error(`Could not find class-extension helper for type \"${obj.constructor ? obj.constructor.name : \"n/a\"}\".`);*/\r\n    return ObjectCE(obj);\r\n}\r\n//# sourceMappingURL=CE_Auto.js.map","import { WithFuncsStandalone, CreateProxyForClassExtensions } from \"../Utils/General\";\r\nexport const ElementCE_funcs = {\r\n    GetParents(topDown = false) {\r\n        let result = [];\r\n        let currentParent = this.parentElement;\r\n        while (currentParent) {\r\n            result.push(currentParent);\r\n            currentParent = currentParent.parentElement;\r\n        }\r\n        if (topDown)\r\n            result.reverse();\r\n        return result;\r\n    },\r\n    GetSelfAndParents(topDown = false) {\r\n        let result = ElementCE(this).GetParents(topDown);\r\n        return topDown ? result.concat([this]) : [this].concat(result);\r\n    },\r\n    /*QuerySelectorAll_BreadthFirst(this: HTMLElement, selector: string) {\r\n        var $found = [];\r\n        let currentSet = this.childNodes.ToArray();\r\n        while (currentSet.length) {\r\n            let found = currentSet.filter(a=>a.matches(selector));\r\n            if ($found.length) break;\r\n            // Get all children of the current set\r\n            $currentSet = $currentSet.children();\r\n        }\r\n        return $found.first(); // Return first match of the collection\r\n    }*/\r\n    QuerySelector_BreadthFirst(selector) {\r\n        let currentLayerElements = Array.from(this.childNodes);\r\n        while (currentLayerElements.length) {\r\n            let firstMatchInLayer = currentLayerElements.find(a => a[\"matches\"] && a[\"matches\"](selector));\r\n            if (firstMatchInLayer)\r\n                return firstMatchInLayer;\r\n            //currentLayerElements = currentLayerElements.SelectMany(a=>[...a.childNodes]);\r\n            currentLayerElements = currentLayerElements.reduce((acc, item) => acc.concat(Array.from(item.childNodes)), []);\r\n        }\r\n        return null;\r\n    },\r\n    $(queryStr) {\r\n        return Array.from(this.querySelectorAll(queryStr));\r\n    },\r\n};\r\nexport const ElementCE = CreateProxyForClassExtensions(ElementCE_funcs);\r\n// maybe make ElementCE preserve the target-type, like ObjectCE and ArrayCE do (not needed atm, since the CE-methods don't make any/much use of the target's type-data)\r\n//export const ElementCE = CreateProxyForClassExtensions(ElementCE_funcs) as <T>(nextThis: T)=>ElementCEProxy;\r\nexport const ElementCES = WithFuncsStandalone(ElementCE_funcs);\r\n//# sourceMappingURL=CE_Element.js.map","import { StringCE } from \"./CE_String\";\r\nimport { WithFuncsStandalone, CreateProxyForClassExtensions } from \"../Utils/General\";\r\nimport { IsNaN } from \"../Utils/Types\";\r\n// Note: Since JS coerces number primitives to the Number class when a property-access is attempted (https://javascriptrefined.io/the-wrapper-object-400311b29151)...\r\n// ...calling the functions below using, eg. \"(3).WrapToRange\" *should* make the \"this\" variable be a Number class within the WrapToRange function.\r\n// However, this is not the case! -- at least when I try it in the Chrome console, with the actual Webpack-added function. (if I add a function with the exact same source using the console, it is coerced to Number as expected)\r\n// I think it might be a Chrome optimization or something.\r\n// Anyway, the code below is based on how it *should* work, with the \"this\" var always being a Number wrapper. (we use \"as number\" in some places below, since valueOf gets auto-called to enable the primitive math ops anyway)\r\nexport const NumberCE_funcs = {\r\n    IfN1Then(valIfSelfIsNeg1) {\r\n        return this == -1 ? valIfSelfIsNeg1 : this;\r\n    },\r\n    NaNTo(valIfSelfIsNaN) {\r\n        return IsNaN(this) ? valIfSelfIsNaN : this;\r\n    },\r\n    //RoundToMultipleOf(step) { return Math.round(new Number(this) / step) * step; }; //return this.lastIndexOf(str, 0) === 0; };\r\n    ToPercentStr(precision) {\r\n        let number = this * 100;\r\n        if (precision != null)\r\n            return number.toFixed(precision) + \"%\";\r\n        return number.toString() + \"%\";\r\n    },\r\n    IsMultipleOf(multipleOf, maxDistToBeMultiple) {\r\n        let valRoundedToMultiple = NumberCE(this).RoundTo(multipleOf);\r\n        let distance = NumberCE(valRoundedToMultiple).Distance(this);\r\n        return distance <= maxDistToBeMultiple;\r\n    },\r\n    RoundTo(multiple) {\r\n        //return Math.round(this / multiple) * multiple;\r\n        // Don't ask me why this works, but it does, and is faster. From: http://phrogz.net/round-to-nearest-via-modulus-division\r\n        /*var half = multiple / 2;\r\n        return (this + half) - ((this + half) % multiple);*/\r\n        // Realign/scale the possible values/multiples, so that each value is given an integer slot. Place the actual value (this) within the appropriate slot using Math.round() int-rounding, then reverse the scaling to get the true rounded value.\r\n        // (This version handles fractions better. Ex: (.2 + .1).RoundTo(.1) == .3 [NOT 0.3000000000000004, as the simpler approach gives])\r\n        let multiple_inverted = 1 / multiple;\r\n        return Math.round(this * multiple_inverted) / multiple_inverted;\r\n    },\r\n    RoundTo_Str(multipleOf, fractionDigits = null, removeEmptyFraction = true) {\r\n        var resultValue = NumberCE(this).RoundTo(multipleOf);\r\n        var result = resultValue.toFixed(fractionDigits != null ? fractionDigits : multipleOf.toString().TrimStart(\"0\").length - 1); // - 0);\r\n        if (removeEmptyFraction && StringCE(result).Contains(\".\")) {\r\n            result = StringCE(StringCE(result).TrimEnd(\"0\")).TrimEnd(\".\");\r\n        }\r\n        return result;\r\n    },\r\n    FloorTo(multipleOf) { return Math.floor(new Number(this) / multipleOf) * multipleOf; },\r\n    FloorTo_Str(multipleOf) {\r\n        var resultValue = NumberCE(this).FloorTo(multipleOf);\r\n        var result = resultValue.toFixed(multipleOf.toString().TrimStart(\"0\").length); // - 1);\r\n        if (StringCE(result).Contains(\".\"))\r\n            result = StringCE(StringCE(result).TrimEnd(\"0\")).TrimEnd(\".\");\r\n        return result;\r\n    },\r\n    CeilingTo(multipleOf) { return Math.ceil(new Number(this) / multipleOf) * multipleOf; },\r\n    CeilingTo_Str(multipleOf) {\r\n        var resultValue = NumberCE(this).CeilingTo(multipleOf);\r\n        var result = resultValue.toFixed(multipleOf.toString().TrimStart(\"0\").length); // - 1);\r\n        if (StringCE(result).Contains(\".\"))\r\n            result = StringCE(StringCE(result).TrimEnd(\"0\")).TrimEnd(\".\");\r\n        //result = TrimEnd(TrimEnd(result, \"0\"), \".\");\r\n        return result;\r\n    },\r\n    KeepAtLeast(min) {\r\n        return Math.max(min, this);\r\n    },\r\n    KeepAtMost(max) {\r\n        return Math.min(max, this);\r\n    },\r\n    KeepBetween(min, max, allowFixMinMax = true) {\r\n        if (min > max && allowFixMinMax) {\r\n            [min, max] = [max, min];\r\n        }\r\n        if (this < min)\r\n            return min;\r\n        if (this > max)\r\n            return max;\r\n        return this;\r\n    },\r\n    WrapToRange(min, max, maxOut = true) {\r\n        let val = this;\r\n        let size = max - min;\r\n        while (val < min)\r\n            val += size;\r\n        while (maxOut ? val >= max : val > max)\r\n            val -= size;\r\n        return val;\r\n    },\r\n    Distance(other) {\r\n        return Math.abs(this - other);\r\n    },\r\n    ToPower(power) {\r\n        return Math.pow(this, power);\r\n    },\r\n};\r\nexport const NumberCE = CreateProxyForClassExtensions(NumberCE_funcs);\r\nexport const NumberCES = WithFuncsStandalone(NumberCE_funcs);\r\n//# sourceMappingURL=CE_Number.js.map","import { DeepGet, WithFuncsStandalone, CreateProxyForClassExtensions, ConvertPathGetterFuncToPropChain, DEL } from \"../Utils/General\";\r\nimport { ArrayCE } from \"./CE_Array\";\r\nimport { IsNaN } from \"../Utils/Types\";\r\nimport { FunctionCE } from \"./CE_Others\";\r\n/*export type WithFuncThisArgsAsXOrWrapped_Type<Source> = {\r\n    [P in keyof Source]:\r\n        Source[P] extends (this: infer ThisArgType, ...args)=>any ? (this: XOrWrapped<ThisArgType>, ...args: Parameters<Source[P]>)=>ReturnType<Source[P]> :\r\n        Source[P];\r\n};\r\nexport function WithFuncThisArgsAsXOrWrapped<Source>(source: Source): WithFuncThisArgsAsXOrWrapped_Type<Source> {\r\n    return source as any;\r\n}*/\r\nexport const specialKeys = [\"_\", \"_key\", \"_id\"];\r\nexport const ObjectCE_funcs = {\r\n    // base\r\n    // ==========\r\n    /** Helps you do stuff like this:\r\n        Array.prototype._AddFunction(function AddX(value) { this.push(value); }); []._AddX(\"newItem\"); */\r\n    _AddItem(name, value, forceAdd = false) {\r\n        if (name == null || name.length == 0)\r\n            throw new Error(\"No prop-name was specified for _AddItem() call.\");\r\n        if (name in this)\r\n            delete this[name];\r\n        if (name in this && !forceAdd)\r\n            return; // workaround for some properties not being deleted\r\n        Object.defineProperty(this, name, {\r\n            configurable: true,\r\n            value: value\r\n        });\r\n        /*if (this[name] == null)\r\n            throw new Error(`Failed to add property \"${name}\" to type \"${this}\".`);*/\r\n    },\r\n    _AddFunction(name, func) {\r\n        //this._AddItem(func.name || func.toString().match(/^function\\s*([^\\s(]+)/)[1], func);\r\n        ObjectCES._AddItem(this, name, func);\r\n    },\r\n    // the below helps you do stuff like this:\r\n    //\t\tArray.prototype._AddGetterSetter(\"AddX\", null, function(value) { this.push(value); }); [].AddX = \"newItem\";\r\n    _AddGetterSetter(name, getter, setter) {\r\n        //var name = (getter || setter).name || (getter || setter).toString().match(/^function\\s*([^\\s(]+)/)[1];\r\n        if (name in this)\r\n            delete this[name];\r\n        if (name in this)\r\n            return; // workaround for some properties not being deleted\r\n        let info = { configurable: true };\r\n        if (getter)\r\n            info.get = getter;\r\n        if (setter)\r\n            info.set = setter;\r\n        Object.defineProperty(this, name, info);\r\n    },\r\n    // the below helps you do stuff like this:\r\n    //\t\tArray.prototype._AddFunction_Inline = function AddX(value) { this.push(value); }; [].AddX = \"newItem\";\r\n    set _AddFunction_Inline(func) {\r\n        ObjectCES._AddFunction(this, FunctionCE(func).GetName(), func);\r\n    },\r\n    set _AddGetter_Inline(func) {\r\n        ObjectCES._AddGetterSetter(this, FunctionCE(func).GetName(), func, null);\r\n    },\r\n    set _AddSetter_Inline(func) {\r\n        ObjectCES._AddGetterSetter(this, FunctionCE(func).GetName(), null, func);\r\n    },\r\n    // normal\r\n    // ==========\r\n    //Object.prototype._AddSetter_Inline = function ExtendWith_Inline(value) { this.ExtendWith(value); };\r\n    //ExtendWith(value) { $.extend(this, value); };\r\n    /*GetItem_SetToXIfNull(itemName, /*;optional:*#/ defaultValue) {\r\n        if (!this[itemName])\r\n            this[itemName] = defaultValue;\r\n        return this[itemName];\r\n    };*/\r\n    // must also do it on window/global, for some reason\r\n    /*g.Extend = function(x) {\r\n        for (var name in x) {\r\n            var value = x[name];\r\n            //if (value !== undefined)\r\n            this[name] = value;\r\n        }\r\n        return this;\r\n    };*/\r\n    Extend(x, copyNonEnumerable = true) {\r\n        if (x != null) {\r\n            for (const key of Object[copyNonEnumerable ? \"getOwnPropertyNames\" : \"keys\"](x)) {\r\n                //if (!x.hasOwnProperty(key)) continue;\r\n                var value = x[key];\r\n                //if (value !== undefined)\r\n                this[key] = value;\r\n            }\r\n        }\r\n        return this;\r\n    },\r\n    // as replacement for C#'s \"new MyClass() {prop = true}\"\r\n    /*VSet<T>(this: T, propName: string, propValue, options?: VSet_Options): TargetTFor<T>;\r\n    //VSet<T extends RealThis>(this: T, props: any, options?: VSet_Options): T; // variant for ObjectCE(obj).X calls (those types only uses the last declaration, and they need \"extend RealThis\" since we any-ify the this-param)\r\n    VSet<T>(this: T, props: any, options?: VSet_Options): TargetTFor<T>; // this one needs to be last (best override for the CE(...) wrapper, and it can only extract the last one)*/\r\n    VSet: (function (...args) {\r\n        let props, opt, propName, propValue;\r\n        if (typeof args[0] == \"object\")\r\n            [props, opt] = args;\r\n        else\r\n            [propName, propValue, opt] = args;\r\n        opt = opt || {};\r\n        let copyNonEnumerable = opt.copyNonEnumerable != null ? opt.copyNonEnumerable : true;\r\n        const SetProp = (name, value) => {\r\n            if (value === DEL || (value === undefined && opt.deleteUndefined) || (value === null && opt.deleteNull) || (value === \"\" && opt.deleteEmpty)) {\r\n                delete this[name];\r\n                return;\r\n            }\r\n            if (opt.prop) {\r\n                Object.defineProperty(this, name, Object.assign({ configurable: true }, opt.prop, { value }));\r\n            }\r\n            else {\r\n                this[name] = value;\r\n            }\r\n        };\r\n        if (props) {\r\n            /*for (let key in props) {\r\n                if (!props.hasOwnProperty(key)) continue;*/\r\n            for (const key of Object[copyNonEnumerable ? \"getOwnPropertyNames\" : \"keys\"](props)) {\r\n                SetProp(key, props[key]);\r\n            }\r\n        }\r\n        else {\r\n            SetProp(propName, propValue);\r\n        }\r\n        return this;\r\n    }),\r\n    Extended(x, copyNonEnumerable = true) {\r\n        let result = this instanceof Array ? [] : {};\r\n        for (const key of Object[copyNonEnumerable ? \"getOwnPropertyNames\" : \"keys\"](this)) {\r\n            result[key] = this[key];\r\n        }\r\n        if (x) {\r\n            for (const key of Object[copyNonEnumerable ? \"getOwnPropertyNames\" : \"keys\"](x)) {\r\n                result[key] = x[key];\r\n            }\r\n        }\r\n        return result;\r\n    },\r\n    /*interface Object { Extended2<T>(this, x: T): T; }\r\n    Extended2(x) {\r\n        return this.Extended(x);\r\n    };*/\r\n    //E(x) { return this.Extended(x); };\r\n    SafeGet: (function (pathOrPathGetterFunc, resultIfNull) {\r\n        let pathSegments = typeof pathOrPathGetterFunc == \"string\" ? pathOrPathGetterFunc : ConvertPathGetterFuncToPropChain(pathOrPathGetterFunc);\r\n        return DeepGet(this, pathSegments, resultIfNull);\r\n    }),\r\n    VAct(func) {\r\n        func.call(this, this);\r\n        return this;\r\n    },\r\n    As(type) {\r\n        Object.setPrototypeOf(this, type.prototype);\r\n        return this;\r\n    },\r\n    Strip() {\r\n        Object.setPrototypeOf(this, Object.getPrototypeOf({}));\r\n        return this;\r\n    },\r\n    Including(...keys) {\r\n        var result = this instanceof Array ? [] : {};\r\n        for (let key of keys) {\r\n            //if (!this.hasOwnProperty(key)) continue;\r\n            if (!(key in this))\r\n                continue; // we include the value, even if from prototype (user wouldn't list in keys array if didn't want it)\r\n            result[key] = this[key];\r\n        }\r\n        return result;\r\n    },\r\n    Excluding(...keys) {\r\n        //var result = Clone(this); // doesn't work with funcs\r\n        /*var result = Object.assign(this instanceof Array ? [] : {}, this as any);\r\n        for (let key of keys) {\r\n            delete result[key];\r\n        }*/\r\n        var result = this instanceof Array ? [] : {};\r\n        for (let key of Object.keys(this)) {\r\n            if (ArrayCE(keys).Contains(key))\r\n                continue;\r\n            result[key] = this[key];\r\n        }\r\n        return result;\r\n    },\r\n    IsOneOf(...values) {\r\n        if (ArrayCE(values).Contains(this)) {\r\n            return true;\r\n        }\r\n        // if the value-list contains the primitive-version of self, consider it a match -- otherwise calling \"test1\".IsOneOf(\"test1\", \"test2\") would fail\r\n        let isObjectFormOfPrimitive = this instanceof Boolean || this instanceof Number || this instanceof String;\r\n        if (isObjectFormOfPrimitive && ArrayCE(values).Contains(this.valueOf())) {\r\n            return true;\r\n        }\r\n        return false;\r\n    },\r\n    // todo: probably remove Props(), and instead just use Pairs(), since Props() sounds odd when used on arrays\r\n    /*declare global {\r\n        interface Object {\r\n            Props<T>(this: {[key: number]: T} | {[key: string]: T}, excludeSpecialProps?: boolean): {index: number, name: string, value: T}[];\r\n            Props<T>(excludeSpecialProps?: boolean): {index: number, name: string, value: T}[];\r\n        }\r\n    }\r\n    //interface Object { Props<ValueType>(excludeSpecialProps?: boolean): {index: number, name: string, value: ValueType}[]; }\r\n    Props(excludeSpecialProps = false) {\r\n        var result = [];\r\n        var i = 0;\r\n        for (var propName in this) {\r\n            if (excludeSpecialProps && (propName == \"_\" || propName == \"_key\" || propName == \"_id\")) continue;\r\n            //result.push({index: i++, key: propName, name: propName, value: this[propName]});\r\n            result.push({index: i++, name: propName, value: this[propName]});\r\n        }\r\n        return result;\r\n    },*/\r\n    Pairs: (function (excludeSpecialKeys = false) {\r\n        var result = [];\r\n        var i = 0;\r\n        let keys = this instanceof Map ? Array.from(this.keys()) : Object.keys(this);\r\n        for (let key of keys) {\r\n            if (excludeSpecialKeys && (key == \"_\" || key == \"_key\" || key == \"_id\"))\r\n                continue;\r\n            let entry = { index: i++, key, keyNum: Number(key), value: this instanceof Map ? this.get(key) : this[key] };\r\n            if (IsNaN(entry.keyNum))\r\n                delete entry.keyNum;\r\n            result.push(entry);\r\n        }\r\n        return result;\r\n    }),\r\n    VKeys: (function (excludeSpecialKeys = false) {\r\n        //if (excludeSpecialKeys) return this.Props(true).map(a=>a.name);\r\n        let keys = this instanceof Map ? Array.from(this.keys()) : Object.keys(this);\r\n        if (excludeSpecialKeys)\r\n            keys = ArrayCE(keys).Except(specialKeys);\r\n        return keys;\r\n    }),\r\n    VValues: (function (excludeSpecialKeys = false) {\r\n        //if (excludeSpecialKeys) return this.Props(true).map(a=>a.value);\r\n        return ObjectCES.VKeys(this, excludeSpecialKeys).map(key => this instanceof Map ? this.get(key) : this[key]);\r\n    }),\r\n    // for symbols\r\n    /*Pairs_Sym() {\r\n    };*/\r\n    Sym(symbolName) {\r\n        let symbols = Object.getOwnPropertySymbols(this);\r\n        let symbol = symbols.find(a => a.toString() == `Symbol(${symbolName})`);\r\n        return this[symbol];\r\n    },\r\n};\r\n//export const ObjectCE = WithFuncsStandalone(ObjectCEProxy.prototype);\r\n//export const ObjectCE = CreateProxyForClassExtensions(ObjectCEProxy);\r\nexport const ObjectCE = CreateProxyForClassExtensions(ObjectCE_funcs);\r\nexport const ObjectCES = WithFuncsStandalone(ObjectCE_funcs);\r\n//# sourceMappingURL=CE_Object.js.map","import { WithFuncsStandalone, CreateProxyForClassExtensions } from \"../Utils/General\";\r\n/*\r\nThere are two ways to make a class-extension<or>standalone-functions system:\r\n1) Define the functions as class methods, and create a typescript extractor that creates versions of those methods, with an added first parameter that is used as the this-arg.\r\n2) Define them as standalone functions, and create a typescript extractor that creates versions of those methods, with a real this-arg that is extracted and supplied as the first parameter.\r\nThe \"Extract\" function below shows how to do approach 2. (we currently instead use approach 1, since I use them as class methods more frequently, and only the source approach allows function overloads)\r\n*/\r\n/*function Test1(a, b: string, c) {}\r\n\r\n/*type ExtractArgs2Plus<T> = FirstParameterType<T>;\r\nexport function Extract(func: (...args: any[])=>any) {\r\n    return (...args: Parameters<typeof func>)=>any;\r\n}\r\nexport const Test1_Next = Extract(Test1);\r\ntype FirstParameterType<T> = T extends (a: infer U, ...args: infer T2) => any ? T2 : unknown;*#/\r\n\r\ntype Extract_Type<T> =\r\n        //T extends (...args)=>any ? (thisArg: Object, ...args: Parameters<T>)=>ReturnType<T> :\r\n        T extends (firstParam: infer FirstParam, ...args: infer RestOfParams)=>any ? (...args: RestOfParams)=>ReturnType<T> :\r\n        T;\r\nexport function Extract<T>(source: T): Extract_Type<T> {\r\n    return null as any;\r\n}\r\n\r\nconst Test2 = Extract(Test1);\r\nexport type exports1 = {Test2: typeof Test2};\r\n\r\ndeclare global {\r\n    interface String extends exports1 {}\r\n}\r\n\"\".Test2(\"\", 5);*/\r\nexport const FunctionCE_funcs = {\r\n    GetName() {\r\n        //return this.name_fake || this.name || this.toString().match(/^function\\s*([^\\s(]+)/)[1];\r\n        //return this[\"name_fake\"] || this.name || (this.toString().match(/^function\\s*([^\\s(]+)/) || [])[1];\r\n        return this.name || (this.toString().match(/^function\\s*([^\\s(]+)/) || [])[1];\r\n    },\r\n    SetName(name) {\r\n        //this[\"name_fake\"] = name;\r\n        Object.defineProperty(this, \"name\", { value: name, configurable: true }); // can only set func.name using Object.defineProperty\r\n        return this;\r\n    },\r\n    AddTag(tag) {\r\n        if (this[\"tags\"] == null)\r\n            this[\"tags\"] = [];\r\n        this[\"tags\"].push(tag);\r\n        return this;\r\n    },\r\n    /*Function.prototype._AddFunction_Inline = function AddTags(/*o:*#/ tags___) { // (already implemented in VDF.js file)\r\n        if (this.tags == null)\r\n            this.tags = [];\r\n        for (var i in arguments)\r\n            this.tags.push(arguments[i]);\r\n        return this;\r\n    };*/\r\n    /*function AddTags() {\r\n        var tags = V.Slice(arguments, 0, arguments.length - 1);\r\n        var func = V.Slice(arguments).Last();\r\n        func.AddTags.apply(func, tags);\r\n    };*/\r\n    GetTags(type) {\r\n        return (this[\"tags\"] || []).Where(a => type == null || a instanceof type);\r\n    },\r\n    //AsStr(...args) { return require(\"../../V/V\").Multiline(this, ...args); };\r\n    //AsStr(useExtraPreprocessing) { return require(\"../../V/V\").Multiline(this, useExtraPreprocessing); };\r\n    RunThenReturn(...args) {\r\n        this.apply(null, args);\r\n        return this;\r\n    },\r\n};\r\nexport const FunctionCE = CreateProxyForClassExtensions(FunctionCE_funcs);\r\nexport const FunctionCES = WithFuncsStandalone(FunctionCE_funcs);\r\nfunction isLeapYear(year) {\r\n    return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0));\r\n}\r\nfunction getDaysInMonth(year, month) {\r\n    return [31, (isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];\r\n}\r\nexport const DateCE_funcs = {\r\n    get MonthDate() {\r\n        return new Date(this.getFullYear(), this.getMonth(), 1);\r\n    },\r\n    IsLeapYear() {\r\n        return isLeapYear(this.getFullYear());\r\n    },\r\n    GetDaysInMonth() {\r\n        return getDaysInMonth(this.getFullYear(), this.getMonth());\r\n    },\r\n    AddMonths(value) {\r\n        var n = this.getDate();\r\n        this.setDate(1);\r\n        this.setMonth(this.getMonth() + value);\r\n        this.setDate(Math.min(n, DateCE(this).GetDaysInMonth()));\r\n        return this;\r\n    },\r\n    Clone() {\r\n        return new Date(this.getTime());\r\n    },\r\n};\r\nexport const DateCE = CreateProxyForClassExtensions(DateCE_funcs);\r\nexport const DateCES = WithFuncsStandalone(DateCE_funcs);\r\n/*export class ErrorCEProxy {\r\n    get Stack() {\r\n        // this causes the full stack-trace to be attached to the Error object (in Chrome)\r\n        if ((Error as any).captureStackTrace) {\r\n            //(Error as any).captureStackTrace(instance, GetStackTraceStr);\r\n            (Error as any).captureStackTrace(this);\r\n        }\r\n        return this.stack;\r\n    }\r\n}\r\nexport const ErrorCE = CreateProxyForClassExtensions(ErrorCEProxy);*/ \r\n//# sourceMappingURL=CE_Others.js.map","import { ArrayCE } from \"./CE_Array\";\r\nimport { WithFuncsStandalone, CreateProxyForClassExtensions } from \"../Utils/General\";\r\nexport const StringCE_funcs = {\r\n    TrimStart(...chars) {\r\n        // fix for if called by VDF (which has a different signature)\r\n        //if (arguments[0] instanceof Array) chars = arguments[0];\r\n        for (var iOfFirstToKeep = 0; iOfFirstToKeep < this.length && ArrayCE(chars).Contains(this[iOfFirstToKeep]); iOfFirstToKeep++)\r\n            ;\r\n        return this.slice(iOfFirstToKeep, this.length);\r\n    },\r\n    TrimEnd(...chars) {\r\n        for (var iOfLastToKeep = this.length - 1; iOfLastToKeep >= 0 && ArrayCE(chars).Contains(this[iOfLastToKeep]); iOfLastToKeep--)\r\n            ;\r\n        return this.substr(0, iOfLastToKeep + 1);\r\n    },\r\n    Contains(str, startIndex) {\r\n        return this.indexOf(str, startIndex) !== -1;\r\n    },\r\n    hashCode() {\r\n        var hash = 0;\r\n        for (var i = 0; i < this.length; i++) {\r\n            var char = this.charCodeAt(i);\r\n            hash = ((hash << 5) - hash) + char;\r\n            hash |= 0; // convert to 32-bit integer\r\n        }\r\n        return hash;\r\n    },\r\n    Matches(strOrRegex) {\r\n        if (typeof strOrRegex == \"string\") {\r\n            let str = strOrRegex;\r\n            let result = [];\r\n            let lastMatchIndex = -1;\r\n            while (true) {\r\n                let matchIndex = this.indexOf(str, lastMatchIndex + 1);\r\n                if (matchIndex == -1)\r\n                    break; // if another match was not found\r\n                result.push({ index: matchIndex });\r\n                lastMatchIndex = matchIndex;\r\n            }\r\n            return result;\r\n        }\r\n        let regex = strOrRegex;\r\n        if (!regex.global) {\r\n            throw new Error(\"Regex must have the 'g' flag added. (otherwise an infinite loop occurs)\"); // todo: make alternate solution, like setting flag ourselves\r\n        }\r\n        let result = [];\r\n        let match;\r\n        while (match = regex.exec(this)) {\r\n            result.push(match);\r\n        }\r\n        return result;\r\n    },\r\n    /*matches_group(regex, /*o:*#/ groupIndex) {\r\n        if (!regex.global)\r\n            throw new Error(\"Regex must have the 'g' flag added. (otherwise an infinite loop occurs)\");\r\n\r\n        groupIndex = groupIndex || 0; // default to the first capturing group\r\n        var matches = [];\r\n        var match;\r\n        while (match = regex.exec(this))\r\n            matches.push(match[groupIndex]);\r\n        return matches;\r\n    }*/\r\n    /** indexX is 0-based */\r\n    IndexOf_X(str, indexX) {\r\n        var currentPos = -1;\r\n        for (var i = 0; i <= indexX; i++) {\r\n            var subIndex = this.indexOf(str, currentPos + 1);\r\n            if (subIndex == -1)\r\n                return -1; // no such xth index\r\n            currentPos = subIndex;\r\n        }\r\n        return currentPos;\r\n    },\r\n    /** indexFromLastX is 0-based */\r\n    IndexOf_XFromLast(str, indexFromLastX) {\r\n        var currentPos = (this.length - str.length) + 1; // index just after the last-index-where-match-could-occur\r\n        for (var i = 0; i <= indexFromLastX; i++) {\r\n            var subIndex = this.lastIndexOf(str, currentPos - 1);\r\n            if (subIndex == -1)\r\n                return -1; // no such xth index\r\n            currentPos = subIndex;\r\n        }\r\n        return currentPos;\r\n    },\r\n    IndexOfAny(...strings) {\r\n        var lowestIndex = -1;\r\n        for (let str of strings) {\r\n            var indexOfChar = this.indexOf(str);\r\n            if (indexOfChar != -1 && (indexOfChar < lowestIndex || lowestIndex == -1))\r\n                lowestIndex = indexOfChar;\r\n        }\r\n        return lowestIndex;\r\n    },\r\n    LastIndexOfAny(...strings) {\r\n        var highestIndex = -1;\r\n        for (let str of strings) {\r\n            var indexOfChar = this.lastIndexOf(str);\r\n            if (indexOfChar > highestIndex)\r\n                highestIndex = indexOfChar;\r\n        }\r\n        return highestIndex;\r\n    },\r\n    StartsWithAny(...strings) {\r\n        return ArrayCE(strings).Any(str => this.startsWith(str));\r\n    },\r\n    EndsWithAny(...strings) {\r\n        return ArrayCE(strings).Any(str => this.endsWith(str));\r\n    },\r\n    ContainsAny(...strings) {\r\n        return ArrayCE(strings).Any(str => StringCE(this).Contains(str));\r\n    },\r\n    /** Separator-strings must be escaped. (they're passed into a regular-expression) */\r\n    SplitByAny(...separators) {\r\n        /*var splitStr = \"/\";\r\n        for (let sep of separators)\r\n            splitStr += (splitStr.length > 1 ? \"|\" : \"\") + sep;\r\n        splitStr += \"/\";\r\n        return this.split(splitStr);*/\r\n        let regex = new RegExp(separators.map(a => `\\\\${a}`).join(\"|\"));\r\n        return this.split(regex);\r\n    },\r\n    SplitAt(index, includeCharAtIndex = false) {\r\n        if (index == -1) // if no split-index, pass source-string as part2 (makes more sense for paths and such)\r\n            return [\"\", this];\r\n        let part1 = this.substr(0, index);\r\n        let part2 = includeCharAtIndex ? this.substr(index) : this.substr(index + 1);\r\n        return [part1, part2];\r\n    },\r\n    Splice(index, removeCount, insert) {\r\n        return this.slice(0, index) + insert + this.slice(index + Math.abs(removeCount));\r\n    },\r\n    Indent(indentCount) {\r\n        var indentStr = \"\\t\".repeat(indentCount);\r\n        return this.replace(/^|(\\n)/g, \"$1\" + indentStr);\r\n    },\r\n    KeepAtMost(maxLength, moreMarkerStr = \"...\") {\r\n        if (this.length <= maxLength)\r\n            return this;\r\n        return this.substr(0, maxLength - moreMarkerStr.length) + moreMarkerStr;\r\n    },\r\n    // for firebase entry keys\r\n    /*interface String { readonly KeyToInt: number; }\r\n    String.prototype._AddGetter_Inline = function KeyToInt() {\r\n        return parseInt((this as string).substr(1));\r\n    }\r\n    interface Number { readonly IntToKey: string; }\r\n    Number.prototype._AddGetter_Inline = function IntToKey() {\r\n        return \"e\" + this;\r\n    }*/\r\n    /** Creates a function from \"func\", setting its name to the \"this\" string's value. */\r\n    Func(func) {\r\n        func.SetName(this);\r\n        return func;\r\n    },\r\n    // special; creates a function with the given name, but also caches it per caller-line,\r\n    //   so every call from that line returns the same function instance\r\n    // REMOVED, because: we need to create new funcs to capture new closure values\r\n    /*var oneFuncCache = {};\r\n    OneFunc(func) {\r\n        var funcName = this;\r\n        var callerLineStr = new Error().stack.split(\"\\n\")[3];\r\n        var funcKey = `${funcName}@${callerLineStr}`;\r\n        if (oneFuncCache[funcKey] == null) {\r\n            func.SetName(this);\r\n            //func.cached = true;\r\n            oneFuncCache[funcKey] = func;\r\n        }\r\n        return oneFuncCache[funcKey];\r\n    }*/\r\n    /**\r\n     * Reformats a multi-line string to represent the actual intended \"block\" of text.\r\n     * @param desiredIndent How much to indent each line. (after removal of the first-non-empty-line indent-length from each of them)\r\n     * @param removeLineStr A special string which, if found in a line, will cause that line to be removed from the result.\r\n     */\r\n    AsMultiline(desiredIndent = null, removeLineStr = \"@RL\") {\r\n        let result = this.substring(this.indexOf(\"\\n\") + 1, this.lastIndexOf(\"\\n\"));\r\n        if (desiredIndent != null) {\r\n            let firstLineIndent = (result.match(/^\\t+/) || [\"\"])[0].length;\r\n            if (firstLineIndent) {\r\n                let lines = result.split(\"\\n\");\r\n                // remove X tabs from start of each line (where X is firstLineIndent)\r\n                lines = lines.map(line => line.replace(new RegExp(`^\\t{0,${firstLineIndent}}`), \"\"));\r\n                // add the desired indent\r\n                lines = lines.map(line => \"\\t\".repeat(desiredIndent) + line);\r\n                // filter out lines with the special remove-line string\r\n                lines = lines.filter(a => !a.includes(removeLineStr));\r\n                result = lines.join(\"\\n\");\r\n            }\r\n        }\r\n        return result;\r\n    },\r\n    Substring(start, end) {\r\n        if (end < 0)\r\n            end = this.length + end;\r\n        return this.substring(start, end);\r\n    },\r\n    ToInt() { return parseInt(Number(this) + \"\"); },\r\n    ToFloat() { return Number(this); },\r\n};\r\nexport const StringCE = CreateProxyForClassExtensions(StringCE_funcs);\r\nexport const StringCES = WithFuncsStandalone(StringCE_funcs);\r\n//# sourceMappingURL=CE_String.js.map","export class JSVE {\r\n}\r\nJSVE.logFunc = console.log;\r\n//# sourceMappingURL=JSVE.js.map","import { GetStackTraceStr } from \"./General\";\r\nimport { JSVE } from \"../JSVE\";\r\nexport function Assert(condition, messageOrMessageFunc) {\r\n    if (condition)\r\n        return;\r\n    var message = messageOrMessageFunc instanceof Function ? messageOrMessageFunc() : messageOrMessageFunc;\r\n    JSVE.logFunc(`Assert failed) ${message}\\n\\nStackTrace) ${GetStackTraceStr()}`);\r\n    console.error(\"Assert failed) \" + message);\r\n    let skipError = false; // add flag which you can use to skip the error, when paused in debugger\r\n    debugger;\r\n    if (!skipError)\r\n        throw new Error(\"Assert failed) \" + message);\r\n}\r\nexport function AssertWarn(condition, messageOrMessageFunc) {\r\n    if (condition)\r\n        return;\r\n    var message = messageOrMessageFunc instanceof Function ? messageOrMessageFunc() : messageOrMessageFunc;\r\n    console.warn(`Assert-warn failed) ${message}\\n\\nStackTrace) ${GetStackTraceStr()}`);\r\n}\r\n// this version throws an error with only the provided message -- for ones the user may well see, and which don't need the stack (or \"Assert failed) \" text)\r\n/*g.Extend({AssertSimple});\r\nexport function AssertSimple(condition, messageOrMessageFunc?: string | Function) {\r\n    if (condition) return;\r\n\r\n    var message = (messageOrMessageFunc as any) instanceof Function ? (messageOrMessageFunc as any)() : messageOrMessageFunc;\r\n\r\n    Log(`Assert failed) ${message}\\n\\nStackTrace) ${V.GetStackTraceStr()}`);\r\n    console.error(\"Assert failed) \" + message);\r\n    debugger;\r\n    throw new Error(message);\r\n}*/\r\nexport class A {\r\n    static get NonNull_() {\r\n        return function (value) {\r\n            Assert(value != null, () => `Value cannot be null. (provided value: ${value})`);\r\n            return value;\r\n        };\r\n    }\r\n    static set NonNull(value) {\r\n        A.NonNull_(value);\r\n    }\r\n    static NotEqualTo(val1) {\r\n        return new A_NotEqualTo_Wrapper(val1);\r\n    }\r\n}\r\nexport class A_NotEqualTo_Wrapper {\r\n    constructor(val1) { this.val1 = val1; }\r\n    set a(val2) { Assert(val2 != this.val1); }\r\n}\r\nexport class A_OfType_Wrapper {\r\n    constructor(type) { this.type = type; }\r\n    set a(val) { Assert(val != null && val.GetType().IsDerivedFrom(this.type)); }\r\n}\r\n//# sourceMappingURL=Assert.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { TryCall } from \"./Timers\";\r\nimport { Assert, ToJSON, IsObject, IsString, FromJSON, ObjectCE, IsFunction } from \"..\";\r\nimport { GetTreeNodesInObjTree } from \"./General\";\r\nexport class BridgeMessage {\r\n    constructor(initialData) {\r\n        ObjectCE(this).Extend(initialData);\r\n    }\r\n}\r\n/*export class Bridge_Options {\r\n    receiveChannelMessageFunc_adder: (receiveDataFunc: (channelMessage: string | Object)=>any)=>any;\r\n    receiveChannelMessageFunc_addImmediately? = true;\r\n    sendChannelMessageFunc: (channelMessage: string | Object)=>any;\r\n    channel_wrapBridgeMessage? = true;\r\n    channel_stringifyChannelMessageObj? = true;\r\n    channel_safeCallbacks? = false;\r\n}*/\r\nexport class Bridge {\r\n    /** Don't worry about having to discard some calls before receiveTextFunc receives it. We automatically discard entries that aren't valid bridge-messages. */\r\n    constructor(options) {\r\n        /** Useful to ensure we ignore non-jsve-bridge messages. (the channel might be used by other systems as well) */\r\n        this.channel_wrapBridgeMessage = true;\r\n        /** Needed if the channel only supports strings being sent/received. */\r\n        this.channel_stringifyChannelMessageObj = true;\r\n        /** Needed if the channel has >2 members; makes-so call-ids are random-numbers, and are filtered by each member to just the ones it knows it initiated. */\r\n        this.channel_safeCallbacks = false;\r\n        // for receiving function-calls (and callbacks) from external bridge\r\n        // ==========\r\n        this.functions = {};\r\n        this.ignoreMissingFunctions = false;\r\n        // callback system (for when passing a function as an argument, or awaiting the result of a remote call)\r\n        // ==========\r\n        this.lastCallbackID = -1;\r\n        this.callbacks = {};\r\n        ObjectCE(this).Extend(ObjectCE(options).Excluding(\"receiveChannelMessageFunc_addImmediately\"));\r\n        if (options.receiveChannelMessageFunc_addImmediately != false)\r\n            this.SetUpReceiver();\r\n    }\r\n    // low level data-transfer\r\n    // ==========\r\n    SetUpReceiver() {\r\n        // add our own receive-text-func right now\r\n        this.receiveChannelMessageFunc = channelMessage => {\r\n            let channelMessageObj;\r\n            if (this.channel_stringifyChannelMessageObj && IsString(channelMessage))\r\n                channelMessageObj = TryCall(() => FromJSON(channelMessage)) || {};\r\n            if (!this.channel_stringifyChannelMessageObj && IsObject(channelMessage))\r\n                channelMessageObj = channelMessage;\r\n            let bridgeMessage = this.channel_wrapBridgeMessage ? channelMessageObj && channelMessageObj[\"JSVE_Bridge_message\"] : channelMessageObj;\r\n            if (!IsObject(bridgeMessage))\r\n                return;\r\n            this.DeserializeFuncsIn(bridgeMessage);\r\n            if (bridgeMessage.callFunction_name)\r\n                this.OnReceiveFunctionCall(bridgeMessage);\r\n            if (bridgeMessage.callCallback_id != null)\r\n                this.OnReceiveCallback(bridgeMessage);\r\n        };\r\n        this.receiveChannelMessageFunc_adder(this.receiveChannelMessageFunc);\r\n    }\r\n    SendBridgeMessage(bridgeMessage) {\r\n        this.SerializeFuncsIn(bridgeMessage);\r\n        let channelMessageObj = this.channel_wrapBridgeMessage ? { JSVE_Bridge_message: bridgeMessage } : bridgeMessage;\r\n        let channelMessage = this.channel_stringifyChannelMessageObj ? ToJSON(channelMessageObj) : channelMessageObj;\r\n        this.sendChannelMessageFunc(channelMessage);\r\n    }\r\n    RegisterFunction(name, func) {\r\n        if (this.functions[name])\r\n            throw new Error(`Cannot register the same function-name twice: \"${name}\"`);\r\n        this.functions[name] = func;\r\n    }\r\n    UnregisterFunction(name) {\r\n        delete this.functions[name];\r\n    }\r\n    OnReceiveFunctionCall(bridgeMessage) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let result = yield this.Local_CallFunc(bridgeMessage.callFunction_name, ...bridgeMessage.callFunction_args);\r\n            this.CallCallback(bridgeMessage.callFunction_callbackID, result);\r\n        });\r\n    }\r\n    // we use async/await here, to support waiting for the registered function if it happens to be async (if it isn't, that's fine -- the async/await doesn't hurt anything)\r\n    Local_CallFunc(funcName, ...args) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let func = this.functions[funcName];\r\n            if (this.ignoreMissingFunctions && func == null)\r\n                return;\r\n            Assert(func, `Cannot find function \"${funcName}\".`);\r\n            return yield func(...args);\r\n        });\r\n    }\r\n    OnReceiveCallback(bridgeMessage) {\r\n        this.Local_CallCallback(bridgeMessage.callCallback_id, bridgeMessage.callCallback_args);\r\n    }\r\n    Local_CallCallback(callbackID, callbackArgs) {\r\n        let callback = this.callbacks[callbackID];\r\n        if (callback == null) {\r\n            if (this.channel_safeCallbacks)\r\n                return;\r\n            Assert(false, `Cannot find callback with id ${callbackID}!`);\r\n        }\r\n        callback(...callbackArgs);\r\n    }\r\n    RegisterCallback(callback) {\r\n        let callbackID = this.channel_safeCallbacks ? Math.random() : this.lastCallbackID + 1;\r\n        this.lastCallbackID = callbackID;\r\n        this.callbacks[callbackID] = callback;\r\n        return callbackID;\r\n    }\r\n    // technically, this just prepares the functions in the tree for serialization (by setting a toJSON key, which JSON.stringify uses)\r\n    SerializeFuncsIn(argTree) {\r\n        let nodes = GetTreeNodesInObjTree(argTree);\r\n        for (let node of nodes) {\r\n            if (IsFunction(node.Value)) {\r\n                let callbackID = this.RegisterCallback(node.Value);\r\n                node.Value.toJSON = () => ({ serializedFunc_callbackID: callbackID });\r\n            }\r\n        }\r\n    }\r\n    DeserializeFuncsIn(argTree) {\r\n        let nodes = GetTreeNodesInObjTree(argTree);\r\n        for (let node of nodes) {\r\n            if (node.Value != null && node.Value.serializedFunc_callbackID != null) {\r\n                let callbackID = node.Value.serializedFunc_callbackID;\r\n                let proxyFunc = (...args) => {\r\n                    this.CallCallback(callbackID, ...args);\r\n                };\r\n                node.Value = proxyFunc;\r\n            }\r\n        }\r\n    }\r\n    // for sending function-calls to external bridge\r\n    // ==========\r\n    Call(funcName, ...args) {\r\n        return new Promise((resolve, reject) => {\r\n            let awaitReturn_callbackID = this.RegisterCallback(resolve);\r\n            let bridgeMessage = new BridgeMessage({ callFunction_callbackID: awaitReturn_callbackID, callFunction_name: funcName, callFunction_args: args });\r\n            this.SendBridgeMessage(bridgeMessage);\r\n        });\r\n    }\r\n    CallCallback(callbackID, ...args) {\r\n        let bridgeMessage = new BridgeMessage({ callCallback_id: callbackID, callCallback_args: args });\r\n        this.SendBridgeMessage(bridgeMessage);\r\n    }\r\n}\r\n//# sourceMappingURL=Bridge.js.map","import { ToJSON } from \"./General\";\r\nexport function GetPropsChanged(oldObj, newObj, returnNullIfSame = true, useJSONCompare = false) {\r\n    oldObj = oldObj || {}, newObj = newObj || {};\r\n    let keys = oldObj.VKeys().concat(newObj.VKeys()).Distinct();\r\n    let result = [];\r\n    for (let key of keys) {\r\n        let newVal_forComparison = useJSONCompare ? ToJSON(newObj[key]) : newObj[key];\r\n        let oldVal_forComparison = useJSONCompare ? ToJSON(oldObj[key]) : oldObj[key];\r\n        if (newVal_forComparison !== oldVal_forComparison) {\r\n            result.push({ key, oldVal: oldObj[key], newVal: newObj[key] });\r\n        }\r\n    }\r\n    if (result.length == 0 && returnNullIfSame)\r\n        return null;\r\n    return result;\r\n}\r\n/*export function GetUpdates(oldData, newData, useNullInsteadOfUndefined = true) {\r\n    const result = {};\r\n    for (const key of oldData.VKeys(true).concat(newData.VKeys(true))) {\r\n        if (newData[key] !== oldData[key]) {\r\n            result[key] = newData[key];\r\n            if (newData[key] === undefined && useNullInsteadOfUndefined) {\r\n                result[key] = null;\r\n            }\r\n        }\r\n    }\r\n    return RemoveHelpers(result);\r\n}*/ \r\n//# sourceMappingURL=Changes.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { IsPrimitive, IsString, IsObject } from \"./Types\";\r\nimport { Assert, ArrayCE, NumberCE, ObjectCE, StringCE } from \"..\";\r\nlet g = typeof window == \"object\" ? window : global;\r\nif (Number.MIN_SAFE_INTEGER == null) {\r\n    Number.MIN_SAFE_INTEGER = -9007199254740991;\r\n}\r\nif (Number.MAX_SAFE_INTEGER == null) {\r\n    Number.MAX_SAFE_INTEGER = 9007199254740991;\r\n}\r\ng[\"G\"] = G;\r\nfunction G(...globalHolders) {\r\n    for (let globalHolder of globalHolders) {\r\n        Object.assign(g, globalHolder);\r\n    }\r\n}\r\nexport function DoNothing(...args) { }\r\nexport function DN(...args) { }\r\n//var quickIncrementValues = {};\r\n//export function QuickIncrement(name = new Error().stack.split(\"\\n\")[2]) { // this doesn't always work, fsr\r\nexport function QuickIncrement(name = \"default\") {\r\n    QuickIncrement[\"values\"][name] = (QuickIncrement[\"values\"][name] | 0) + 1;\r\n    return QuickIncrement[\"values\"][name];\r\n}\r\nQuickIncrement[\"values\"] = [];\r\nexport const emptyObj = {};\r\nexport const eo = emptyObj; // used for (maybeNullVar || eo).prop;\r\nexport const emptyArray = [];\r\nexport const emptyArray_forLoading = [];\r\nexport function E(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20) {\r\n    var result = {};\r\n    for (let extend of Array.from(arguments)) {\r\n        Object.assign(result, extend);\r\n    }\r\n    // if result is empty, return the same empty-obj each time so it doesn't trigger react-js rerenders\r\n    if (emptyObj && result.VKeys().length == 0) {\r\n        return emptyObj;\r\n    }\r\n    return result;\r\n    //return StyleSheet.create(result);\r\n}\r\nexport function WrapWithGo(func) {\r\n    Object.defineProperty(func, \"Go\", {\r\n        /*set: arg1=>{\r\n            func(arg1);\r\n        },*/\r\n        set: func,\r\n    });\r\n    return func;\r\n}\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\n// Performs equality by iterating through keys on an object and returning false when any key has values which are not strictly equal between the arguments.\r\n// Returns true when the values of all keys are strictly equal.\r\nexport function ShallowEquals(objA, objB) {\r\n    if (Object.is(objA, objB))\r\n        return true;\r\n    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null)\r\n        return false;\r\n    var keysA = Object.keys(objA);\r\n    var keysB = Object.keys(objB);\r\n    if (keysA.length !== keysB.length)\r\n        return false;\r\n    // test for A's keys different from B\r\n    for (var i = 0; i < keysA.length; i++) {\r\n        if (!hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexport function ShallowChanged(objA, objB) {\r\n    return !ShallowEquals(objA, objB);\r\n}\r\nexport function CopyText(text) {\r\n    /*\r\n    //var note = $(`<input type=\"text\">`).appendTo(\"body\");\r\n    var note = document.createElement(\"textarea\");\r\n    document.body.appendChild(note);\r\n    note.innerHTML = text;\r\n\r\n    note.focus();\r\n    var range = document.createRange();\r\n    range.setStart(note, 0);\r\n    range.setEnd(note, 1);\r\n    //range.setEnd(note2, 0);\r\n\r\n    //range.setEnd(e(\"notesEnder\"), 0); // adds one extra new-line; that's okay, right?\r\n    var sel = window.getSelection();\r\n    sel.removeAllRanges();\r\n    sel.addRange(range);\r\n\r\n    document.execCommand(\"copy\");*/\r\n    document.oncopy = function (event) {\r\n        event.clipboardData.setData(\"text/plain\", text);\r\n        event.preventDefault();\r\n        document.oncopy = null;\r\n    };\r\n    document.execCommand(\"copy\", false, null);\r\n}\r\n// methods: serialization\r\n// ==========\r\n// object-Json\r\nexport function FromJSON(json) { return JSON.parse(json); }\r\n/*declare global { function ToJSON(obj, ...excludePropNames): string; } g.Extend({ToJSON});\r\nexport function ToJSON(obj, ...excludePropNames): string {\r\n    try {\r\n        if (arguments.length > 1) {\r\n            return JSON.stringify(obj, function(key, value) {\r\n                if (excludePropNames.Contains(key))\r\n                    return;\r\n                return value;\r\n            });\r\n        }\r\n        return JSON.stringify(obj);\r\n    }\r\n    catch (ex) {\r\n        if (ex.toString() == \"TypeError: Converting circular structure to JSON\")\r\n            return ToJSON_Safe.apply(this, arguments);\r\n        throw ex;\r\n    }\r\n}*/\r\nexport function ToJSON(obj, replacerFunc, spacing) {\r\n    try {\r\n        return JSON.stringify(obj, replacerFunc, spacing);\r\n    }\r\n    catch (ex) {\r\n        if (ex.toString() == \"TypeError: Converting circular structure to JSON\")\r\n            return ToJSON_Safe.apply(this, arguments);\r\n        throw ex;\r\n    }\r\n}\r\nexport class ToJSON_WithSpaces_Options {\r\n    constructor() {\r\n        this.insideObjectBraces = false;\r\n        this.insideArrayBrackets = false;\r\n        this.betweenPropsOrItems = true;\r\n        this.betweenPropNameAndValue = true;\r\n    }\r\n}\r\nexport function ToJSON_WithSpaces(obj, options) {\r\n    options = E(new ToJSON_WithSpaces_Options(), options);\r\n    let result = JSON.stringify(obj, null, 1); // stringify, with line-breaks and indents\r\n    result = result.replace(/^ +/gm, \" \"); // remove all but the first space for each line\r\n    result = result.replace(/\\n/g, \"\"); // remove line-breaks\r\n    if (!options.insideObjectBraces)\r\n        result = result.replace(/{ /g, \"{\").replace(/ }/g, \"}\");\r\n    if (!options.insideArrayBrackets)\r\n        result = result.replace(/\\[ /g, \"[\").replace(/ \\]/g, \"]\");\r\n    if (!options.betweenPropsOrItems)\r\n        result = result.replace(/, /g, \",\");\r\n    if (!options.betweenPropNameAndValue)\r\n        result = result.replace(/\": /g, `\":`);\r\n    return result;\r\n}\r\nexport function ToJSON_Safe(obj, ...excludePropNames) {\r\n    var cache = [];\r\n    var foundDuplicates = false;\r\n    var result = JSON.stringify(obj, function (key, value) {\r\n        if (ArrayCE(excludePropNames).Contains(key))\r\n            return;\r\n        if (typeof value == 'object' && value !== null) {\r\n            // if circular reference found, discard key\r\n            if (cache.indexOf(value) !== -1) {\r\n                foundDuplicates = true;\r\n                return;\r\n            }\r\n            cache.push(value); // store value in our cache\r\n        }\r\n        return value;\r\n    });\r\n    //cache = null; // enable garbage collection\r\n    if (foundDuplicates)\r\n        result = \"[was circular]\" + result;\r\n    return result;\r\n}\r\nexport function ToJSON_Try(...args) {\r\n    try {\r\n        return ToJSON.apply(this, args);\r\n    }\r\n    catch (ex) { }\r\n    return \"[converting to JSON failed]\";\r\n}\r\nexport function Clone(obj, keepPrototype = false) {\r\n    if (obj == null)\r\n        return obj;\r\n    let result = FromJSON(ToJSON(obj));\r\n    if (keepPrototype == true) {\r\n        Object.setPrototypeOf(result, Object.getPrototypeOf(obj));\r\n    }\r\n    return result;\r\n}\r\nexport function CloneWithPrototypes(originalObject, keepCircularLinks = false) {\r\n    if (originalObject == null)\r\n        return originalObject;\r\n    let copies = [{\r\n            source: originalObject,\r\n            target: Array.isArray(originalObject) ? [] : Object.create(Object.getPrototypeOf(originalObject)),\r\n        }];\r\n    let cloneObject = copies[0].target;\r\n    let sourceReferences = [originalObject];\r\n    let targetReferences = [cloneObject];\r\n    // First in, first out\r\n    let current;\r\n    while (current = copies.shift()) {\r\n        let keys = Object.getOwnPropertyNames(current.source);\r\n        for (let propertyIndex = 0; propertyIndex < keys.length; propertyIndex++) {\r\n            // Save the source's descriptor\r\n            let descriptor = Object.getOwnPropertyDescriptor(current.source, keys[propertyIndex]);\r\n            if (!descriptor.value || typeof descriptor.value !== 'object') {\r\n                Object.defineProperty(current.target, keys[propertyIndex], descriptor);\r\n                continue;\r\n            }\r\n            let nextSource = descriptor.value;\r\n            descriptor.value = Array.isArray(nextSource) ? [] : Object.create(Object.getPrototypeOf(nextSource));\r\n            if (keepCircularLinks) {\r\n                let indexOf = sourceReferences.indexOf(nextSource);\r\n                if (indexOf !== -1) {\r\n                    // The source is already referenced, just assign reference\r\n                    descriptor.value = targetReferences[indexOf];\r\n                    Object.defineProperty(current.target, keys[propertyIndex], descriptor);\r\n                    continue;\r\n                }\r\n                sourceReferences.push(nextSource);\r\n                targetReferences.push(descriptor.value);\r\n            }\r\n            Object.defineProperty(current.target, keys[propertyIndex], descriptor);\r\n            copies.push({ source: nextSource, target: descriptor.value });\r\n        }\r\n    }\r\n    return cloneObject;\r\n}\r\n/*export function Range(min, max, step = 1, includeMax = true) {\r\n    var result: number[] = [];\r\n    for (let i = min; includeMax ? i <= max : i < max; i += step)\r\n        result.push(i);\r\n    return result;\r\n}*/\r\n/**\r\n * Gets an array of the numbers between min and max.\r\n * @param min\r\n * @param max\r\n * @param step (default: 1)\r\n * @param includeMax (default: true)\r\n * @param roundToStep (default: true)\r\n */\r\nexport function Range(min, max, step = 1, includeMax = true, roundToStep = true) {\r\n    var result = [];\r\n    for (let i = min; includeMax ? i <= max : i < max; i = roundToStep ? NumberCE(i + step).RoundTo(step) : i + step) {\r\n        result.push(i);\r\n    }\r\n    return result;\r\n}\r\nexport function Global(target) {\r\n    //var name = (target as any).GetName();\r\n    var name = target[\"name_fake\"] || target.name || (target.toString().match(/^function\\s*([^\\s(]+)/) || [])[1];\r\n    //console.log(\"Globalizing: \" + name);\r\n    g[name] = target;\r\n}\r\nexport class IDProvider {\r\n    constructor() {\r\n        this.lastID = -1;\r\n    }\r\n    GetID() {\r\n        return ++this.lastID;\r\n    }\r\n}\r\nexport const nl = \"\\n\";\r\nexport function AsObj(obj) {\r\n    if (typeof obj == \"object\")\r\n        return obj;\r\n    if (obj != null)\r\n        return obj.Props().ToMap(a => a.name, a => a.value);\r\n    return {};\r\n}\r\nexport function AsArray(args) { return Slice(args, 0); }\r\n;\r\n//s.ToArray = function(args) { return s.Slice(args, 0); };\r\nexport function Slice(args, start, end) { return Array.prototype.slice.call(args, start != null ? start : 0, end); }\r\n;\r\n/*static startupInfo = null;\r\nstatic startupInfoRequested = false;\r\nstatic postStartupInfoReceivedFuncs = [];\r\nstatic WaitForStartupInfoThenRun(func) {\r\n    if (startupInfo)\r\n        func(startupInfo);\r\n    else\r\n        V.postStartupInfoReceivedFuncs.push(func);\r\n}*/\r\n// example:\r\n// var multilineText = V.Multiline(function() {/*\r\n//\t\tText that...\r\n//\t\tspans multiple...\r\n//\t\tlines.\r\n// */});\r\nexport function Multiline(functionWithInCommentMultiline, useExtraPreprocessing) {\r\n    useExtraPreprocessing = useExtraPreprocessing != null ? useExtraPreprocessing : true;\r\n    var text = functionWithInCommentMultiline.toString().replace(/\\r/g, \"\");\r\n    // some extra preprocessing\r\n    if (useExtraPreprocessing) {\r\n        text = text.replace(/@@.*/g, \"\"); // remove single-line comments\r\n        //text = text.replace(/@\\**?\\*@/g, \"\"); // remove multi-line comments\r\n        text = text.replace(/@\\*/g, \"/*\").replace(/\\*@/g, \"*/\"); // fix multi-line comments\r\n    }\r\n    var firstCharPos = text.indexOf(\"\\n\", text.indexOf(\"/*\")) + 1;\r\n    return text.substring(firstCharPos, text.lastIndexOf(\"\\n\"));\r\n}\r\nexport function Multiline_NotCommented(functionWithCode) {\r\n    var text = functionWithCode.toString().replace(/\\r/g, \"\");\r\n    var firstCharOfSecondLinePos = text.indexOf(\"\\n\") + 1;\r\n    var enderOfSecondLastLine = text.lastIndexOf(\"\\n\");\r\n    var result = text.substring(firstCharOfSecondLinePos, enderOfSecondLastLine);\r\n    result = result.replace(/\\t/g, \"    \");\r\n    // replace the start and end tokens of special string-containers (used for keeping comments in-tact)\r\n    result = result.replace(/['\"]@((?:.|\\n)+)@['\"];(\\n(?=\\n))?/g, (match, sub1) => sub1.replace(/\\\\n/, \"\\n\"));\r\n    return result;\r\n}\r\nexport function StableSort(array, compare) {\r\n    var array2 = array.map((item, index) => ({ index, item }));\r\n    array2.sort((a, b) => {\r\n        var r = compare(a.item, b.item, a.index, b.index);\r\n        return r != 0 ? r : Compare(a.index, b.index);\r\n    });\r\n    return array2.map(pack => pack.item);\r\n}\r\nexport function Compare(a, b, caseSensitive = true) {\r\n    if (!caseSensitive && typeof a == \"string\" && typeof b == \"string\") {\r\n        a = a.toLowerCase();\r\n        b = b.toLowerCase();\r\n    }\r\n    return a < b ? -1 : (a > b ? 1 : 0);\r\n}\r\n// just use the word 'percent', even though value is represented as fraction (e.g. 0.5, rather than 50[%])\r\nexport function Lerp(from, to, percentFromXToY, keepResultInRange = true) {\r\n    let result = from + ((to - from) * percentFromXToY);\r\n    if (keepResultInRange)\r\n        result = NumberCE(result).KeepBetween(from, to);\r\n    return result;\r\n}\r\nexport function GetPercentFromXToY(start, end, val, keepResultInRange = true) {\r\n    // distance-from-x / distance-from-x-required-for-result-'1'\r\n    var result = (val - start) / (end - start);\r\n    if (keepResultInRange)\r\n        result = NumberCE(result).KeepBetween(0, 1);\r\n    return result;\r\n}\r\nexport function GetXToY(minX, maxY, interval = 1) {\r\n    var result = [];\r\n    for (var val = minX; val <= maxY; val += interval) {\r\n        result.push(val);\r\n    }\r\n    return result;\r\n}\r\nexport function GetXToYOut(minX, maxOutY, interval = 1) {\r\n    var result = [];\r\n    for (var val = minX; val < maxOutY; val += interval) {\r\n        result.push(val);\r\n    }\r\n    return result;\r\n}\r\nexport function CloneObject(obj, propMatchFunc, depth = 0) {\r\n    /*var Assert = require(\"../../Frame/General/Assert\").Assert;\r\n    Assert(depth < 100, \"CloneObject cannot work past depth 100! (probably circular ref)\");*/\r\n    if (obj == null)\r\n        return null;\r\n    if (IsPrimitive(obj))\r\n        return obj;\r\n    //if (obj.GetType() == Array)\r\n    if (obj.constructor == Array)\r\n        return CloneArray(obj);\r\n    /*if (obj instanceof List)\r\n        return List.apply(null, [obj.itemType].concat(V.CloneArray(obj)));\r\n        if (obj instanceof Dictionary) {\r\n            let result = new Dictionary(obj.keyType, obj.valueType);\r\n            for (let pair of obj.Pairs)\r\n                result.Add(pair.key, pair.value);\r\n            return result;\r\n        }*/\r\n    let result = {};\r\n    for (let prop of obj.Props()) {\r\n        if (!(prop.value instanceof Function) && (propMatchFunc == null || propMatchFunc.call(obj, prop.name, prop.value)))\r\n            result[prop.name] = CloneObject(prop.value, propMatchFunc, depth + 1);\r\n    }\r\n    return result;\r\n}\r\nexport function CloneArray(array) {\r\n    //array.slice(0); //deep: JSON.parse(JSON.stringify(array));\r\n    return Array.prototype.slice.call(array, 0);\r\n}\r\n/*static IsEqual(a, b) {\r\n    function _equals(a, b) { return JSON.stringify(a) === JSON.stringify($.extend(true, {}, a, b)); }\r\n    return _equals(a, b) && _equals(b, a);\r\n};*/\r\nexport function Bind(func, newThis) {\r\n    return func.bind(newThis);\r\n}\r\n/*static ForEachChildInTreeXDoY(treeX: any, actionY: (value, key: string)=>void) {\r\n    for (let key in treeX) {\r\n        let value = treeX[key];\r\n        actionY(value, key);\r\n        if (typeof value == \"object\" || value instanceof Array)\r\n            V.ForEachChildInTreeXDoY(value, actionY);\r\n    }\r\n}*/\r\nfunction GetHiddenHolder() {\r\n    let holder = document.querySelector(\"#jsve_hiddenContainer\");\r\n    if (holder == null) {\r\n        holder = document.createElement(\"div\");\r\n        holder.id = \"jsve_hiddenContainer\";\r\n        ObjectCE(holder.style).Extend({ position: \"absolute\", left: `-1000px`, top: `-1000px`, width: `1000px`, height: `1000px`, overflow: \"hidden\" });\r\n        document.body.appendChild(holder);\r\n    }\r\n    return holder;\r\n}\r\nlet GetContentSize_cache = {};\r\nexport function GetContentSize(content, includeMargin = false, createClone = false, allowCache = true) {\r\n    /*var holder = $(\"#jsve_hiddenContainer\");\r\n    var contentClone = content.clone();\r\n    holder.append(contentClone);\r\n    var width = contentClone.outerWidth();\r\n    var height = contentClone.outerHeight();\r\n    contentClone.remove();*/\r\n    let cacheStore = IsString(content) ? GetContentSize_cache : (content[\"GetContentSize_cache\"] = content[\"GetContentSize_cache\"] || {});\r\n    let currentHTML = IsString(content) ? content : content.outerHTML;\r\n    let result = cacheStore[currentHTML];\r\n    if (result == null) {\r\n        let holder = GetHiddenHolder();\r\n        let testElement = IsString(content) ? $(content) : (createClone ? $(content).clone() : $(content));\r\n        holder.appendChild(testElement[0]);\r\n        var width = testElement.outerWidth(includeMargin);\r\n        var height = testElement.outerHeight(includeMargin);\r\n        testElement.remove();\r\n        result = { width, height };\r\n        if (allowCache) {\r\n            cacheStore[currentHTML] = result;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexport function GetContentWidth(content, includeMargin = false, createClone = false, allowCache = true) {\r\n    return GetContentSize(content, includeMargin, createClone, allowCache).width;\r\n}\r\nexport function GetContentHeight(content, includeMargin = false, createClone = false, allowCache = true) {\r\n    return GetContentSize(content, includeMargin, createClone, allowCache).height;\r\n}\r\nexport let autoElements = {};\r\nexport function GetAutoElement(startHTML) {\r\n    if (autoElements[startHTML] == null) {\r\n        let holder = GetHiddenHolder();\r\n        let element = $(startHTML)[0];\r\n        holder.appendChild(element);\r\n        autoElements[startHTML] = element;\r\n    }\r\n    return autoElements[startHTML];\r\n}\r\nexport class TreeNode {\r\n    constructor(ancestorNodes, obj, prop) {\r\n        this.ancestorNodes = ancestorNodes;\r\n        this.obj = obj;\r\n        this.prop = prop;\r\n    }\r\n    get PathNodes() {\r\n        if (this.prop == \"_root\")\r\n            return [];\r\n        return ArrayCE(this.ancestorNodes).Select(a => a.prop).concat(this.prop);\r\n    }\r\n    get PathStr() {\r\n        return this.PathNodes.join(\"/\");\r\n    }\r\n    get PathStr_Updeep() {\r\n        return this.PathNodes.join(\".\");\r\n    }\r\n    //value;\r\n    get Value() {\r\n        if (this.obj == null)\r\n            return undefined;\r\n        return this.obj[this.prop];\r\n    }\r\n    set Value(newVal) {\r\n        this.obj[this.prop] = newVal;\r\n    }\r\n}\r\nexport function GetTreeNodesInObjTree(obj, includeRootNode = false, _ancestorNodes = []) {\r\n    Assert(_ancestorNodes.length <= 300, \"Cannot traverse more than 300 levels into object tree. (probably circular)\");\r\n    let result = [];\r\n    if (includeRootNode)\r\n        result.push(new TreeNode([], { _root: obj }, \"_root\"));\r\n    /*for (let key in obj) {\r\n        if (!obj.hasOwnProperty(key)) continue;*/\r\n    for (const key of Object.keys(obj)) {\r\n        let value = obj[key];\r\n        let currentNode = new TreeNode(_ancestorNodes, obj, key);\r\n        result.push(currentNode);\r\n        if (value != null && IsObject(value)) {\r\n            ArrayCE(result).AddRange(GetTreeNodesInObjTree(value, false, _ancestorNodes.concat(currentNode)));\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/*export function CloneTreeDownToXWhileReplacingXValue(treeRoot, pathToX: string, newValueForX) {\r\n    let pathNodes = pathToX.split(\"/\");\r\n    let currentPathNode = pathNodes[0];\r\n    let currentPathNode_newValue = pathNodes.length > 1\r\n        ? CloneTreeDownToXWhileReplacingXValue(treeRoot[currentPathNode], pathNodes.Skip(1).join(\"/\"), newValueForX)\r\n        : newValueForX;\r\n    return {...treeRoot, [currentPathNode]: currentPathNode_newValue};\r\n}*/\r\nexport function GetTreeNodesInPath(treeRoot, pathNodesOrStr, includeRootNode = false, _ancestorNodes = []) {\r\n    let descendantPathNodes = pathNodesOrStr instanceof Array ? pathNodesOrStr : pathNodesOrStr.split(\"/\");\r\n    let childTreeNode = new TreeNode(_ancestorNodes, treeRoot, descendantPathNodes[0]);\r\n    var result = [];\r\n    if (includeRootNode) {\r\n        result.push(new TreeNode([], { _root: treeRoot }, \"_root\"));\r\n    }\r\n    result.push(childTreeNode);\r\n    if (descendantPathNodes.length > 1) { // if the path goes deeper than the current child-tree-node\r\n        result.push(...GetTreeNodesInPath(childTreeNode ? childTreeNode.Value : null, ArrayCE(descendantPathNodes).Skip(1).join(\"/\"), false, _ancestorNodes.concat(childTreeNode)));\r\n    }\r\n    return result;\r\n}\r\n/*export function GetTreeNodesInPath_WithRoot(treeRoot, path: string) {\r\n    return GetTreeNodesInPath({root: treeRoot}, \"root/\" + path).Skip(1);\r\n}*/\r\nexport function VisitTreeNodesInPath(treeRoot, pathNodesOrStr, visitFunc, visitRootNode = false, _ancestorNodes = []) {\r\n    if (visitRootNode)\r\n        visitFunc(new TreeNode([], { _root: treeRoot }, \"_root\"));\r\n    let descendantPathNodes = pathNodesOrStr instanceof Array ? pathNodesOrStr : pathNodesOrStr.split(\"/\");\r\n    let childTreeNode = new TreeNode(_ancestorNodes, treeRoot, descendantPathNodes[0]);\r\n    visitFunc(childTreeNode);\r\n    if (descendantPathNodes.length > 1) // if the path goes deeper than the current child-tree-node\r\n        VisitTreeNodesInPath(childTreeNode.Value, ArrayCE(descendantPathNodes).Skip(1).join(\"/\"), visitFunc, false, _ancestorNodes.concat(childTreeNode));\r\n    return treeRoot;\r\n}\r\n/*export function VisitTreeNodesInPath_WithRoot(treeRoot, path: string, visitFunc: (node: TreeNode)=>any) {\r\n    VisitTreeNodesInPath({root: treeRoot}, \"root/\" + path, visitFunc);\r\n    return treeRoot;\r\n}*/\r\nexport function ConvertPathGetterFuncToPropChain(pathGetterFunc) {\r\n    let funcStr = pathGetterFunc.toString();\r\n    Assert(!funcStr.includes(\"[\"), `State-getter-func cannot contain bracket-based property-access.\\n${nl}For variable inclusion, use multiple segments as in: ...ToPropChain(\"main\", \"mapViews\", mapID)`);\r\n    /*const pathStr = funcStr.match(/return [^.]+\\.(.+?);/)[1] as string;\r\n    //let result = pathStr.replace(/\\./g, \"/\");\r\n    const result = pathStr.split(\".\");*/\r\n    let parts = funcStr.split(\".\").slice(1); // remove first segment, since it's just the \"return xxx.\" part\r\n    parts[parts.length - 1] = parts[parts.length - 1].match(/^([a-zA-Z0-9_$]+)/)[1]; // remove semicolon (or whatever else) at the end\r\n    return parts;\r\n}\r\n/** @param sepChar Default: \"/\" */\r\nexport function DeepGet(obj, pathOrPathSegments, resultIfNull = null, sepChar = \"/\") {\r\n    let pathSegments = pathOrPathSegments instanceof Array ? pathOrPathSegments : pathOrPathSegments.split(sepChar);\r\n    let result = obj;\r\n    for (let pathNode of pathSegments) {\r\n        if (result == null)\r\n            break;\r\n        result = result[pathNode];\r\n    }\r\n    if (result == null)\r\n        return resultIfNull;\r\n    return result;\r\n}\r\n/** @param sepChar Default: \"/\" */\r\nexport function DeepSet(obj, pathOrPathSegments, newValue, sepChar = \"/\", createPathSegmentsIfMissing = true, deleteUndefined = false) {\r\n    let pathSegments = pathOrPathSegments instanceof Array ? pathOrPathSegments : pathOrPathSegments.split(sepChar);\r\n    let deepObj = obj;\r\n    // tunnel down to the object holding the path-specified prop\r\n    pathSegments.slice(0, -1).forEach(segment => {\r\n        if (deepObj[segment] == null) {\r\n            if (createPathSegmentsIfMissing) {\r\n                deepObj[segment] = {};\r\n            }\r\n            else {\r\n                Assert(false, `The given path (${pathSegments.join(\"/\")}) had a missing segment (${segment}), so the deep-set failed.`);\r\n            }\r\n        }\r\n        deepObj = deepObj[segment];\r\n    });\r\n    if (newValue === undefined && deleteUndefined) {\r\n        delete deepObj[ArrayCE(pathSegments).Last()];\r\n    }\r\n    else {\r\n        deepObj[ArrayCE(pathSegments).Last()] = newValue;\r\n    }\r\n}\r\n/** @param sepChar Default: \"/\" */\r\n/*export function WithDeepSet(baseObj, pathOrPathSegments: string | (string | number)[], newValue, sepChar = \"/\") {\r\n    let pathSegments = pathOrPathSegments instanceof Array ? pathOrPathSegments : pathOrPathSegments.split(sepChar);\r\n\r\n    let result;\r\n    let result_deep;\r\n    let baseObj_deep = baseObj;\r\n    // tunnel down to the given path, overwriting the result_deep and baseObj_deep variables along the way\r\n    pathSegments.forEach((segment, index)=> {\r\n        // initialize with correct constructor for special cases (there might be some others, but this is sufficient for now)\r\n        result_deep = baseObj_deep instanceof Array ? [...baseObj_deep] : {...baseObj_deep};\r\n        Object.setPrototypeOf(result_deep, Object.getPrototypeOf(baseObj_deep)); // set the prototype to match\r\n        result = result || result_deep;\r\n\r\n        if (index < pathSegments.length - 1) {\r\n            // tunnel down, for next iteration\r\n            result_deep = result_deep[segment];\r\n            baseObj_deep = baseObj_deep[segment];\r\n        } else {\r\n            result_deep[segment] = newValue;\r\n        }\r\n    });\r\n    return result;\r\n}*/\r\nexport function WithDeepSet(baseObj, pathOrPathSegments, newValue, sepChar = \"/\") {\r\n    let pathSegments = pathOrPathSegments instanceof Array ? pathOrPathSegments : pathOrPathSegments.split(sepChar);\r\n    return Object.assign(Object.assign({}, baseObj), { [pathSegments[0]]: pathSegments.length > 1 ? WithDeepSet(baseObj[pathSegments[0]], pathSegments.slice(1), newValue) : newValue });\r\n}\r\n//@((()=> { if (g.onclick == null) g.onclick = ()=>console.log(V.GetStackTraceStr()); }) as any)\r\nexport function GetStackTraceStr(...args) {\r\n    var stackTrace, sourceStackTrace = true;\r\n    if (IsString(args[0]))\r\n        [stackTrace, sourceStackTrace] = args;\r\n    else\r\n        [sourceStackTrace] = args;\r\n    //stackTrace = stackTrace || new Error()[sourceStackTrace ? \"Stack\" : \"stack\"];\r\n    //stackTrace = stackTrace || (sourceStackTrace ? StackTrace.get().then(stack=>stackTrace = stack.map(a=>a.toString()).join(\"\\n\")) : new Error().stack);\r\n    //stackTrace = stackTrace || new Error().stack;\r\n    if (stackTrace == null) {\r\n        //let fakeError = {}.VAct(a=>Error.captureStackTrace(a));\r\n        let oldStackLimit = Error.stackTraceLimit;\r\n        Error.stackTraceLimit = Infinity;\r\n        let fakeError = new Error();\r\n        stackTrace = fakeError.stack;\r\n        Error.stackTraceLimit = oldStackLimit;\r\n    }\r\n    return stackTrace.substr(StringCE(stackTrace).IndexOf_X(\"\\n\", 1)); // remove \"Error\" line and first stack-frame (that of this method)\r\n}\r\nexport function GetErrorMessagesUnderElement(element) {\r\n    //return element.querySelectorAll(\":invalid\").ToList().map(node=>node.validationMessage || `Invalid value.`);\r\n    return Array.from(element.querySelectorAll(\":invalid\")).map(node => node.validationMessage || `Invalid value.`);\r\n}\r\nexport const DEL = \"JS_VEXTENSIONS_SPECIAL_DELETE_KEY\";\r\nexport function FindDOM(selector) {\r\n    return document.querySelector(selector);\r\n}\r\nexport function FindDOMAll(selector) {\r\n    return Array.from(document.querySelectorAll(selector));\r\n}\r\nexport function WaitTillDataPathIsSet(dataPath) {\r\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n        let dataPathParts = dataPath.split(\".\");\r\n        let currentParent = g;\r\n        for (let part of dataPathParts) {\r\n            while (currentParent[part] == null) {\r\n                yield WaitTillPropertyIsSet(currentParent, part);\r\n            }\r\n            currentParent = currentParent[part];\r\n        }\r\n        resolve();\r\n    }));\r\n}\r\nexport function WaitTillPropertyIsSet(obj, prop) {\r\n    return new Promise((resolve, reject) => {\r\n        ObjectCE(obj)._AddGetterSetter(prop, () => { }, value => {\r\n            delete obj[prop]; // remove this hook\r\n            obj[prop] = value; // set to provided value\r\n            resolve();\r\n        });\r\n    });\r\n}\r\nexport var CapScheme;\r\n(function (CapScheme) {\r\n    /** examplePropNameWithDuoWord */ CapScheme[CapScheme[\"PropName\"] = 0] = \"PropName\";\r\n    /** Example Title With Duo-Word */ CapScheme[CapScheme[\"Title\"] = 1] = \"Title\";\r\n    /** Example sentence with duo-word */ CapScheme[CapScheme[\"Sentence\"] = 2] = \"Sentence\";\r\n})(CapScheme || (CapScheme = {}));\r\nexport function ChangeCapitalization(text, fromScheme, toScheme) {\r\n    let inStandardScheme = ConvertFromSchemeXToStandardScheme(text, fromScheme);\r\n    return ConvertFromStandardSchemeToSchemeX(inStandardScheme, toScheme);\r\n}\r\n// \"standard scheme\" is currently CapitalizeScheme.Sentence\r\nfunction ConvertFromSchemeXToStandardScheme(text, fromScheme) {\r\n    if (fromScheme == CapScheme.PropName) {\r\n        // demo string: somePropName\r\n        return text\r\n            // somePropName -> some prop name\r\n            .replace(/[A-Z]/g, a => \" \" + a.toLowerCase())\r\n            // some prop name -> Some prop name\r\n            .replace(/^./, a => a.toUpperCase());\r\n    }\r\n    else if (fromScheme == CapScheme.Title) {\r\n        Assert(false, \"Not yet implemented.\");\r\n    }\r\n    else if (fromScheme == CapScheme.Sentence) {\r\n        return text;\r\n    }\r\n}\r\nfunction ConvertFromStandardSchemeToSchemeX(text, toScheme) {\r\n    if (toScheme == CapScheme.PropName) {\r\n        Assert(false, \"Not yet implemented.\");\r\n    }\r\n    else if (toScheme == CapScheme.Title) {\r\n        Assert(false, \"Not yet implemented.\");\r\n    }\r\n    else if (toScheme == CapScheme.Sentence) {\r\n        return text;\r\n    }\r\n}\r\nexport function StartDownload(content, filename, dataTypeStr = \"data:application/octet-stream,\", encodeContentAsURIComp = true) {\r\n    var link = document.createElement(\"a\");\r\n    Object.assign(link.style, { display: \"none\" });\r\n    link.innerText = \"Save to disk\";\r\n    link.setAttribute(\"href\", dataTypeStr + (encodeContentAsURIComp ? encodeURIComponent(content) : content));\r\n    link.setAttribute(\"download\", filename);\r\n    document.body.appendChild(link);\r\n    link.click();\r\n    link.remove();\r\n}\r\nexport function StartUpload() {\r\n    return new Promise(resolve => {\r\n        let fileInput = document.createElement(\"input\");\r\n        fileInput.type = \"file\";\r\n        fileInput.style.display = \"none\";\r\n        fileInput.onchange = e => {\r\n            var file = e.target[\"files\"][0];\r\n            if (!file)\r\n                return;\r\n            var reader = new FileReader();\r\n            reader.onload = e => {\r\n                var contents = e.target[\"result\"];\r\n                //Assert(typeof contents == \"string\")\r\n                resolve(contents);\r\n            };\r\n            reader.readAsText(file);\r\n        };\r\n        document.body.appendChild(fileInput);\r\n        fileInput.click();\r\n    });\r\n}\r\nexport function TransferPrototypeProps(target, source, descriptorBase, descriptorOverride) {\r\n    //for (let [name, descriptor] of Object.entries(Object.getOwnPropertyDescriptors(source))) {\r\n    for (let name of Object.getOwnPropertyNames(source)) {\r\n        if (name == \"constructor\")\r\n            continue;\r\n        let descriptor = Object.getOwnPropertyDescriptor(source, name);\r\n        Object.defineProperty(target, name, Object.assign({}, descriptorBase, descriptor, descriptorOverride));\r\n    }\r\n}\r\nexport function WithFuncsStandalone(source) {\r\n    let result = {};\r\n    for (const key of Object.getOwnPropertyNames(source)) {\r\n        if (key == \"constructor\")\r\n            continue; // no reason to call the wrapper's constructor\r\n        const descriptor = Object.getOwnPropertyDescriptor(source, key);\r\n        const newDescriptor = Object.assign({}, descriptor);\r\n        if (descriptor.value instanceof Function) {\r\n            const oldFunc = descriptor.value;\r\n            newDescriptor.value = (thisArg, ...callArgs) => {\r\n                return oldFunc.apply(thisArg, callArgs);\r\n            };\r\n        }\r\n        Object.defineProperty(result, key, newDescriptor);\r\n    }\r\n    return result;\r\n}\r\n/*export type WithFuncThisArgsAsAny_Type<T> = {\r\n    [P in keyof T]:\r\n        T[P] extends (this: any, ...args)=>any ? (this: any, ...args: Parameters<T[P]>)=>ReturnType<T[P]> :\r\n        T[P];\r\n};\r\nexport function WithFuncThisArgsAsAny<T>(source: T): WithFuncThisArgsAsAny_Type<T> {\r\n    return source as any;\r\n}*/\r\n/*export type WithFuncThisArgTypesWrappedBy_Type<T> = {\r\n    [P in keyof T]:\r\n        T[P] extends (this: infer T2, ...args)=>any ? (this: T<T2>, ...args: Parameters<T[P]>)=>ReturnType<T[P]> :\r\n        T[P];\r\n};\r\nexport function WithFuncThisArgTypesWrappedBy<T>(source: T): WithFuncThisArgTypesWrappedBy_Type<T> {\r\n    return source as any;\r\n}*/\r\n// use this simpler variant for class-extensions of target-types, where the class-extension methods don't need the type-generics of the target-type\r\n/*export function CreateProxyForClassExtensions_ThisAsAny<T>(sourceClass: new(...args: any[])=>T) {\r\n    return CreateProxyForClassExtensions<WithFuncThisArgsAsAny_Type<T>>(sourceClass as any);\r\n}*/\r\n//export function CreateProxyForClassExtensions<T>(sourceClass: new(...args: any[])=>T) {\r\n//export function CreateProxyForClassExtensions(sourceClass_prototype: any) {\r\n// old comment: we don't use this (specifying types at time of proxy-creation), as it would cause loss/simplifying of type-data for function calls\r\nexport function CreateProxyForClassExtensions(sourceClass_prototype) {\r\n    // proxy approach; nicer, but I don't like potential slowdown from creating new proxy each time a class-extension method is called!\r\n    /*return (thisArg: any)=> {\r\n        return new Proxy({}, {\r\n            get(target, key, receiver?) {\r\n                if (key == \"constructor\") return Reflect.get(target, key, receiver); // no reason to call the wrapper's constructor\r\n                let descriptor = Object.getOwnPropertyDescriptor(sourceClass.prototype, key);\r\n                if (descriptor.value instanceof Function) {\r\n                    let oldFunc = descriptor.value as Function;\r\n                    return (...callArgs)=> {\r\n                        return oldFunc.apply(thisArg, callArgs);\r\n                    };\r\n                }\r\n            }\r\n        //}) as T;\r\n        }) as WithFuncThisArgsAsAny_Type<T>;\r\n    };*/\r\n    // Static proxy approach -- a bit faster since it doesn't create any functions, closures, or proxies per wrap/CE-method-call.\r\n    //\t(Limitation: you can't store the result of \"ObjectCE(something)\" and call a method attached to it more than once, since each method-call removes the supplied this-arg from the stack.)\r\n    /*let proxy = {} as any;\r\n    const thisArgStack = [];*/\r\n    let proxy = {};\r\n    const thisArgStack = [];\r\n    for (const key of Object.getOwnPropertyNames(sourceClass_prototype)) {\r\n        if (key == \"constructor\")\r\n            continue; // no reason to call the wrapper's constructor\r\n        const descriptor = Object.getOwnPropertyDescriptor(sourceClass_prototype, key);\r\n        const newDescriptor = Object.assign({}, descriptor);\r\n        if (descriptor.value instanceof Function) {\r\n            const oldFunc = descriptor.value;\r\n            newDescriptor.value = (...callArgs) => {\r\n                const thisArg = thisArgStack[thisArgStack.length - 1];\r\n                const result = oldFunc.apply(thisArg, callArgs);\r\n                //thisArgStack.length--;\r\n                thisArgStack.splice(thisArgStack.length - 1, 1);\r\n                return result;\r\n            };\r\n        }\r\n        Object.defineProperty(proxy, key, newDescriptor);\r\n    }\r\n    //return (nextThis: any)=> {\r\n    return (nextThis) => {\r\n        thisArgStack.push(nextThis);\r\n        return proxy;\r\n    };\r\n}\r\n//# sourceMappingURL=General.js.map","import { Assert, IsNumber, NumberCE, ArrayCE } from \"..\";\r\nexport class TimerContext {\r\n    constructor() {\r\n        this.timers = [];\r\n    }\r\n    Reset() {\r\n        for (let timer of this.timers) {\r\n            timer.Stop();\r\n        }\r\n        this.timers = [];\r\n    }\r\n    // Can be useful on platforms (eg. Android) where setInterval() and setTimeout() stop working when the screen is off.\r\n    // Just have the Android code call the js every second or so, running this method; this will force the timer-functions to be manually triggered once they've passed the expected tick-time.\r\n    ManuallyTriggerOverdueTimers() {\r\n        for (let timer of this.timers) {\r\n            if (timer.NextTickFuncOverdue) {\r\n                timer.nextTickFunc();\r\n            }\r\n        }\r\n    }\r\n}\r\nTimerContext.default = new TimerContext();\r\nTimerContext.default_autoAddAll = false;\r\n// methods\r\n// ==========\r\nexport function TryCall(func, ...args) {\r\n    //if (!(func instanceof Function)) return;\r\n    if (typeof func != \"function\")\r\n        return;\r\n    try {\r\n        return func.apply(this, args);\r\n    }\r\n    catch (ex) { }\r\n}\r\nexport function TryCall_OnX(obj, func, ...args) {\r\n    if (typeof func != \"function\")\r\n        return;\r\n    try {\r\n        return func.apply(obj, args);\r\n    }\r\n    catch (ex) { }\r\n}\r\n/*let oldTimeout = setTimeout;\r\ng.setTimeout = function(func: Function, delayInMS = 0, ...args) {\r\n    // setTimeout can take really long on Chrome mobile (eg. while scrolling), for some reason (like, 1.5 seconds)\r\n    // on desktop, setImmediate is better as well, since it takes ~0ms instead of 1-15ms\r\n    if (delayInMS == 0)\r\n        return setImmediate(func, ...args);\r\n    return oldTimeout(func, delayInMS, ...args);\r\n}*/\r\n/*export function Sleep(ms) {\r\n    var startTime = new Date().getTime();\r\n    while (new Date().getTime() - startTime < ms) {}\r\n}*/\r\nconst maxTimeoutLength = 0x7FFFFFFF; // setTimeout limit is MAX_INT32=(2^31-1)\r\nexport function WaitXThenRun(delayInMS, func, ...args) {\r\n    Assert(delayInMS <= maxTimeoutLength, `Cannot wait for longer than ${maxTimeoutLength} ms. (use WaitUntilXThenRun, if a long-delay is needed)`);\r\n    // setTimeout can take really long on Chrome mobile (eg. while scrolling), for some reason (like, 1.5 seconds)\r\n    // on desktop, setImmediate is better as well, since it takes ~0ms instead of 1-15ms\r\n    if (delayInMS == 0) {\r\n        return window[\"setImmediate\"](func, ...args); // same as below\r\n    }\r\n    return setTimeout(func, delayInMS, ...args); // \"as any\": maybe temp; used to allow source-importing from NodeJS\r\n}\r\nexport function WaitUntilXThenRun(targetDateTimeInMS, func, ...args) {\r\n    var now = Date.now();\r\n    var diff = NumberCE(targetDateTimeInMS - now).KeepAtLeast(0);\r\n    if (diff > maxTimeoutLength) {\r\n        WaitXThenRun(maxTimeoutLength, () => WaitUntilXThenRun(targetDateTimeInMS, func));\r\n    }\r\n    else {\r\n        WaitXThenRun(diff, func);\r\n    }\r\n}\r\nexport function SleepAsync(timeMS) {\r\n    return new Promise((resolve, reject) => {\r\n        WaitXThenRun(timeMS, resolve);\r\n    });\r\n}\r\nexport function SleepAsyncUntil(targetDateTimeInMS) {\r\n    return new Promise((resolve, reject) => {\r\n        WaitUntilXThenRun(targetDateTimeInMS, resolve);\r\n    });\r\n}\r\nvar DoNothingXTimesThenDoY_counters = {};\r\nexport function DoNothingXTimesThenDoY(doNothingCount, func, key = \"default\") {\r\n    if (DoNothingXTimesThenDoY_counters[key] == null) {\r\n        DoNothingXTimesThenDoY_counters[key] = 0;\r\n    }\r\n    if (DoNothingXTimesThenDoY_counters[key] >= doNothingCount) {\r\n        func();\r\n    }\r\n    DoNothingXTimesThenDoY_counters[key]++;\r\n}\r\n// interval is in seconds (can be decimal)\r\nexport class Timer {\r\n    constructor(intervalInMS, func, maxCallCount = -1) {\r\n        this.timerID = -1;\r\n        this.callCount_thisRun = 0;\r\n        this.callCount_total = 0;\r\n        Assert(IsNumber(intervalInMS), \"Interval must be a number.\");\r\n        this.intervalInMS = intervalInMS;\r\n        this.func = func;\r\n        this.maxCallCount = maxCallCount;\r\n        if (TimerContext.default_autoAddAll) {\r\n            TimerContext.default.timers.push(this);\r\n        }\r\n    }\r\n    SetContext(timerContext) {\r\n        Assert(timerContext, \"TimerContext cannot be null.\");\r\n        this.timerContexts = (this.timerContexts || []).concat(timerContext);\r\n        timerContext.timers.push(this);\r\n        return this;\r\n    }\r\n    RemoveFromContext(timerContext) {\r\n        ArrayCE(this.timerContexts).Remove(timerContext);\r\n        ArrayCE(timerContext.timers).Remove(this);\r\n    }\r\n    ClearContexts() {\r\n        for (let context of this.timerContexts) {\r\n            this.RemoveFromContext(context);\r\n        }\r\n    }\r\n    get IsRunning() { return this.timerID != -1; }\r\n    get NextTickFuncOverdue() {\r\n        return this.nextTickTime != null && Date.now() > this.nextTickTime && this.nextTickFunc != null;\r\n    }\r\n    Start(initialDelayOverride = null) {\r\n        // if start is called when it's already running, stop the timer first (thus we restart the timer instead of causing overlapping setIntervals/delayed-func-calls)\r\n        if (this.IsRunning)\r\n            this.Stop();\r\n        this.startTime = Date.now();\r\n        const StartRegularInterval = () => {\r\n            this.nextTickTime = this.startTime + this.intervalInMS;\r\n            this.timerID = setInterval(this.nextTickFunc = () => {\r\n                this.callCount_thisRun++;\r\n                this.callCount_total++;\r\n                this.func();\r\n                if (this.maxCallCount != -1 && this.callCount_thisRun >= this.maxCallCount) {\r\n                    this.Stop();\r\n                }\r\n                else {\r\n                    //this.nextTickTime += this.intervalInMS;\r\n                    this.nextTickTime = Date.now() + this.intervalInMS; // using Date.now() prevents the prop from getting out-of-sync (from sleep-mode)\r\n                }\r\n            }, this.intervalInMS); // \"as any\": maybe temp; used to allow source-importing from NodeJS\r\n        };\r\n        if (initialDelayOverride != null) {\r\n            this.nextTickTime = this.startTime + initialDelayOverride;\r\n            this.timerID = setTimeout(this.nextTickFunc = () => {\r\n                this.callCount_thisRun++;\r\n                this.callCount_total++;\r\n                this.func();\r\n                if (this.maxCallCount != -1 && this.callCount_thisRun >= this.maxCallCount) {\r\n                    this.Stop();\r\n                }\r\n                else {\r\n                    StartRegularInterval();\r\n                }\r\n            }, initialDelayOverride); // \"as any\": maybe temp; used to allow source-importing from NodeJS\r\n        }\r\n        else {\r\n            StartRegularInterval();\r\n        }\r\n        return this; // enable chaining, for SetContext() call\r\n    }\r\n    Stop() {\r\n        clearInterval(this.timerID);\r\n        //this.startTime = null;\r\n        this.nextTickTime = null;\r\n        this.nextTickFunc = null;\r\n        this.timerID = -1;\r\n        this.callCount_thisRun = 0;\r\n    }\r\n}\r\nexport class TimerS extends Timer {\r\n    constructor(interval_decimal, func, maxCallCount = -1) {\r\n        super(interval_decimal * 1000, func, maxCallCount);\r\n    }\r\n}\r\nvar funcLastScheduledRunTimes = {};\r\nexport function BufferAction(...args) {\r\n    if (args.length == 2)\r\n        var [minInterval, func] = args, key = null;\r\n    else if (args.length == 3)\r\n        var [key, minInterval, func] = args;\r\n    var lastScheduledRunTime = funcLastScheduledRunTimes[key] || 0;\r\n    var now = new Date().getTime();\r\n    var timeSinceLast = now - lastScheduledRunTime;\r\n    if (timeSinceLast >= minInterval) { // if we've waited enough since last run, run right now\r\n        func();\r\n        funcLastScheduledRunTimes[key] = now;\r\n    }\r\n    else {\r\n        let waitingForNextRunAlready = lastScheduledRunTime > now;\r\n        if (!waitingForNextRunAlready) { // else, if we're not already waiting for next-run, schedule next-run\r\n            var nextRunTime = lastScheduledRunTime + minInterval;\r\n            var timeTillNextRun = nextRunTime - now;\r\n            WaitXThenRun(timeTillNextRun, func);\r\n            funcLastScheduledRunTimes[key] = nextRunTime;\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=Timers.js.map","// standard types\r\n// ----------\r\n/*export class bool extends Boolean {}\r\nexport class int extends Number {}\r\nexport class double extends Number {}\r\nexport var string = \"string\" as any as (new(..._)=>string);*/\r\nexport var bool = () => \"bool\";\r\nexport var int = () => \"int\";\r\nexport var double = () => \"double\";\r\nexport var string = () => \"string\";\r\nexport function IsNaN(obj) { return typeof obj == \"number\" && obj != obj; }\r\nexport function IsPrimitive(obj) { return IsBool(obj) || IsNumber(obj) || IsString(obj); }\r\nexport function IsBool(obj) { return typeof obj == \"boolean\"; } //|| obj instanceof Boolean\r\nexport function ToBool(boolStr) { return boolStr == \"true\" ? true : false; }\r\nexport function IsArray(obj) { return Array.isArray(obj); } // for briefness and/or consistency\r\nexport function IsObject(obj) { return typeof obj == \"object\"; }\r\n//export function IsObjectOf<T>(obj) : obj is T { return typeof obj == \"object\"; }\r\n//export function IsOfType<T>(obj, typeConstructor: new()=>T) : obj is T { return obj.constructor.name == typeConstructor.name; }\r\nexport function IsTypeX(obj, typeConstructor) { return obj instanceof typeConstructor; }\r\nexport function IsNumberString(obj, allowNaN = false) { return IsString(obj) && obj.length && IsNumber(Number(obj), false, allowNaN); }\r\nexport function IsNumber(obj, allowNumberObj = false, allowNaN = false) {\r\n    if (!allowNaN && IsNaN(obj))\r\n        return false;\r\n    return typeof obj == \"number\" || (allowNumberObj && obj instanceof Number);\r\n}\r\n/** Basically the same as Number(...), accepting numbers, and converting number-strings of these forms:\r\n1) \"010\" -> 10 [ES5+], 8 [<ES5]\r\n2) \"0x10\" -> 16\r\n3) \"5e3\" -> 5000\r\nDoes *not* convert values of these forms (instead returns valIfConversionFails -- by default NaN):\r\n4) null -> ?\r\n5) \"\" -> ?*/\r\nexport function ToNumber(stringOrFloatVal, valIfConversionFails = NaN) {\r\n    if (!IsString(stringOrFloatVal) && !IsNumber(stringOrFloatVal))\r\n        return valIfConversionFails;\r\n    if (IsString(stringOrFloatVal) && stringOrFloatVal.length == 0)\r\n        return valIfConversionFails;\r\n    return Number(stringOrFloatVal);\r\n}\r\nexport function IsInt(obj) { return IsNumber(obj) && parseInt(obj) == obj; }\r\nexport function ToInt(stringOrFloatVal, valIfConversionFails = NaN) { return parseInt(ToNumber(stringOrFloatVal, valIfConversionFails) + \"\"); }\r\n/*export function IsFloat(obj) : obj is number { return typeof obj == \"number\" && parseFloat(obj as any) != parseInt(obj as any); }\r\nexport function ToFloat(stringOrIntVal) { return parseFloat(stringOrIntVal); }*/\r\nexport function IsString(obj, allowStringObj = false) {\r\n    return typeof obj == \"string\" || (allowStringObj && obj instanceof String);\r\n}\r\nexport function ToString(val) { return \"\" + val; }\r\nexport function IsFunction(obj) {\r\n    //return obj instanceof Function;\r\n    return typeof obj == \"function\";\r\n}\r\nexport function IsConstructor(obj) {\r\n    //return obj instanceof Function && obj.name;\r\n    return typeof obj == \"function\" && obj.name;\r\n}\r\n/*function TypeOrNameOrGetter_ToName<T>(typeOrNameOrGetter?: string | (new(..._)=>T) | ((_?)=>new(..._)=>T)): string {\r\n    return typeOrNameOrGetter instanceof Function && typeOrNameOrGetter.name ? typeOrNameOrGetter.name :\r\n        typeOrNameOrGetter instanceof Function ? (typeOrNameOrGetter as any)().name :\r\n        typeOrNameOrGetter;\r\n}*/\r\n// classes/enums\r\n// ==========\r\n/*var constructorHelper = function() {};\r\nexport function CreateClass(baseClass, classMembers) {\r\n    baseClass = baseClass || Object;\r\n\r\n    var result;\r\n\r\n    if (classMembers && classMembers.hasOwnProperty(\"constructor\"))\r\n        result = classMembers.constructor;\r\n    else\r\n        result = function () { return baseClass.apply(this, arguments); };\r\n\r\n    constructorHelper.prototype = baseClass.prototype;\r\n    result.prototype = new constructorHelper();\r\n\r\n    if (classMembers)\r\n        result.prototype.Extend(classMembers);\r\n\r\n    result.prototype.constructor = result;\r\n    result.__super__ = baseClass.prototype;\r\n\r\n    return result;\r\n}*/\r\n// enums\r\n// ==========\r\n/**\r\n * Typescript enums compile to an object with each `key = value` pair converted into two props: key->value, value->key\r\n * This function returns just the key->value pairs. (with each entry having the form {name: string, value: number | null})\r\n */\r\nexport function GetEntries(enumType, nameModifierFunc) {\r\n    //let entryNames = Object.keys(enumType).filter(a=>a.match(/^\\D/) != null);\r\n    // valid enum values are numbers and null, so any props other than those are the name->value props we want\r\n    /*let nameValuePairs = enumType.Pairs().filter(pair=>!IsNumberString(pair.key) && pair.key != \"null\");\r\n    return nameValuePairs.map(pair=>({name: nameModifierFunc ? nameModifierFunc(pair.key) : pair.key, value: pair.value as number}));*/\r\n    // valid enum values are numbers and null, so any keys other than those are the ones we want (they're the keys for the key->value pairs)\r\n    let entryNames = Object.keys(enumType).filter(key => !IsNumberString(key) && key != \"null\");\r\n    return entryNames.map(name => ({ name: nameModifierFunc ? nameModifierFunc(name) : name, value: enumType[name] }));\r\n}\r\nexport function GetValues(enumType) {\r\n    return GetEntries(enumType).map(a => a.value);\r\n}\r\nexport function GetValues_ForSchema(enumType) {\r\n    return GetValues(enumType).map(value => ({ const: value }));\r\n}\r\n//# sourceMappingURL=Types.js.map","import { E, Assert, StringCE, NumberCE } from \"..\";\r\nexport function ToAbsoluteUrl(url) {\r\n    // Handle absolute URLs (with protocol-relative prefix)\r\n    // Example: //domain.com/file.png\r\n    if (url.search(/^\\/\\//) != -1) {\r\n        return window.location.protocol + url;\r\n    }\r\n    // Handle absolute URLs (with explicit origin)\r\n    // Example: http://domain.com/file.png\r\n    if (url.search(/:\\/\\//) != -1) {\r\n        return url;\r\n    }\r\n    // Handle absolute URLs (without explicit origin)\r\n    // Example: /file.png\r\n    if (url.search(/^\\//) != -1) {\r\n        return window.location.origin + url;\r\n    }\r\n    // Handle relative URLs\r\n    // Example: file.png\r\n    var base = window.location.href.match(/(.*\\/)/)[0];\r\n    return base + url;\r\n}\r\nexport function JumpToHash(hashStr) {\r\n    var url = location.href; // Save down the URL without hash.\r\n    location.href = \"#\" + hashStr; // Go to the target element.\r\n    history.replaceState(null, null, url); // Don't like hashes. Changing it back.\r\n    //document.getElementById(hashStr).scrollIntoView(); //Even IE6 supports this\r\n}\r\n/** Returns [domainStr, pathStr, varsStr, hashStr], without the separator-chars. */\r\nexport function GetCurrentURLString() {\r\n    return window.location.href.replace(/%22/, \"\\\"\");\r\n}\r\nexport function GetUrlParts(url) {\r\n    url = url || GetCurrentURLString();\r\n    let [domainStr, pathStr, varsStr, hashStr] = Array(4).fill(0).map(a => \"\");\r\n    let urlToProcess = url;\r\n    if (urlToProcess.includes(\"#\") && !varsStr.includes(\"runJS=\")) {\r\n        [urlToProcess, hashStr] = StringCE(urlToProcess).SplitAt(urlToProcess.indexOf(\"#\"));\r\n    }\r\n    if (urlToProcess.includes(\"?\")) {\r\n        [urlToProcess, varsStr] = StringCE(urlToProcess).SplitAt(urlToProcess.indexOf(\"?\"));\r\n    }\r\n    //if (urlToProcess.Matches(\"/\").length == )\r\n    let splitAtSlash_pos = NumberCE(StringCE(urlToProcess).IndexOf_X(\"/\", 2)).IfN1Then(urlToProcess.length);\r\n    [domainStr, pathStr] = StringCE(urlToProcess).SplitAt(splitAtSlash_pos);\r\n    return [domainStr, pathStr, varsStr, hashStr];\r\n}\r\nfunction GetUrlPath(url, fromDomain = true) {\r\n    /*let [pathStr, varsStr, hashStr] = GetUrlParts(url);\r\n    if (fromDomain)\r\n        pathStr = pathStr.SplitAt(pathStr.IndexOf_X(\"/\", 2).IfN1Then(pathStr.length))[1];\r\n    if (pathStr.endsWith(\"/\"))\r\n        pathStr = pathStr.substr(0, pathStr.length - 1);*/\r\n    let [_, pathStr] = GetUrlParts(url);\r\n    if (pathStr.endsWith(\"/\"))\r\n        pathStr = pathStr.slice(0, -1);\r\n    return pathStr;\r\n}\r\nfunction GetUrlVars(url, allowQuestionMarkAsVarSep = true) {\r\n    let varSeparators = allowQuestionMarkAsVarSep ? [\"&\", \"?\"] : [\"&\"];\r\n    let [_, __, varsStr] = GetUrlParts(url);\r\n    var vars = {}; //{[key: string]: string};\r\n    var parts = StringCE(varsStr).SplitByAny(...varSeparators).filter(a => a);\r\n    for (let part of parts) {\r\n        let [key, value] = StringCE(part).SplitAt(part.indexOf(\"=\"));\r\n        vars[key] = value;\r\n    }\r\n    return vars;\r\n}\r\n/*export function GetCurrentURL(fromAddressBar = false) {\r\n    return fromAddressBar ? URL.Parse(GetCurrentURLString()) : URL.FromState(State(\"router\"));\r\n}*/\r\nexport class VURL {\r\n    constructor(domain = \"\", pathNodes = [], queryVars = [], hash = \"\") {\r\n        this.domain = domain;\r\n        this.pathNodes = pathNodes;\r\n        this.queryVars = queryVars;\r\n        this.hash = hash;\r\n    }\r\n    static Parse(urlStr, useCurrentDomainIfMissing = true, allowQuestionMarkAsVarSep = true) {\r\n        if (useCurrentDomainIfMissing && !urlStr.startsWith(\"http\"))\r\n            urlStr = window.location.origin + (urlStr.startsWith(\"/\") ? \"\" : \"/\") + urlStr;\r\n        let [domainStr, pathStr, varsStr, hashStr] = GetUrlParts(urlStr);\r\n        let queryVarsMap = GetUrlVars(urlStr, allowQuestionMarkAsVarSep);\r\n        let result = new VURL();\r\n        result.domain = domainStr;\r\n        result.pathNodes = pathStr.length ? pathStr.split(\"/\") : [];\r\n        for (let key of Object.keys(queryVarsMap)) {\r\n            result.queryVars.push(new QueryVar(key, queryVarsMap[key]));\r\n        }\r\n        result.hash = hashStr;\r\n        return result;\r\n    }\r\n    static FromLocationObject(location) {\r\n        // todo: have this support all Location properties, not just those used by connected-react-router\r\n        let result = VURL.Parse(location ? (location.pathname || \"\") + (location.search || \"\") + (location.hash || \"\") : \"\");\r\n        //if (normalize) result = result.Normalized();\r\n        return result;\r\n    }\r\n    // doesn't supply all the properties of a Location object, but supplies the most common\r\n    ToLocationObject() {\r\n        return {\r\n            pathname: this.toString({ domain: false, path: true, queryVars: false, hash: false }),\r\n            search: this.toString({ domain: false, pathStartSlash: false, path: false, queryVars: true, hash: false }),\r\n            hash: this.toString({ domain: false, pathStartSlash: false, path: false, queryVars: false, hash: true }),\r\n            key: \"URLKey_\" + Date.now(),\r\n        };\r\n    }\r\n    DomainStr(withProtocol = true) {\r\n        return withProtocol ? this.domain : this.DomainWithoutProtocol;\r\n    }\r\n    get Protocol() { return this.domain && StringCE(this.domain).Contains(\"://\") ? this.domain.substr(0, this.domain.indexOf(\"://\")) : null; }\r\n    get DomainWithoutProtocol() { return this.domain && StringCE(this.domain).Contains(\"://\") ? this.domain.substr(this.domain.indexOf(\"://\") + 3) : this.domain; }\r\n    PathStr(pathStartSlash) {\r\n        let result = \"\";\r\n        if (pathStartSlash) {\r\n            result += \"/\";\r\n        }\r\n        // path-nodes\r\n        if (this.pathNodes.length)\r\n            result += this.pathNodes.join(\"/\");\r\n        return result;\r\n    }\r\n    get QueryStr() {\r\n        let result = \"\";\r\n        for (let [index, queryVar] of this.queryVars.entries()) {\r\n            result += (index == 0 ? \"?\" : \"&\") + queryVar.name + \"=\" + queryVar.value;\r\n        }\r\n        return result;\r\n    }\r\n    GetQueryVar(name) {\r\n        let entry = this.queryVars.find(a => a.name == name);\r\n        return entry ? entry.value : undefined;\r\n    }\r\n    SetQueryVar(name, value) {\r\n        let existingEntry = this.queryVars.find(a => a.name == name);\r\n        if (existingEntry) {\r\n            existingEntry.value = value;\r\n        }\r\n        else {\r\n            this.queryVars.push(new QueryVar(name, value));\r\n        }\r\n    }\r\n    get HashStr() {\r\n        if (!this.hash)\r\n            return \"\";\r\n        return \"#\" + this.hash;\r\n    }\r\n    Clone() {\r\n        return new VURL(this.domain, this.pathNodes.slice(), this.queryVars.map(a => a.Clone()), this.hash);\r\n    }\r\n    /*Normalized() {\r\n        let result = this.Clone();\r\n        if (!rootPages.Contains(result.pathNodes[0])) {\r\n            result.pathNodes.Insert(0, \"home\");\r\n        }\r\n        if (result.pathNodes[1] == null && rootPageDefaultChilds[result.pathNodes[0]]) {\r\n            result.pathNodes.Insert(1, rootPageDefaultChilds[result.pathNodes[0]]);\r\n        }\r\n        return result;\r\n    }*/\r\n    toString(options) {\r\n        options = E({ domain: true, domain_protocol: true, pathStartSlash: \"auto\", path: true, queryVars: true, hash: true }, options);\r\n        let result = \"\";\r\n        // domain\r\n        if (options.domain)\r\n            result += this.DomainStr(options.domain_protocol);\r\n        //if (options.forceSlashAfterDomain || (options.path && this.pathNodes.length) || (options.queryVars && this.queryVars.length) || (options.hash && this.hash))\r\n        let pathStartSlash_auto = result.length == 0 || (options.path && this.pathNodes.length) || (options.queryVars && this.queryVars.length) || (options.hash && this.hash);\r\n        let pathStartSlash = options.pathStartSlash == true || (options.pathStartSlash == \"auto\" && pathStartSlash_auto);\r\n        if (pathStartSlash) {\r\n            result += \"/\";\r\n        }\r\n        if (options.path)\r\n            result += this.PathStr(false);\r\n        if (options.queryVars)\r\n            result += this.QueryStr;\r\n        if (options.hash)\r\n            result += this.HashStr;\r\n        Assert(!result.startsWith(\"//\"), `URL toString() result cannot start with \"//\". (it's probably an error)`);\r\n        return result;\r\n    }\r\n    toString_OptIn(options) {\r\n        options = E({ domain: false, path: false, queryVars: false, hash: false }, options);\r\n        return this.toString(options);\r\n    }\r\n}\r\nfunction AsPartial(obj) { return obj; }\r\nexport class QueryVar {\r\n    constructor(name, value) {\r\n        this.name = name;\r\n        this.value = value;\r\n    }\r\n    Clone() {\r\n        return new QueryVar(this.name, this.value);\r\n    }\r\n}\r\n// todo: merge this functionality into the URL class\r\n/*export function GetPathNodes(path = GetUrlPath(), makeFull = true) {\r\n    /*let location = State().router;\r\n    if (location == null) return \"/\";\r\n    return location.pathname.split(\"/\")[1];*#/\r\n    \r\n    let pathNodes = path.split(\"/\").Where(a=>a.length > 0);\r\n    if (makeFull) {\r\n        if (!rootPages.Contains(pathNodes[0]))\r\n            pathNodes.Insert(0, \"home\");\r\n        if (pathNodes[1] == null)\r\n            pathNodes.Insert(1, rootPageDefaultChilds[pathNodes[0]]);\r\n    }\r\n    return pathNodes;\r\n}\r\nexport function GetPath(path = GetUrlPath(), makeFull = true) {\r\n    return GetPathNodes(path, makeFull).join(\"/\");\r\n}*/ \r\n//# sourceMappingURL=URLs.js.map","import { ShallowEquals } from \"./General\";\r\nimport { ArrayCE, Continue } from \"../ClassExtensions/CE_Array\";\r\nexport class Storage {\r\n    constructor() {\r\n        this.resultUpdateCount = 0;\r\n    }\r\n}\r\nexport let storages = {};\r\nexport function GetStorageForCachedTransform(transformType, staticProps) {\r\n    //let storageKey = transformType + \"|\" + JSON.stringify(staticProps);\r\n    let storageKey = transformType + \"|\" + staticProps.join(\"|\");\r\n    let storage = storages[storageKey] || (storages[storageKey] = new Storage());\r\n    return storage;\r\n}\r\n/**\r\n * Basically, by wrapping code in this function, you're saying:\r\n *\t\t\"Do not re-evaluate the code below unless the dynamic-props have changed since the last time we were here.\"\r\n *\t\t(with the transformType and staticProps defining what \"here\" means)\r\n * @param transformType The name of the transformation; usually a function-name like \"GetSomeThing\", or \"connectProp_processX\". (used, along with static-props, to form a \"storage key\", where cache is checked for and stored)\r\n * @param staticProps An array.\r\n * @param dynamicProps Can be either an object or array.\r\n * @param transformFunc The data-transformer. Whenever a dynamic-prop changes, this will be called, and the new result will be cached.\r\n */\r\n//export function CachedTransform<T, T2, T3>(transformType: string, staticProps: T, dynamicProps: T2, transformFunc: (staticProps: T, dynamicProps: T2)=>T3): T3 {\r\nexport function CachedTransform(transformType, staticProps, dynamicProps, transformFunc) {\r\n    //Assert(dynamicProps != null);\r\n    let storage = GetStorageForCachedTransform(transformType, staticProps);\r\n    if (!ShallowEquals(dynamicProps, storage.lastDynamicProps) || storage.resultUpdateCount == 0) {\r\n        /*MaybeLog(a=>a.cacheUpdates,\r\n            ()=>`Recalculating cache. @Type:${transformType} @StaticProps:${ToJSON(staticProps)} @DynamicProps:${ToJSON(dynamicProps)} @TransformFunc:${transformFunc}`);*/\r\n        storage.lastDynamicProps = dynamicProps;\r\n        storage.lastDebugInfo = {};\r\n        storage.lastResult = transformFunc(storage.lastDebugInfo, staticProps, dynamicProps);\r\n        storage.resultUpdateCount++;\r\n    }\r\n    return storage.lastResult;\r\n}\r\nexport function CombineDynamicPropMaps(...maps) {\r\n    var result = {};\r\n    ArrayCE(maps).ForEach((map, mapIndex) => {\r\n        if (map == null)\r\n            return Continue();\r\n        Object.keys(map).forEach(key => {\r\n            result[mapIndex + \"_\" + key] = map[key];\r\n        });\r\n    });\r\n    return result;\r\n}\r\n//# sourceMappingURL=VCache.js.map","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar Vector2i_1, Vector3i_1, VRect_1;\r\nimport { Global } from \"./General\";\r\nimport { IsNaN, Assert, NumberCE, ObjectCE, ArrayCE } from \"..\";\r\nfunction IsNullOrNaN(value) {\r\n    return value === null || IsNaN(value);\r\n}\r\nexport function IsVector2iShape(obj) {\r\n    return obj.hasOwnProperty(\"x\") && obj.hasOwnProperty(\"y\");\r\n}\r\nlet Vector2i = Vector2i_1 = class Vector2i {\r\n    constructor(...args) {\r\n        var x = 0, y = 0;\r\n        if (typeof args[0] == \"number\")\r\n            [x, y] = args;\r\n        else if (args[0] && args[0].x != null)\r\n            [x, y] = [args[0].x, args[0].y];\r\n        else if (args[0] && args[0].left != null)\r\n            [x, y] = [args[0].left, args[0].top];\r\n        Assert(!IsNullOrNaN(x) && !IsNullOrNaN(y), \"Cannot initialize Vector2i's x/y to null/NaN. (if needed, initialize to undefined)\");\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    static get zero() { return new Vector2i_1(0, 0); }\r\n    static get one() { return new Vector2i_1(1, 1); }\r\n    /*@_VDFDeserialize() Deserialize(node) {\r\n        var strParts = node.primitiveValue.split(\" \");\r\n        this.x = parseInt(strParts[0]);\r\n        this.y = parseInt(strParts[1]);\r\n    }\r\n    @_VDFSerialize() Serialize() { return new VDFNode(this.toString()); }*/\r\n    toString() { return this.x + \" \" + this.y; }\r\n    Equals(other) { return other && this.toString() == other.toString(); }\r\n    NewX(xOrFunc) { return new Vector2i_1(xOrFunc instanceof Function ? xOrFunc(this.x) : xOrFunc, this.y); }\r\n    NewY(yOrFunc) { return new Vector2i_1(this.x, yOrFunc instanceof Function ? yOrFunc(this.y) : yOrFunc); }\r\n    Plus(...args) {\r\n        let [x, y] = IsVector2iShape(args[0]) ? [args[0].x, args[0].y] : args;\r\n        return new Vector2i_1(this.x + x, this.y + y);\r\n    }\r\n    Minus(...args) {\r\n        let [x, y] = IsVector2iShape(args[0]) ? [args[0].x, args[0].y] : args;\r\n        return new Vector2i_1(this.x - x, this.y - y);\r\n    }\r\n    Times(...args) {\r\n        var [x, y] = IsVector2iShape(args[0]) ? [args[0].x, args[0].y] :\r\n            args.length == 1 ? [args[0], args[0]] :\r\n                args;\r\n        return new Vector2i_1(this.x * x, this.y * y);\r\n    }\r\n    DividedBy(...args) {\r\n        var [x, y] = IsVector2iShape(args[0]) ? [args[0].x, args[0].y] :\r\n            args.length == 1 ? [args[0], args[0]] :\r\n                args;\r\n        return new Vector2i_1(this.x / x, this.y / y);\r\n    }\r\n    DistanceTo(other) {\r\n        return Math.sqrt(NumberCE(other.x - this.x).ToPower(2) + NumberCE(other.y - this.y).ToPower(2));\r\n    }\r\n};\r\nVector2i = Vector2i_1 = __decorate([\r\n    Global\r\n], Vector2i);\r\nexport { Vector2i };\r\nexport function IsVector3iShape(obj) {\r\n    return obj.hasOwnProperty(\"x\") && obj.hasOwnProperty(\"y\") && obj.hasOwnProperty(\"z\");\r\n}\r\nlet Vector3i = Vector3i_1 = class Vector3i {\r\n    constructor(x = null, y = null, z = null) {\r\n        Assert(!IsNullOrNaN(x) && !IsNullOrNaN(y) && !IsNullOrNaN(z), \"Cannot initialize Vector3i's x/y/z to null/NaN. (if needed, initialize to undefined)\");\r\n        this.x = x != null ? x : 0;\r\n        this.y = y != null ? y : 0;\r\n        this.z = z != null ? z : 0;\r\n    }\r\n    static get zero() { return new Vector3i_1(0, 0, 0); }\r\n    static get one() { return new Vector3i_1(1, 1, 1); }\r\n    /*@_VDFDeserialize() Deserialize(node) {\r\n        var strParts = node.primitiveValue.split(\" \");\r\n        this.x = parseInt(strParts[0]);\r\n        this.y = parseInt(strParts[1]);\r\n        this.z = parseInt(strParts[2]);\r\n    }\r\n    //VDFSerialize() { return this.toString(); } //Swapped().toString(); }\r\n    @_VDFSerialize() Serialize() { return new VDFNode(this.toString()); }*/\r\n    toString() { return this.x + \" \" + this.y + \" \" + this.z; }\r\n    NewX(xOrFunc) { return new Vector3i_1(xOrFunc instanceof Function ? xOrFunc(this.x) : xOrFunc, this.y, this.z); }\r\n    NewY(yOrFunc) { return new Vector3i_1(this.x, yOrFunc instanceof Function ? yOrFunc(this.y) : yOrFunc, this.z); }\r\n    NewZ(zOrFunc) { return new Vector3i_1(this.x, this.y, zOrFunc instanceof Function ? zOrFunc(this.z) : zOrFunc); }\r\n    Minus(...args) {\r\n        let [x, y, z] = IsVector3iShape(args[0]) ? [args[0].x, args[0].y, args[0].z] : args;\r\n        return new Vector3i_1(this.x - x, this.y - y, this.z - z);\r\n    }\r\n    Plus(...args) {\r\n        let [x, y, z] = IsVector3iShape(args[0]) ? [args[0].x, args[0].y, args[0].z] : args;\r\n        return new Vector3i_1(this.x + x, this.y + y, this.z + z);\r\n    }\r\n    Times(...args) {\r\n        var [x, y, z] = IsVector3iShape(args[0]) ? [args[0].x, args[0].y, args[0].z] :\r\n            args.length == 1 ? [args[0], args[0], args[0]] :\r\n                args;\r\n        return new Vector3i_1(this.x * x, this.y * y, this.z * z);\r\n    }\r\n};\r\nVector3i = Vector3i_1 = __decorate([\r\n    Global\r\n], Vector3i);\r\nexport { Vector3i };\r\nexport function IsVRectShape(obj) {\r\n    return obj.hasOwnProperty(\"x\") && obj.hasOwnProperty(\"y\") && obj.hasOwnProperty(\"width\") && obj.hasOwnProperty(\"height\");\r\n}\r\nlet VRect = VRect_1 = class VRect {\r\n    constructor(...args) {\r\n        let x, y, width, height, y0IsBottom;\r\n        if (args.length == 2 || args.length == 3)\r\n            [x, y, width, height, y0IsBottom] = [args[0].x, args[0].y, args[1].x, args[1].y, args[2]];\r\n        else\r\n            [x, y, width, height, y0IsBottom] = args;\r\n        Assert(!IsNullOrNaN(x) && !IsNullOrNaN(y) && !IsNullOrNaN(width) && !IsNullOrNaN(height), \"Cannot initialize VRect's x/y/width/height to null/NaN. (if needed, initialize to undefined)\");\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width != null ? width : 0;\r\n        this.height = height != null ? height : 0;\r\n        //this.y0IsBottom = y0IsBottom != null ? y0IsBottom : false;\r\n        if (y0IsBottom)\r\n            this.y0IsBottom = y0IsBottom;\r\n    }\r\n    static FromLTWH(rect, y0IsBottom = false) {\r\n        return new VRect_1(rect.left, rect.top, rect.width, rect.height, y0IsBottom);\r\n    }\r\n    get Left() { return this.x; }\r\n    set Left(val) {\r\n        var oldRight = this.Right;\r\n        this.x = val;\r\n        this.Right = oldRight;\r\n    }\r\n    get Right() { return this.x + this.width; }\r\n    set Right(val) { this.width = val - this.x; }\r\n    get Bottom() { return this.y0IsBottom ? this.y : this.y + this.height; }\r\n    set Bottom(val) {\r\n        if (this.y0IsBottom) {\r\n            var oldTop = this.Top;\r\n            this.y = val;\r\n            this.Top = oldTop;\r\n        }\r\n        else {\r\n            this.height = val - this.y;\r\n        }\r\n    }\r\n    get Top() { return this.y0IsBottom ? this.y + this.height : this.y; }\r\n    set Top(val) {\r\n        if (this.y0IsBottom) {\r\n            this.height = val - this.y;\r\n        }\r\n        else {\r\n            let oldBottom = this.Bottom;\r\n            this.y = val;\r\n            this.Bottom = oldBottom;\r\n        }\r\n    }\r\n    get Position() { return new Vector2i(this.x, this.y); }\r\n    set Position(val) {\r\n        this.x = val.x;\r\n        this.y = val.y;\r\n    }\r\n    get Size() { return new Vector2i(this.width, this.height); }\r\n    set Size(val) {\r\n        this.width = val.x;\r\n        this.height = val.y;\r\n    }\r\n    get Center() { return new Vector2i(this.x + (this.width / 2), this.y + (this.height / 2)); }\r\n    set Center(val) {\r\n        let offset = val.Minus(this.Center);\r\n        this.Position = this.Position.Plus(offset);\r\n    }\r\n    /*@_VDFDeserialize() Deserialize(node) {\r\n        var strParts = node.primitiveValue.split(\" \");\r\n        this.x = parseInt(strParts[0]);\r\n        this.y = parseInt(strParts[1]);\r\n        this.width = parseInt(strParts[2]);\r\n        this.height = parseInt(strParts[3]);\r\n    }\r\n    @_VDFSerialize() Serialize() { return new VDFNode(this.toString()); }*/\r\n    toString() { return this.x + \" \" + this.y + \" \" + this.width + \" \" + this.height; }\r\n    Equals(other) {\r\n        if (!(other instanceof VRect_1))\r\n            return false;\r\n        return this.toString() == other.toString();\r\n    }\r\n    NewX(valOrFunc) {\r\n        return ObjectCE(this.Clone()).VSet({ x: valOrFunc instanceof Function ? valOrFunc(this.x) : valOrFunc });\r\n    }\r\n    NewLeft(valOrFunc) {\r\n        return ObjectCE(this.Clone()).VSet({ Left: valOrFunc instanceof Function ? valOrFunc(this.Left) : valOrFunc });\r\n    }\r\n    NewRight(valOrFunc) {\r\n        return ObjectCE(this.Clone()).VSet({ Right: valOrFunc instanceof Function ? valOrFunc(this.Right) : valOrFunc });\r\n    }\r\n    NewY(valOrFunc) {\r\n        return ObjectCE(this.Clone()).VSet({ y: valOrFunc instanceof Function ? valOrFunc(this.y) : valOrFunc });\r\n    }\r\n    NewBottom(valOrFunc) {\r\n        return ObjectCE(this.Clone()).VSet({ Bottom: valOrFunc instanceof Function ? valOrFunc(this.Bottom) : valOrFunc });\r\n    }\r\n    NewTop(valOrFunc) {\r\n        return ObjectCE(this.Clone()).VSet({ Top: valOrFunc instanceof Function ? valOrFunc(this.Top) : valOrFunc });\r\n    }\r\n    NewPosition(valOrFunc) {\r\n        return ObjectCE(this.Clone()).VSet({ Position: valOrFunc instanceof Function ? valOrFunc(this.Position) : valOrFunc });\r\n    }\r\n    NewWidth(valOrFunc) {\r\n        return ObjectCE(this.Clone()).VSet({ width: valOrFunc instanceof Function ? valOrFunc(this.width) : valOrFunc });\r\n    }\r\n    NewHeight(valOrFunc) {\r\n        return ObjectCE(this.Clone()).VSet({ height: valOrFunc instanceof Function ? valOrFunc(this.height) : valOrFunc });\r\n    }\r\n    NewSize(valOrFunc) {\r\n        return ObjectCE(this.Clone()).VSet({ Size: valOrFunc instanceof Function ? valOrFunc(this.Size) : valOrFunc });\r\n    }\r\n    Grow(amountOnEachSide) {\r\n        return new VRect_1(this.x - amountOnEachSide, this.y - amountOnEachSide, this.width + (amountOnEachSide * 2), this.height + (amountOnEachSide * 2));\r\n    }\r\n    Encapsulating(rect) {\r\n        var posX = Math.min(this.x, rect.x);\r\n        var posY = Math.min(this.y, rect.y);\r\n        return new VRect_1(posX, posY, Math.max(this.x + this.width, rect.x + rect.width) - posX, Math.max(this.y + this.height, rect.y + rect.height) - posY);\r\n    }\r\n    Encapsulate(rect) {\r\n        var oldRight = this.x + this.width;\r\n        var oldBottom = this.y + this.height;\r\n        this.x = Math.min(this.x, rect.x);\r\n        this.y = Math.min(this.y, rect.y);\r\n        this.width = Math.max(oldRight, rect.x + rect.width) - this.x;\r\n        this.height = Math.max(oldBottom, rect.y + rect.height) - this.y;\r\n    }\r\n    Intersects(other) {\r\n        return this.Right > other.Left && this.Left < other.Right && this.Bottom > other.Top && this.Top < other.Bottom;\r\n    }\r\n    /** Returns true if rect would intersect the other, when wrapped to the 2/8 potential \"other-sides\" of given frame/backdrop. (-x, +x, -y, +y, -x -y, -x +y, +x -y, +x +y)\r\n     * (note that it does the checks \"stupidly\", ie. just checking all possible switch-side variants, without checking if \"switched side\" version is actually on or even near the actual frame/backdrop) */\r\n    Intersects_Advanced(other, options) {\r\n        let variantsToCompare = [this];\r\n        if (options.xWrappedBy) {\r\n            variantsToCompare.push(...ArrayCE(variantsToCompare).SelectMany(base => {\r\n                return [base, base.NewX(x => x - options.xWrappedBy), base.NewX(x => x + options.xWrappedBy)];\r\n            }));\r\n        }\r\n        if (options.yWrappedBy) {\r\n            variantsToCompare.push(...ArrayCE(variantsToCompare).SelectMany(base => {\r\n                return [base, base.NewY(y => y - options.yWrappedBy), base.NewY(y => y + options.yWrappedBy)];\r\n            }));\r\n        }\r\n        return ArrayCE(variantsToCompare).Any(a => a.Intersects(other));\r\n    }\r\n    Clone() {\r\n        return new VRect_1(this.x, this.y, this.width, this.height);\r\n    }\r\n};\r\nVRect = VRect_1 = __decorate([\r\n    Global\r\n], VRect);\r\nexport { VRect };\r\nlet VBounds = class VBounds {\r\n    constructor(position, size) {\r\n        this.position = position;\r\n        this.size = size;\r\n    }\r\n    /*@_VDFDeserialize() Deserialize(node) {\r\n        var parts = node.primitiveValue.split(\"|\");\r\n        var posParts = parts[0].split(\" \");\r\n        this.position = new VVector3(parseFloat(posParts[0]), parseFloat(posParts[1]), parseFloat(posParts[2]));\r\n        var sizeParts = parts[1].split(\" \");\r\n        this.size = new VVector3(parseFloat(sizeParts[0]), parseFloat(sizeParts[1]), parseFloat(sizeParts[2]));\r\n    }\r\n    @_VDFSerialize() Serialize() { return new VDFNode(this.toString()); }*/\r\n    toString() { return this.position.x + \" \" + this.position.y + \" \" + this.position.z + \"|\" + this.size.x + \" \" + this.size.y + \" \" + this.size.z; }\r\n};\r\nVBounds = __decorate([\r\n    Global\r\n], VBounds);\r\nexport { VBounds };\r\n//# sourceMappingURL=VectorStructs.js.map","//import \"./ClassExtensions\";\r\n//export * from \"./ClassExtensions/@ApplyCode\";\r\n//export * from \"./ClassExtensions/@ApplyTypes\"; // if desired, user project should import directly (from Source folder)\r\nexport * from \"./ClassExtensions/CE_Array\";\r\nexport * from \"./ClassExtensions/CE_Element\";\r\nexport * from \"./ClassExtensions/CE_Number\";\r\nexport * from \"./ClassExtensions/CE_Object\";\r\nexport * from \"./ClassExtensions/CE_Others\";\r\nexport * from \"./ClassExtensions/CE_String\";\r\nexport * from \"./ClassExtensions/CE_Auto\";\r\nexport * from \"./JSVE\";\r\nexport * from \"./Utils/General\";\r\nexport * from \"./Utils/Changes\";\r\nexport * from \"./Utils/Assert\";\r\nexport * from \"./Utils/Timers\";\r\nexport * from \"./Utils/Types\";\r\nexport * from \"./Utils/VectorStructs\";\r\nexport * from \"./Utils/URLs\";\r\nexport * from \"./Utils/VCache\";\r\nexport * from \"./Utils/Bridge\";\r\n//# sourceMappingURL=index.js.map","// @ts-check\r\n\r\nconst {TransferPrototypeProps} = require(\"../Dist\");\r\nconst {ArrayCE_funcs} = require(\"../Dist/ClassExtensions/CE_Array\");\r\nconst {ElementCE_funcs} = require(\"../Dist/ClassExtensions/CE_Element\");\r\nconst {NumberCE_funcs} = require(\"../Dist/ClassExtensions/CE_Number\");\r\nconst {ObjectCE_funcs} = require(\"../Dist/ClassExtensions/CE_Object\");\r\nconst {DateCE_funcs, FunctionCE_funcs} = require(\"../Dist/ClassExtensions/CE_Others\");\r\nconst {StringCE_funcs} = require(\"../Dist/ClassExtensions/CE_String\");\r\n\r\nfunction ClassExtensions_ApplyCode() {\r\n\tTransferPrototypeProps(Array.prototype, ArrayCE_funcs, {}, {configurable: true, enumerable: false});\r\n\tif (typeof Element != \"undefined\") {\r\n\t\tTransferPrototypeProps(Element.prototype, ElementCE_funcs, {}, {configurable: true, enumerable: false});\r\n\t}\r\n\tTransferPrototypeProps(Number.prototype, NumberCE_funcs, {}, {configurable: true, enumerable: false});\r\n\tTransferPrototypeProps(Object.prototype, ObjectCE_funcs, {}, {configurable: true, enumerable: false});\r\n\tTransferPrototypeProps(Function.prototype, FunctionCE_funcs, {}, {configurable: true, enumerable: false});\r\n\tTransferPrototypeProps(Date.prototype, DateCE_funcs, {}, {configurable: true, enumerable: false});\r\n\t//TransferPrototypeProps(Error.prototype, ErrorCE_funcs, {}, {configurable: true, enumerable: false});\r\n\tTransferPrototypeProps(String.prototype, StringCE_funcs, {}, {configurable: true, enumerable: false});\r\n}\r\n\r\n// this file is only imported if user manually imports it; if so, apply immediately when imported\r\nClassExtensions_ApplyCode();","module.exports = require(\"babel-polyfill\");","module.exports = require(\"death\");","module.exports = require(\"ffi\");","module.exports = require(\"iohook\");","module.exports = require(\"process\");","module.exports = require(\"ref\");","module.exports = require(\"ref-struct\");","module.exports = require(\"win32-api\");"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;ACLA;AAAA;AAAA;AACA;AAGA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAAA;;;;;;;;AAOA;AAEA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;AACA;AACA;AAEA;AAJA;AAAA;AAAA;AACA;AADA;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AAbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AAEA;;;;;;AAMA;AACA;AAAA;;;;;;;;AAQA;AACA;;;;;;;;;;;;;;;;AACA;AA2FA;AACA;AACA;AAFA;AAUA;AACA;AACA;AACA;AACA;AAJA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAUA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAXA;AAcA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7TA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAnDA;AACA;AAsDA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAGA;AAEA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAGA;AACA;AACA;AAAA;AACA;AAKA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;;;;;;;AAQA;AACA;AAAA;;AAEA;AAEA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAhDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAgDA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;;;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;AC7HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3PA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1MA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvJA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACn0BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5RA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACxBA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;A","sourceRoot":""}