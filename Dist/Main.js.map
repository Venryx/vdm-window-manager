{"version":3,"file":"Main.js","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./Source/General/ClassExtensions/CE_General.ts","webpack:///./Source/General/Logging.ts","webpack:///./Source/General/Start_0.ts","webpack:///./Source/General/Windows.ts","webpack:///./Source/Input/ExtraKeys.ts","webpack:///./Source/Main.ts","webpack:///./Source/Scripts/General.ts","webpack:///./Source/Utils/Bridge/Bridge_VDesktop.ts","webpack:///./node_modules/js-vextensions/Dist/ClassExtensions/CE_Array.js","webpack:///./node_modules/js-vextensions/Dist/ClassExtensions/CE_Auto.js","webpack:///./node_modules/js-vextensions/Dist/ClassExtensions/CE_Element.js","webpack:///./node_modules/js-vextensions/Dist/ClassExtensions/CE_Number.js","webpack:///./node_modules/js-vextensions/Dist/ClassExtensions/CE_Object.js","webpack:///./node_modules/js-vextensions/Dist/ClassExtensions/CE_Others.js","webpack:///./node_modules/js-vextensions/Dist/ClassExtensions/CE_String.js","webpack:///./node_modules/js-vextensions/Dist/JSVE.js","webpack:///./node_modules/js-vextensions/Dist/Utils/Assert.js","webpack:///./node_modules/js-vextensions/Dist/Utils/Bridge.js","webpack:///./node_modules/js-vextensions/Dist/Utils/Changes.js","webpack:///./node_modules/js-vextensions/Dist/Utils/General.js","webpack:///./node_modules/js-vextensions/Dist/Utils/Timers.js","webpack:///./node_modules/js-vextensions/Dist/Utils/Types.js","webpack:///./node_modules/js-vextensions/Dist/Utils/URLs.js","webpack:///./node_modules/js-vextensions/Dist/Utils/VCache.js","webpack:///./node_modules/js-vextensions/Dist/Utils/VectorStructs.js","webpack:///./node_modules/js-vextensions/Dist/index.js","webpack:///./node_modules/js-vextensions/Helpers/@ApplyCECode.js","webpack:///external \"babel-polyfill\"","webpack:///external \"death\"","webpack:///external \"ffi\"","webpack:///external \"iohook\"","webpack:///external \"js-vextensions\"","webpack:///external \"process\"","webpack:///external \"ref\"","webpack:///external \"ref-struct\"","webpack:///external \"win32-api\""],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"http://localhost:8080/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","interface Array<T> { SequenceEquals(otherArray: any[], equalsFunc?: (a, b)=>boolean): boolean; }\r\nArray.prototype._AddFunction_Inline = function SequenceEquals(this: any[], otherArray: any[], equalsFunc = ((a, b)=>a == b)) {\r\n\tif (this.length != otherArray.length) return false;\r\n\treturn this.every((item, index)=> {\r\n\t\treturn equalsFunc(item, otherArray[index]);\r\n\t});\r\n};","import \"./Logging\";\r\n\r\nG({Log}); declare global { function Log(...args); }\r\nfunction Log(...args) {\r\n\treturn console.log(...args);\r\n}","import \"./Start_0\"; // fake/empty import, so this module is correctly seen as module (rather than raw js script)\r\n\r\n// special, early, definitely-safe codes\r\n//var g = window as any;\r\ndeclare global { const g; } global[\"g\"] = global;\r\n\r\ndeclare global { function G(...globalHolders); } g.G = G;\r\nfunction G(...globalHolders) {\r\n\tfor (let globalHolder of globalHolders) {\r\n\t\tg.Extend(globalHolder);\r\n\t}\r\n}","import {User32, DTypes, DModel} from 'win32-api';\r\nimport ffi from \"ffi\";\r\nimport ref, {alloc} from \"ref\";\r\nimport {VRect, GetTreeNodesInObjTree, ToJSON, CE} from 'js-vextensions';\r\nimport Struct from 'ref-struct';\r\n\r\n// mod win32-api to use number-based handles (instead of Buffers)\r\n// ==========\r\n\r\n// make-so any parameter or return type set to W.HWND (\"HANDLE\"), gets replaced with \"int\"\r\n// For more info, see: https://github.com/waitingsong/node-win32-api/issues/16#issuecomment-540887760\r\n/*let replacements = [\r\n\t{key: \"HWND\", oldValue: null, newValue: \"int\"},\r\n];\r\nreplacements.forEach(a=> {\r\n\ta.oldValue = W[a.key];\r\n\tW[a.key] = a.newValue;\r\n});*/\r\nlet replacements = [\r\n\t//{oldValue: \"HANDLE\", newValue: \"int32\"},\r\n\t{oldValue: \"uint64*\", newValue: \"int32\"}, // I thought the lib source-code specified \"HANDLE\", but apparently it gets converted into \"uint64*\" at some point (perhaps in gen_api_opts)\r\n\r\n\t//{oldValue: \"uint16*\", newValue: \"string\"},\r\n];\r\nfor (let pair of CE(User32.apiDef).Pairs()) {\r\n\tlet definitionArray = pair.value;\r\n\t//Log(`Name(${pair.key}) Returns(${pair.value[0]}) Arguments(${pair.value[1]})`);\r\n\r\n\tlet nodes = GetTreeNodesInObjTree(definitionArray);\r\n\tfor (let node of nodes) {\r\n\t\tfor (let replacement of replacements) {\r\n\t\t\tif (node.Value === replacement.oldValue) {\r\n\t\t\t\tnode.Value = replacement.newValue;\r\n\t\t\t\t//Log(`Replacing ${replacement.oldValue} with ${replacement.newValue}... @Path(${node.PathStr})`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t//Log(`New Name(${pair.key}) Returns(${pair.value[0]}) Arguments(${pair.value[1]})`);\r\n}\r\n\r\n/*let functionReplacements = [\r\n\t{name: \"GetWindowTextW\", value: []}\r\n]\r\nfunctionReplacements.ForEach((replacement, {index, Break, Continue})=> {\r\n\tU.apiDef[replacement.name] = value;\r\n});*/\r\n//U.apiDef.GetWindowTextW = [\"int32\", [\"int32\", ref.refType(\"string\") as any, \"int32\"]];\r\n/*U.apiDef.Pairs().forEach(pair=> {\r\n\tif (pair.key != \"EnumWindows\")\r\n\tdelete U.apiDef[pair.key];\r\n})\r\nU.apiDef.VSet({\r\n\t...U.apiDef.Including(\"EnumWindows\"),\r\n\tGetWindowTextA: [\"int32\", [\"int32\", \"string\", \"int32\"]],\r\n} as any);*/\r\n//U.apiDef.GetWindowTextA = [\"int32\", [\"int32\", \"string\", \"int32\"]];\r\n\r\nexport const user32 = User32.load() as User32.Win32Fns;\r\n\r\n// create extension of user32, which uses type \"number\" for each param that was of type \"Buffer\"\r\n/*declare type ConvertModelFuncParams<T> = {\r\n\t//[K in keyof T]: T[K] extends (...args: any) => any ? (...args: ConvertFuncParams<T[K]>) => any : T[K];\r\n\t[K in keyof T]: T[K] extends (...args: any) => any ? ConvertFuncParams<T[K]> : T[K];\r\n};\r\ntype ConvertFuncParams<\r\n\tT extends (...args: any) => any\r\n> =\r\n\t//T extends (...args: (infer P)[]) => any ? (P extends Buffer ? number : P)[] : never;\r\n\tT extends (...args: (infer P)[]) => any ? (...args: (P extends Buffer ? number : P)[]) => any : never;\r\n//type Test1 = ()=>Buffer;\r\n/*type Test1 = typeof user32.GetWindowTextW;\r\ntype Test2 = ConvertFuncParams<Test1>;*#/\r\nconst user32_numbers = user32 as any as ConvertModelFuncParams<typeof user32>;\r\nuser32.GetWindowTextW();\r\nuser32_numbers.GetWindowTextW();*/\r\n\r\n// add Typescript overloads for the functions which were modified to send/receive number-handles instead of Buffer-handles\r\n/*declare module \"win32-api/dist/lib/user32/api\" {\r\n\texport interface Win32Fns {\r\n\t\tGetWindowTextW(hWnd: number, lpString: Buffer, nMaxCount: number): number\r\n\t}\r\n}\r\nuser32.GetWindowTextW();*/\r\n\r\n// add Typescript overloads for the functions which were modified to send/receive number-handles instead of Buffer-handles\r\n/*declare module \"win32-api/dist/lib/user32/api\" {\r\n\texport namespace M {\r\n\t\texport type HWND = number;\r\n\t}\r\n}*/\r\ntype RealBuffer = Buffer;\r\ndeclare module \"win32-api/node_modules/win32-def/dist/lib/win-model/common\" {\r\n\t//type HWND = number;\r\n\t//type Buffer = number;\r\n\ttype Buffer = number | RealBuffer;\r\n}\r\n//user32.GetWindowTextW();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// general\r\n// ==========\r\n//var voidPtr = ref.refType(ref.types.void);\r\n//var stringPtr = ref.refType(ref.types.CString);\r\n\r\n/*declare global {\r\n\tinterface Buffer { Int(): number; }\r\n\tinterface Number { Buf(): Buffer; }\r\n}\r\nObject.prototype[\"Int\"] = function() {\r\n\t// convert\r\n\tif (this instanceof Buffer) {\r\n\t\t//return ref.address(this);\r\n\t\tthis[\"type\"] = ref.types.int64;\r\n\t\treturn temp1[\"deref\"]();\r\n\t}\r\n\r\n\t//if (typeof this == \"number\")\r\n\treturn this; // handle is already number -- just return\r\n}\r\nObject.prototype[\"Buf\"] = function() {\r\n\t//if (typeof this == \"number\") return ...; // convert (don't know how)\r\n\t//if (typeof this == \"number\")\r\n\treturn this; // handle is already number (matching modified definition-array) -- just return\r\n}*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nexport interface Point {\r\n\tx: number;\r\n\ty: number;\r\n}\r\nexport const POINT = Struct({\r\n\t'x': 'long',\r\n\t'y': 'long',\r\n});\r\nexport interface Rect {\r\n\tleft: number;\r\n\ttop: number;\r\n\tright: number;\r\n\tbottom: Point;\r\n}\r\nexport const RECT = Struct({\r\n\t'left': 'long',\r\n\t'top': 'long',\r\n\t'right': 'long',\r\n\t'bottom': 'long',\r\n});\r\nexport interface WindowPlacement {\r\n\tlength: number;\r\n\tflags: number;\r\n\tshowCmd: number;\r\n\tptMinPosition: Point;\r\n\tptMaxPosition: Point;\r\n\trcNormalPosition: Rect;\r\n}\r\nexport const WINDOWPLACEMENT = Struct({\r\n\t'length': 'uint',\r\n\t'flags': 'uint',\r\n\t'showCmd': 'uint',\r\n\t'ptMinPosition': POINT,\r\n\t'ptMaxPosition': POINT,\r\n\t'rcNormalPosition': RECT,\r\n});\r\n//var WINDOWPLACEMENT_REF = ref.refType(WINDOWPLACEMENT);\r\n\r\n// flags\r\nexport const WPF_ASYNCWINDOWPLACEMENT = 4;\r\n\r\n// showCmd (from: https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-windowplacement)\r\nexport const SW_HIDE = 0;\r\nexport const SW_MAXIMIZE = 3;\r\nexport const SW_MINIMIZE = 6;\r\nexport const SW_RESTORE = 9;\r\nexport const SW_SHOW = 5;\r\n//export const SW_SHOWMAXIMIZED = 3; // duplicate of SW_MAXIMIZE?\r\nexport const SW_SHOWMINIMIZED = 2;\r\nexport const SW_SHOWMINNOACTIVE = 7;\r\nexport const SW_SHOWNA = 8;\r\nexport const SW_SHOWNOACTIVATE = 4;\r\nexport const SW_SHOWNORMAL = 1;\r\n\r\nexport const user32_extra = new ffi.Library(\"user32\", {\r\n\t//EnumWindows: ['bool', [voidPtr, 'int32']],\r\n\t//GetForegroundWindow: [\"int32\", []],\r\n\tGetWindowTextA: [\"int32\", [\"int32\", \"string\", \"int32\"]],\r\n\t//GetWindowTextA : ['long', ['long', stringPtr, 'long']]\r\n\t//GetWindowTextW: [\"int32\", [\"int32\", ref.refType(\"string\"), \"int32\"]],\r\n\tGetWindowTextLengthW: [\"int32\", [\"int32\"]],\r\n\tGetWindowRect: ['bool', ['int32', \"pointer\"]],\r\n\r\n\tGetWindowPlacement: [\"bool\", [\"int32\", ref.refType(WINDOWPLACEMENT)]],\r\n\tSetWindowPlacement: [\"bool\", [\"int32\", ref.refType(WINDOWPLACEMENT)]],\r\n\tShowWindow: ['bool', ['int32', 'int32']],\r\n});\r\n\r\nexport class WindowInfo {\r\n\thandle: number;\r\n\tlParam: number;\r\n}\r\nexport function GetWindowHandles() {\r\n\tlet result = [] as number[];\r\n\tlet onFoundWindow = ffi.Callback('bool', ['long', 'int32'], (handle: number, lParam: number) => {\r\n\t\tresult.push(handle);\r\n\t\treturn true;\r\n\t});\r\n\tuser32.EnumWindows(onFoundWindow, 0);\r\n\treturn result;\r\n}\r\n/*export function GetWindowHandles() {\r\n\tlet result = [] as DModel.HWND[];\r\n\tlet onFoundWindow = ffi.Callback(W.BOOL, [W.HWND, W.LPARAM], (handle: DModel.HWND, lParam: number)=> {\r\n\t\tresult.push(handle);\r\n\t\treturn true;\r\n\t});\r\n\tuser32.EnumWindows(onFoundWindow, 0);\r\n\treturn result;\r\n}*/\r\n\r\nexport function GetForegroundWindowHandle() {\r\n\t//return user32.GetForegroundWindow().Int();\r\n\treturn user32.GetForegroundWindow() as number;\r\n\t//return user32.GetForegroundWindow() as any as number;\r\n}\r\nexport function GetForegroundWindowText() {\r\n\tvar handle = GetForegroundWindowHandle();\r\n\treturn GetWindowText(handle);\r\n}\r\n\r\n// Note: This function can cause an info-less crash, if: 1) using the W variant, 2) the buffer length is in a certain range [~8-280], 3) the program is launched using \"node --inspect\"\r\nexport function GetWindowText(handle: number) {\r\n\t//let length = user32_extra.GetWindowTextLengthW(handle as any);\r\n\t//let bufferSize = 256;\r\n\tlet bufferSize = 512;\r\n\tvar buffer = new Buffer(bufferSize);\r\n\t//buffer.type = ref.types.CString;\r\n\t//let length = user32.GetWindowTextW(user32.GetForegroundWindow(), buffer, bufferSize);\r\n\t//let length = user32_extra.GetWindowTextA(handle, buffer, bufferSize);\r\n\t//let length = user32.GetWindowTextA(handle, buffer, bufferSize);\r\n\t//let length = user32.GetWindowTextW(handle.Buf(), buffer, bufferSize);\r\n\tlet length = user32.GetWindowTextW(handle, buffer, bufferSize);\r\n\t//let length = user32.GetWindowTextW(handle as any, buffer, bufferSize);\r\n\t//return ref.readCString(buffer, 0);\r\n\t//return buffer.toString().substr(0, length as any);\r\n\treturn buffer.toString('ucs2').replace(/\\0+$/, '');\r\n}\r\n\r\nexport function GetWindowRect(handle: number) {\r\n\t//var rect = new rectStruct();\r\n\t//var rectPointer = ref.alloc(rectStructPointer);\r\n\tvar rectPointer: Buffer = Buffer.alloc(4 * 4);\r\n\t//Log(\"Address: \" + ref.address(handle));\r\n\t//var success = user32_extra.GetWindowRect(handle, rect);\r\n\t//var success = user32_extra.GetWindowRect(ref.address(handle), repbuffer);\r\n\tvar success = user32_extra.GetWindowRect(handle, rectPointer);\r\n\tif (!success) return null;\r\n\r\n\t//let rect = ref.get(rectPointer, 0, rectStructPointer).deref();\r\n\t//let rect = ref.get(rectPointer.buffer, 0, rectStructPointer).deref();\r\n\t//var repbuffer = new Buffer(4 * 4);\r\n\r\n\tlet rect = RectPointerToRect(rectPointer);\r\n\t//Log(\"Rect: \" + ToJSON(rect) + \";\" + success);\r\n\treturn RectToVRect(rect);\r\n}\r\n\r\nexport function GetWindowPlacement(handle: number) {\r\n\tlet placementRef = ref.alloc(WINDOWPLACEMENT);\r\n\tuser32_extra.GetWindowPlacement(handle, placementRef);\r\n\treturn placementRef.deref() as WindowPlacement;\r\n}\r\nexport function SetWindowPlacement(handle: number, placement: WindowPlacement) {\r\n\t/*var placementRef = ref.alloc(WINDOWPLACEMENT);\r\n\tplacementRef.writeObject(0, state.placement);*/\r\n\tvar placementRef = ref.alloc(WINDOWPLACEMENT, placement);\r\n\treturn user32_extra.SetWindowPlacement(handle, placementRef);\r\n}\r\n\r\nfunction RectPointerToRect(rectPointer: Buffer) {\r\n\tlet rect = {} as any;\r\n\trect.left = rectPointer.readUInt32LE(0);\r\n\trect.top = rectPointer.readUInt32LE(4);\r\n\trect.right = rectPointer.readUInt32LE(8);\r\n\trect.bottom = rectPointer.readUInt32LE(12);\r\n\treturn rect;\r\n}\r\nfunction RectToVRect(rect: {left, top, right, bottom}) {\r\n\treturn new VRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);\r\n}\r\n\r\nexport enum SuspendState {\r\n\tSleep,\r\n}\r\n\r\nvar powrprof = ffi.Library('powrprof.dll', {\r\n\tSetSuspendState: ['int', ['int', 'int', 'int']]\r\n});\r\nexport function SetSuspendState(state: SuspendState) {\r\n\tif (state == SuspendState.Sleep) {\r\n\t\tpowrprof.SetSuspendState(0, 0, 0);\r\n\t}\r\n}","// full list here: http://cherrytree.at/misc/vk.htm\r\nexport const extraKeys = {\r\n\tleftShift: 160,\r\n\trightShift: 161,\r\n\tleftControl: 162,\r\n\trightControl: 163,\r\n\tleftAlt: 164,\r\n\trightAlt: 165,\r\n\r\n\tmeta_windows: 91,\r\n\r\n\t// custom\r\n\tmouseLeft: 1000 + 1,\r\n\tmouseRight: 1000 + 2,\r\n\tmouseMiddle: 1000 + 3,\r\n\tmouseForward: 1000 + 4,\r\n\tmouseBackward: 1000 + 5,\r\n\tmouseWheelUp: 1000 + 6,\r\n\tmouseWheelDown: 1000 + 7,\r\n\r\n\t// number row\r\n\tN1: 49,\r\n\r\n\t// slashes and such\r\n\t/*slash: 191,\r\n\tbackslash: 220,*/\r\n\r\n\tvolumeDown: 174, //0xAE,\r\n\tvolumeUp: 175, //0xAF,\r\n\r\n\t// numpad keys\r\n\t// All of these, except for numpadCenter, are in regular keycode collection, but kept here too since naming is confusing.\r\n\t// (For example, [numpad insert] is same as [insert], but [numpad +] is not same as [+].)\r\n\t// ==========\r\n\r\n\t// 0-9\r\n\tnumpadInsert: 45,\r\n\tnumpadEnd: 35,\r\n\tnumpadDown: 40,\r\n\tnumpadPageDown: 34,\r\n\tnumpadLeft: 37,\r\n\tnumpadCenter: 12, // not sure real name\r\n\tnumpadRight: 39,\r\n\tnumpadHome: 36,\r\n\tnumpadUp: 38,\r\n\tnumpadPageUp: 33,\r\n\r\n\t// others, clockwise from top-left\r\n\tnumpadDivide: 111,\r\n\tnumpadMultiply: 106,\r\n\tnumpadSubtract: 109,\r\n\tnumpadAdd: 107,\r\n\tnumpadEnter: 108,\r\n};\r\n\r\n// smaller copy sets\r\nexport enum MouseButton {\r\n\tLeft = extraKeys.mouseLeft,\r\n\tRight = extraKeys.mouseRight,\r\n\tMiddle = extraKeys.mouseMiddle,\r\n\tForward = extraKeys.mouseForward,\r\n\tBackward = extraKeys.mouseBackward,\r\n}","// \"static\" imports\nimport \"./General/Start_0\";\n//import \"js-vextensions/Helpers/@ApplyCETypes.d.ts\";\ntype __ = typeof import(\"../node_modules/js-vextensions/Helpers/@ApplyCETypes\");\nimport \"js-vextensions/Helpers/@ApplyCECode.js\";\nimport \"./General/ClassExtensions/CE_General\";\nimport \"./General/Logging\";\n//import \"babel-core/register\";\nimport \"babel-polyfill\";\n\nimport OnDeath from \"death\";\nimport process from \"process\";\n//import { StartEventLoop, StopEventLoop } from \"./Input/EventLoop\";\n\n//let addHotkeySystem = !process.argv.Contains(\"noHotkey\");\n\nrequire(\"./Utils/Bridge/Bridge_VDesktop\");\n\n// subscripts\n// ==========\n\nrequire(\"./Scripts/General\");\n\n// shutdown\n// ==========\n\n//OnDeath({uncaughtException: true, exit: true})((signal, error)=> {\nvar OffDeath = OnDeath({uncaughtException: true, exit: true})((signal, error)=> {\n\tShutDown(signal, error);\n\tOffDeath();\n});\nfunction ShutDown(signal: string, error: Error) {\n\tconsole.log(`Signal: ${signal} Error: ${error}`);\n\t//StopEventLoop();\n\t//RemoveHooks();\n}\n// PreExit message is sent by venryx-desktop just before it closes (so we have chance to clean up) \nprocess.on(\"message\", message=> {\n\tif (message == \"PreExit\") {\n\t\tShutDown(\"PreExit\", null);\n\t}\n});\n\n// launch\n// ==========\n\n/*if (addHotkeySystem) {\n\tAddHook();\n}*/\n//StartEventLoop();","import ioHook from \"iohook\";\nimport {extraKeys} from \"../Input/ExtraKeys\";\nimport {GetWindowHandles, GetWindowText, GetWindowRect, GetForegroundWindowText, user32, user32_extra, WINDOWPLACEMENT, WindowPlacement, GetWindowPlacement, SetWindowPlacement, SW_SHOWMINIMIZED, SW_RESTORE, SW_SHOW, SW_HIDE, SW_MINIMIZE, SW_SHOWNA, SW_SHOWMINNOACTIVE, WPF_ASYNCWINDOWPLACEMENT, SW_SHOWNOACTIVATE, SW_MAXIMIZE, SW_SHOWNORMAL} from \"../General/Windows\";\nimport {VRect, ToJSON, E, Clone} from \"js-vextensions\";\n\nlet windowTitlesToIgnore = [\n\t// never visible (as real window)\n\t\"Program Manager\",\n\t// not really visible (at least usually -- and for me)\n\t\"Microsoft Text Input Application\", \"Backup and Sync\", \"Settings\", \"Microsoft Edge\",\n\t// not needing placement-restoring, for other reasons\n\t\"Venryx Overlay\",\n];\n\nexport class WindowState {\n\tconstructor(initialData: Partial<WindowState>) {\n\t\tthis.Extend(initialData);\n\t}\n\trect: VRect;\n\ttext: string;\n\tplacement: WindowPlacement;\n}\nlet windowStates = {} as {[key: string]: WindowState};\n\nexport function StoreStates() {\n\twindowStates = {};\n\n\tlet windows = GetWindowHandles();\n\twindows.forEach(handle => {\n\t\tif (!user32.IsWindowVisible(handle)) return;\n\n\t\tlet text = GetWindowText(handle);\n\t\tif (text.length == 0) return;\n\t\tif (windowTitlesToIgnore.Contains(text)) return;\n\n\t\tlet rect = GetWindowRect(handle);\n\t\tlet placement = GetWindowPlacement(handle);\n\t\t//Log(`Found window. @Handle(${handle}) @Title(${text}) @Rect(${rect})`);\n\n\t\tlet state = new WindowState({rect, text, placement});\n\t\twindowStates[handle] = state;\n\t});\n\tLog(`States stored for ${windowStates.Pairs().length} windows.`);\n}\nexport function ShowStoredStates() {\n\tfor (let {key: handle, value: state} of windowStates.Pairs()) {\n\t\tLog(`Window state: @Handle(${handle}) @Title(${state.text}) @Rect(${state.rect}) @Placement(${ToJSON(state.placement)})`);\n\t}\n}\nexport function RestoreStates() {\n\tlet restoredWindows = 0;\n\tfor (let {keyNum: handle, value: state} of windowStates.Pairs()) {\n\t\tlet placement = GetWindowPlacement(handle);\n\t\t// if placement is exactly the same as before, don't do anything\n\t\tif (ToJSON(placement) == ToJSON(state.placement)) continue;\n\n\t\t/*user32.ShowWindow(handle, SW_HIDE); // first, hide window (this seems to make the following steps get applied more quickly graphically)\n\t\t//user32.ShowWindow(handle, SW_SHOWMINNOACTIVE); // set show-state to \"minimized\", since maximized windows otherwise refuse to change screen\n\t\tuser32.ShowWindow(handle, SW_RESTORE); // set show-state to \"restored\", since maximized windows otherwise refuse to change screen\n\t\t//user32.ShowWindow(handle, SW_SHOWNOACTIVATE); // set show-state to \"restored\", since maximized windows otherwise refuse to change screen\n\t\t//SetWindowPlacement(handle, E(state.placement, {showCmd: SW_RESTORE})); // apply old-placement, except have show-state be \"restored\", since most reliable for getting on correct screen\n\t\tSetWindowPlacement(handle, state.placement); // now that in \"moveable\" state, apply old-placement\n\t\t//SetWindowPlacement(handle, E(state.placement, {flags: WPF_ASYNCWINDOWPLACEMENT})); // now that in \"moveable\" state, apply old-placement*/\n\n\t\t// in case the window just changed screens, have taskbar entry moved to match\n\t\t/*user32.ShowWindow(handle, SW_HIDE);\n\t\tuser32.ShowWindow(handle, SW_SHOWNA);*/\n\t\t//user32.ShowWindow(handle, SW_SHOWNA);\n\n\t\t//let finalPlacement = E(state.placement);\n\t\t// state.placement is an instance of a WindowPlacement class (node-ffi created; not the interface defined in Windows.ts), with the props as prototype getters (accessing the \"ref.buffer\" backing); thus, must use Clone to copy the values\n\t\tlet finalPlacement = Clone(state.placement);\n\t\tfinalPlacement.flags |= WPF_ASYNCWINDOWPLACEMENT;\n\n\t\t// first, set show-state to \"restored\" on the correct screen (fixes taskbar-entry being on wrong screen (todo: confirm), and maximized windows refusing to change screen)\n\t\t//let restorePlacement = E(finalPlacement, {showCmd: SW_SHOWNOACTIVATE}); // this seems to sometimes make window really small, and not maximize from next command\n\t\tlet restorePlacement = E(finalPlacement, {showCmd: SW_RESTORE});\n\t\tSetWindowPlacement(handle, restorePlacement);\n\n\t\t// modify show-command to be the non-activating variant\n\t\t/*if (finalPlacement.showCmd == SW_MAXIMIZE) {\n\t\t\t// first, set show-state to \"restored\", since maximized windows otherwise refuse to change screen\n\t\t\t//let restorePlacement = E(finalPlacement, {showCmd: SW_SHOWNOACTIVATE}); // this seems to sometimes make window really small, and not maximize from next command\n\t\t\t/*let restorePlacement = E(finalPlacement, {showCmd: SW_RESTORE});\n\t\t\tSetWindowPlacement(handle, restorePlacement);*#/\n\n\t\t\tfinalPlacement.showCmd = SW_MAXIMIZE;\n\t\t} else*/ if (finalPlacement.showCmd == SW_MINIMIZE || finalPlacement.showCmd == SW_SHOWMINIMIZED) {\n\t\t\tfinalPlacement.showCmd = SW_SHOWMINNOACTIVE;\n\t\t} else if (finalPlacement.showCmd == SW_SHOWNORMAL) {\n\t\t\tfinalPlacement.showCmd = SW_SHOWNOACTIVATE;\n\t\t}\n\n\t\t// apply final placement\n\t\tSetWindowPlacement(handle, finalPlacement);\n\n\t\trestoredWindows++;\n\t}\n\tLog(`States restored for ${restoredWindows} windows.`);\n}\n\n// hotkeys\n// ==========\n\n// If using iohook turns out insufficient (eg. not being able to capture keypresses for a desired hotkey), try using the Windows RegisterHotKey function:\n// * https://stackoverflow.com/questions/14799035/node-webkit-winapi/58314436#58314436\n// * https://www.fluxbytes.com/csharp/how-to-register-a-global-hotkey-for-your-application-in-c\n// If that doesn't work, I guess you'll have the use the node-ffi hook approach, even though I think it causes more overhead/delay. (see HotkeyManager.ts)\n\nioHook.useRawcode(true); // use rawcodes for shortcuts/hotkeys\n\n// logging\n/*ioHook.on('keydown', event => {\n\tconsole.log(event); // { type: 'mousemove', x: 700, y: 400 }\n});*/\n\nioHook.registerShortcut([extraKeys.leftControl, extraKeys.leftAlt, extraKeys.numpadEnd], (keys) => StoreStates());\nioHook.registerShortcut([extraKeys.leftControl, extraKeys.leftAlt, extraKeys.numpadDown], (keys) => ShowStoredStates());\nioHook.registerShortcut([extraKeys.leftControl, extraKeys.leftAlt, extraKeys.numpadPageDown], (keys) => RestoreStates());\n\n// register and start hook\nioHook.start(false);\nLog(\"Added listeners\");\n\n// might as well store the window-states at module launch (no real negative, and helps for cases where forget to store states manually, since pre-sleep listener not yet developed)\nStoreStates();","import {Bridge} from \"js-vextensions\";\n\nexport function InDesktopApp() {\n\t//return window.top != window && window.top.name == \"Venryx Desktop\";\n\t//return window.top != window;\n\t//return inElectron;\n\treturn process.argv[2] && process.argv[2] == \"asVDM\";\n}\n\nexport const desktopBridge = new Bridge({\n\treceiveChannelMessageFunc_adder: receiveChannelMessageFunc=>{\n\t\tif (!InDesktopApp()) return;\n\t\tprocess.on(\"message\", channelMessage=> {\n\t\t\treceiveChannelMessageFunc(channelMessage);\n\t\t});\n\t},\n\tsendChannelMessageFunc: channelMessage=>{\n\t\tif (!InDesktopApp()) return;\n\t\tprocess.send(channelMessage);\n\t},\n\t//channel_stringifyChannelMessageObj: false,\n});\n\n// for module system\n// ==========\n\nexport let sideScreen = false;\ndesktopBridge.RegisterFunction(\"SetSideScreen\", val=> {\n\tLog(\"SideScreen value received in window-manager module! Val: \" + val);\n\tsideScreen = val;\n});","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar __values = (this && this.__values) || function(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n};\r\nvar __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nvar __spread = (this && this.__spread) || function () {\r\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar General_1 = require(\"../Utils/General\");\r\nvar Assert_1 = require(\"../Utils/Assert\");\r\n//type ArrayLike_Unwrap<T> = ThisFor<XOrWrapped<T>>;\r\n//type ArrayLike_Unwrap<T> =\r\n/*type Unwrapped<T> =\r\n    T extends Array<infer ItemT> ? ItemT[] :\r\n    T extends ArrayCEProxy<infer ItemT> ? ItemT[] :\r\n    never;*/\r\nexports.ArrayCE_funcs = {\r\n    ForEach: function (func) {\r\n        var _loop_1 = function (i) {\r\n            var shouldBreak = false;\r\n            var shouldContinue = false;\r\n            var extras = { index: i, Break: function () { return shouldBreak = true; }, Continue: function () { return shouldContinue = true; } };\r\n            func(this_1[i], extras);\r\n            if (shouldBreak)\r\n                return \"break\";\r\n            if (shouldContinue)\r\n                return \"continue\";\r\n        };\r\n        var this_1 = this;\r\n        for (var i = 0; i < this.length; i++) {\r\n            var state_1 = _loop_1(i);\r\n            if (state_1 === \"break\")\r\n                break;\r\n        }\r\n    },\r\n    ForEachAsync: function (func) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _loop_2, this_2, i, state_2;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        _loop_2 = function (i) {\r\n                            var shouldBreak, shouldContinue, extras;\r\n                            return __generator(this, function (_a) {\r\n                                switch (_a.label) {\r\n                                    case 0:\r\n                                        shouldBreak = false;\r\n                                        shouldContinue = false;\r\n                                        extras = { index: i, Break: function () { return shouldBreak = true; }, Continue: function () { return shouldContinue = true; } };\r\n                                        return [4 /*yield*/, func(this_2[i], extras)];\r\n                                    case 1:\r\n                                        _a.sent();\r\n                                        if (shouldBreak)\r\n                                            return [2 /*return*/, \"break\"];\r\n                                        if (shouldContinue)\r\n                                            return [2 /*return*/, \"continue\"];\r\n                                        return [2 /*return*/];\r\n                                }\r\n                            });\r\n                        };\r\n                        this_2 = this;\r\n                        i = 0;\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        if (!(i < this.length)) return [3 /*break*/, 4];\r\n                        return [5 /*yield**/, _loop_2(i)];\r\n                    case 2:\r\n                        state_2 = _a.sent();\r\n                        if (state_2 === \"break\")\r\n                            return [3 /*break*/, 4];\r\n                        _a.label = 3;\r\n                    case 3:\r\n                        i++;\r\n                        return [3 /*break*/, 1];\r\n                    case 4: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    },\r\n    /*declare global { interface Array<T> { ForEachAsyncParallel(func: (value: T, index: number, array: T[])): Promise<void>; } }\r\n    Array.prototype.ForEachAsync_Parallel = async function (this: Array<any>, fn) {\r\n        await Promise.all(this.map(fn));\r\n    },*/\r\n    Contains: function (item) {\r\n        return this.indexOf(item) != -1;\r\n    },\r\n    ContainsAny: function () {\r\n        var e_1, _a;\r\n        var items = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            items[_i] = arguments[_i];\r\n        }\r\n        try {\r\n            for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {\r\n                var item = items_1_1.value;\r\n                if (this.indexOf(item) != -1) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        return false;\r\n    },\r\n    // for some reason, this platform doesn't have entries() defined\r\n    /*entries() {\r\n        var result = [];\r\n        for (var i = 0; i < this.length; i++)\r\n            result.push([i, this[i]]);\r\n        return result;\r\n    };*/\r\n    Prepend: function () {\r\n        var newItems = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            newItems[_i] = arguments[_i];\r\n        }\r\n        this.splice.apply(this, __spread([0, 0], newItems));\r\n    },\r\n    Add: function (item) {\r\n        return this.push(item);\r\n    },\r\n    CAdd: function (item) {\r\n        this.push(item);\r\n        return this;\r\n    },\r\n    TAdd: function (item) {\r\n        this.push(item);\r\n        return item;\r\n    },\r\n    AddRange: function (array) {\r\n        var e_2, _a;\r\n        try {\r\n            //this.push(...array);\r\n            // use loop, since sending them all as arguments fails when there are ~10000+ items\r\n            for (var array_1 = __values(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {\r\n                var item = array_1_1.value;\r\n                this.push(item);\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        return this;\r\n    },\r\n    Remove: function (item) {\r\n        var itemIndex = this.indexOf(item);\r\n        if (itemIndex == -1)\r\n            return false;\r\n        this.splice(itemIndex, 1);\r\n        return true;\r\n    },\r\n    RemoveAll: function (items) {\r\n        var e_3, _a;\r\n        try {\r\n            for (var items_2 = __values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {\r\n                var item = items_2_1.value;\r\n                exports.ArrayCES.Remove(this, item);\r\n            }\r\n        }\r\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n        finally {\r\n            try {\r\n                if (items_2_1 && !items_2_1.done && (_a = items_2.return)) _a.call(items_2);\r\n            }\r\n            finally { if (e_3) throw e_3.error; }\r\n        }\r\n    },\r\n    RemoveAt: function (index) {\r\n        return this.splice(index, 1)[0];\r\n    },\r\n    Insert: function (index, obj) {\r\n        this.splice(index, 0, obj);\r\n    },\r\n    SetItems: function (items) {\r\n        this.splice.apply(this, __spread([0, this.length], items));\r\n        return this;\r\n    },\r\n    Reversed: function () {\r\n        var clone = this.slice(0);\r\n        clone.reverse();\r\n        return clone;\r\n    },\r\n    //Object.prototype._AddFunction_Inline = function AsRef() { return new NodeReference_ByPath(this); }\r\n    // Linq replacements\r\n    // ----------\r\n    Any: function (matchFunc) {\r\n        var e_4, _a;\r\n        try {\r\n            for (var _b = __values(this.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var _d = __read(_c.value, 2), index = _d[0], item = _d[1];\r\n                if (matchFunc == null || matchFunc.call(item, item, index)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_4) throw e_4.error; }\r\n        }\r\n        return false;\r\n    },\r\n    All: function (matchFunc) {\r\n        var e_5, _a;\r\n        try {\r\n            for (var _b = __values(this.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var _d = __read(_c.value, 2), index = _d[0], item = _d[1];\r\n                if (!matchFunc.call(item, item, index)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_5) throw e_5.error; }\r\n        }\r\n        return true;\r\n    },\r\n    Where: function (matchFunc) {\r\n        var e_6, _a;\r\n        var result = [];\r\n        try {\r\n            for (var _b = __values(this.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var _d = __read(_c.value, 2), index = _d[0], item = _d[1];\r\n                if (matchFunc.call(item, item, index)) { // call, having the item be \"this\", as well as the first argument\r\n                    result.push(item);\r\n                }\r\n            }\r\n        }\r\n        catch (e_6_1) { e_6 = { error: e_6_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_6) throw e_6.error; }\r\n        }\r\n        return result;\r\n    },\r\n    Select: function (selectFunc) {\r\n        var e_7, _a;\r\n        var result = [];\r\n        try {\r\n            for (var _b = __values(this.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var _d = __read(_c.value, 2), index = _d[0], item = _d[1];\r\n                result.push(selectFunc.call(item, item, index));\r\n            }\r\n        }\r\n        catch (e_7_1) { e_7 = { error: e_7_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_7) throw e_7.error; }\r\n        }\r\n        return result;\r\n    },\r\n    SelectMany: function (selectFunc) {\r\n        var e_8, _a;\r\n        //return [...this.entries()].reduce((acc, [index, item])=>acc.concat(selectFunc.call(item, item, index)), []);\r\n        var result = [];\r\n        try {\r\n            for (var _b = __values(this.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var _d = __read(_c.value, 2), index = _d[0], item = _d[1];\r\n                exports.ArrayCES.AddRange(result, selectFunc.call(item, item, index));\r\n            }\r\n        }\r\n        catch (e_8_1) { e_8 = { error: e_8_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_8) throw e_8.error; }\r\n        }\r\n        return result;\r\n    },\r\n    //Count(matchFunc) { return this.Where(matchFunc).length; };\r\n    //Count(matchFunc) { return this.Where(matchFunc).length; }; // needed for items to be added properly to custom classes that extend Array\r\n    // needed for items to be added properly to custom classes that extend Array\r\n    Count: function () {\r\n        return this.length;\r\n    },\r\n    VCount: function (matchFunc) {\r\n        return exports.ArrayCES.Where(this, matchFunc).length;\r\n    },\r\n    Clear: function () {\r\n        /*while (this.length > 0)\r\n            this.pop();*/\r\n        this.splice(0, this.length);\r\n    },\r\n    /* interface Array<T> { /** Same as forEach, except breaks the loop when \"true\" is returned. *#/ forEach_break(callbackfn: (value: any, index: number, array: any[]) => boolean, thisArg?: any); }\r\n    forEach_break(...args) { return this.some(...args); } */\r\n    First: function (matchFunc) {\r\n        var result = exports.ArrayCES.FirstOrX(this, matchFunc);\r\n        if (result == null) {\r\n            throw new Error(\"Matching item not found.\");\r\n        }\r\n        return result;\r\n    },\r\n    FirstOrX: function (matchFunc, x) {\r\n        var e_9, _a;\r\n        if (x === void 0) { x = null; }\r\n        if (matchFunc) {\r\n            try {\r\n                for (var _b = __values(this.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var _d = __read(_c.value, 2), index = _d[0], item = _d[1];\r\n                    if (matchFunc.call(item, item, index)) {\r\n                        return item;\r\n                    }\r\n                }\r\n            }\r\n            catch (e_9_1) { e_9 = { error: e_9_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_9) throw e_9.error; }\r\n            }\r\n        }\r\n        else if (this.length > 0) {\r\n            return this[0];\r\n        }\r\n        return x;\r\n    },\r\n    //FirstWithPropValue(propName, propValue) { return this.Where(function() { return this[propName] == propValue; })[0]; };\r\n    FirstWith: function (propName, propValue) {\r\n        return exports.ArrayCES.Where(this, function () { return this[propName] == propValue; })[0];\r\n    },\r\n    Last: function (matchFunc) {\r\n        var result = exports.ArrayCES.LastOrX(this, matchFunc);\r\n        if (result === undefined) {\r\n            throw new Error(\"Matching item not found.\");\r\n        }\r\n        return result;\r\n    },\r\n    LastOrX: function (matchFunc, x) {\r\n        if (x === void 0) { x = null; }\r\n        if (matchFunc) {\r\n            for (var i = this.length - 1; i >= 0; i--) {\r\n                if (matchFunc.call(this[i], this[i], i)) {\r\n                    return this[i];\r\n                }\r\n            }\r\n        }\r\n        else if (this.length > 0) {\r\n            return this[this.length - 1];\r\n        }\r\n        return x;\r\n    },\r\n    XFromLast: function (x) {\r\n        return this[(this.length - 1) - x];\r\n    },\r\n    Move: function (item, newIndex, newIndexAsPreRemovalIndexVSFinalIndex) {\r\n        if (newIndexAsPreRemovalIndexVSFinalIndex === void 0) { newIndexAsPreRemovalIndexVSFinalIndex = false; }\r\n        var oldIndex = this.indexOf(item);\r\n        /*if (oldIndex != -1) {\r\n            this.RemoveAt(oldIndex);\r\n            // New-index is understood to be the position-in-list to move the item to, as seen before the item started being moved.\r\n            // So compensate for remove-from-old-position list modification.\r\n            if (shiftInsertPointToPreserveFinalNeighbors && oldIndex < newIndex) {\r\n                newIndex--;\r\n            }\r\n        }\r\n        this.Insert(newIndex, item);*/\r\n        if (newIndexAsPreRemovalIndexVSFinalIndex) {\r\n            exports.ArrayCES.Insert(this, newIndex, item);\r\n            if (oldIndex != -1) {\r\n                var oldEntry_currentIndex = newIndex <= oldIndex ? oldIndex + 1 : oldIndex; // if we just inserted the new version before the old entry, fix the old-entry's index by adding 1\r\n                exports.ArrayCES.RemoveAt(this, oldEntry_currentIndex);\r\n            }\r\n        }\r\n        else {\r\n            if (oldIndex != -1) {\r\n                exports.ArrayCES.RemoveAt(this, oldIndex);\r\n            }\r\n            exports.ArrayCES.Insert(this, newIndex, item);\r\n        }\r\n        return oldIndex;\r\n    },\r\n    //ToList<T>(this: T[], itemType = null) { return [].concat(this); }\r\n    /*ToDictionary(keyFunc, valFunc) {\r\n        var result = new Dictionary();\r\n        for (var i in this)\r\n            result.Add(keyFunc(this[i]), valFunc(this[i]));\r\n        return result;\r\n    }*/\r\n    ToMap: function (keyFunc, valFunc) {\r\n        var e_10, _a;\r\n        var result = {};\r\n        try {\r\n            for (var _b = __values(this.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var _d = __read(_c.value, 2), index = _d[0], item = _d[1];\r\n                result[keyFunc(item, index)] = valFunc(item, index);\r\n            }\r\n        }\r\n        catch (e_10_1) { e_10 = { error: e_10_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_10) throw e_10.error; }\r\n        }\r\n        return result;\r\n    },\r\n    Skip: function (count) {\r\n        var result = [];\r\n        for (var i = count; i < this.length; i++) {\r\n            result.push(this[i]);\r\n        }\r\n        return result;\r\n    },\r\n    Take: function (count) {\r\n        var result = [];\r\n        for (var i = 0; i < count && i < this.length; i++) {\r\n            result.push(this[i]);\r\n        }\r\n        return result;\r\n    },\r\n    TakeLast: function (count) {\r\n        var result = [];\r\n        for (var i = 0; i < count && (this.length - 1) - i >= 0; i++) {\r\n            result.push(this[(this.length - 1) - i]);\r\n        }\r\n        return result;\r\n    },\r\n    FindIndex: function (matchFunc) {\r\n        var e_11, _a;\r\n        try {\r\n            for (var _b = __values(this.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var _d = __read(_c.value, 2), index = _d[0], item = _d[1];\r\n                if (matchFunc.call(item, item, index)) { // call, having the item be \"this\", as well as the first argument\r\n                    return index;\r\n                }\r\n            }\r\n        }\r\n        catch (e_11_1) { e_11 = { error: e_11_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_11) throw e_11.error; }\r\n        }\r\n        return -1;\r\n    },\r\n    /*FindIndex(matchFunc: (item: T)=>boolean) {\r\n        for (let [index, item] of this.entries())\r\n            if (matchFunc.call(item, item))\r\n                    return index;\r\n        return -1;\r\n    };*/\r\n    OrderBy: function (valFunc) {\r\n        if (valFunc === void 0) { valFunc = function (item, index) { return item; }; }\r\n        /*var temp = this.ToList();\r\n        temp.sort((a, b)=>V.Compare(valFunc(a), valFunc(b)));\r\n        return temp;*/\r\n        return General_1.StableSort(this, function (a, b, aIndex, bIndex) { return General_1.Compare(valFunc(a, aIndex), valFunc(b, bIndex)); });\r\n    },\r\n    OrderByDescending: function (valFunc) {\r\n        if (valFunc === void 0) { valFunc = function (item, index) { return item; }; }\r\n        return exports.ArrayCES.OrderBy(this, function (item, index) { return -valFunc(item, index); });\r\n    },\r\n    Distinct: function () {\r\n        var result = [];\r\n        for (var i in this) {\r\n            if (!this.hasOwnProperty(i))\r\n                continue;\r\n            if (!exports.ArrayCES.Contains(result, this[i])) {\r\n                result.push(this[i]);\r\n            }\r\n        }\r\n        return result;\r\n    },\r\n    Except: (function () {\r\n        var _a, e_12, _b;\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var opt, excludeItems;\r\n        if (args[0] && \"excludeEachOnlyOnce\" in args[0])\r\n            _a = __read(args, 2), opt = _a[0], excludeItems = _a[1];\r\n        else\r\n            excludeItems = args;\r\n        if (opt.excludeEachOnlyOnce) {\r\n            var result = this.slice();\r\n            try {\r\n                for (var excludeItems_1 = __values(excludeItems), excludeItems_1_1 = excludeItems_1.next(); !excludeItems_1_1.done; excludeItems_1_1 = excludeItems_1.next()) {\r\n                    var excludeItem = excludeItems_1_1.value;\r\n                    exports.ArrayCES.Remove(result, excludeItem);\r\n                }\r\n            }\r\n            catch (e_12_1) { e_12 = { error: e_12_1 }; }\r\n            finally {\r\n                try {\r\n                    if (excludeItems_1_1 && !excludeItems_1_1.done && (_b = excludeItems_1.return)) _b.call(excludeItems_1);\r\n                }\r\n                finally { if (e_12) throw e_12.error; }\r\n            }\r\n            return result;\r\n        }\r\n        return this.filter(function (a) { return !exports.ArrayCES.Contains(excludeItems, a); });\r\n    }),\r\n    IfEmptyThen: function (valIfSelfIsEmpty) {\r\n        return this.length == 0 ? valIfSelfIsEmpty : this;\r\n    },\r\n    //JoinUsing(separator) { return this.join(separator);};\r\n    Min: function (valFunc, asNumbers) {\r\n        if (asNumbers === void 0) { asNumbers = false; }\r\n        if (asNumbers) {\r\n            /*let values = valFunc ? this.map(valFunc) : this;\r\n            return Math.min(...values);*/\r\n            Assert_1.Assert(valFunc == null, \"Cannot use valFunc if asNumbers is set to true.\");\r\n            return Math.min.apply(Math, __spread(this));\r\n        }\r\n        return exports.ArrayCES.OrderBy(this, valFunc)[0];\r\n    },\r\n    Max: function (valFunc, asNumbers) {\r\n        if (asNumbers === void 0) { asNumbers = false; }\r\n        if (asNumbers) {\r\n            /*let values = valFunc ? this.map(valFunc) : this;\r\n            return Math.max(...values);*/\r\n            Assert_1.Assert(valFunc == null, \"Cannot use valFunc if asNumbers is set to true.\");\r\n            return Math.max.apply(Math, __spread(this));\r\n        }\r\n        return exports.ArrayCES.LastOrX(exports.ArrayCES.OrderBy(this, valFunc));\r\n    },\r\n    Sum: function () {\r\n        var e_13, _a;\r\n        var total = 0;\r\n        try {\r\n            for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var item = _c.value;\r\n                total += item;\r\n            }\r\n        }\r\n        catch (e_13_1) { e_13 = { error: e_13_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_13) throw e_13.error; }\r\n        }\r\n        return total;\r\n    },\r\n    Average: function () {\r\n        var total = exports.ArrayCES.Sum(this);\r\n        return total / this.length;\r\n    },\r\n    Median: function () {\r\n        var ordered = exports.ArrayCES.OrderBy(this, function (a) { return a; });\r\n        if (this.length % 2 == 0) { // if even number of elements, average two middlest ones\r\n            return ordered[(this.length / 2) - 1] + ordered[this.length / 2];\r\n        }\r\n        return ordered[this.length / 2]; // otherwise, return the exactly-middle one\r\n    },\r\n    Random: function () {\r\n        var index = Math.floor(Math.random() * this.length);\r\n        return this[index];\r\n    },\r\n    //oldJoin: [].join,\r\n    join: function (separator) {\r\n        if (separator === void 0) { separator = \",\"; }\r\n        if (this.length == 0)\r\n            return \"\";\r\n        //let result = \"\" + this[0];\r\n        var result = this[0] != null ? \"\" + this[0] : \"\"; // to match behavior of native join\r\n        for (var i = 1, len = this.length; i < len; i++) {\r\n            result += separator;\r\n            result += this[i] != null ? \"\" + this[i] : \"\";\r\n        }\r\n        /*let oldResult = oldJoin.apply(this, arguments);\r\n        if (oldResult != result) debugger;*/\r\n        return result;\r\n    },\r\n};\r\nexports.ArrayCE = General_1.CreateProxyForClassExtensions(exports.ArrayCE_funcs);\r\nexports.ArrayCES = General_1.WithFuncsStandalone(exports.ArrayCE_funcs);\r\n/*var ArrayIterator = [].entries().constructor;\r\nexport class ArrayIteratorCEProxy {\r\n    ToArray(this: ArrayIterator) {\r\n        return Array.from(this);\r\n    }\r\n}\r\nexport const ArrayIteratorCE = CreateProxyForClassExtensions(ArrayIteratorCEProxy);*/\r\n/*export class NodeListCEProxy {\r\n    ToArray(this: NodeList) {\r\n        return Array.from(this);\r\n    }\r\n}\r\nexport const NodeListCE = CreateProxyForClassExtensions(NodeListCEProxy);*/ \r\n//# sourceMappingURL=CE_Array.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar CE_Array_1 = require(\"./CE_Array\");\r\nvar CE_Number_1 = require(\"./CE_Number\");\r\nvar CE_Object_1 = require(\"./CE_Object\");\r\nvar CE_String_1 = require(\"./CE_String\");\r\nvar __1 = require(\"..\");\r\nvar Types_1 = require(\"../Utils/Types\");\r\nvar CE_Others_1 = require(\"./CE_Others\");\r\n/*interface CE_Auto_I {\r\n    (obj: Array<any>): typeof ArrayCE;\r\n    (obj: Element): typeof ElementCE;\r\n    (obj: number): typeof NumberCE;\r\n    (obj: Object): typeof ObjectCE;\r\n    (obj: string): typeof StringCE;\r\n}\r\n\r\nexport const CE_Auto = ((obj)=> {\r\n}) as CE_Auto_I;*/\r\nvar classExtensionMap = {\r\n    Number: CE_Number_1.NumberCE,\r\n    String: CE_String_1.StringCE,\r\n    Date: CE_Others_1.DateCE,\r\n    Element: __1.ElementCE,\r\n    Function: CE_Others_1.FunctionCE,\r\n    Array: CE_Array_1.ArrayCE,\r\n    Object: CE_Object_1.ObjectCE,\r\n};\r\nfunction CE(obj, checkForUncommonDerived) {\r\n    if (checkForUncommonDerived === void 0) { checkForUncommonDerived = false; }\r\n    // first, try to get class-extension func based on direct constructor name (most common case)\r\n    var typeName = obj.constructor ? obj.constructor.name : null;\r\n    if (typeName && classExtensionMap[typeName]) {\r\n        return classExtensionMap[typeName](obj);\r\n    }\r\n    // else, check each option using \"instanceof\" and such (needed for derived classes)\r\n    if (checkForUncommonDerived) {\r\n        if (Types_1.IsNumber(obj, true))\r\n            return CE_Number_1.NumberCE(obj);\r\n        if (Types_1.IsString(obj, true))\r\n            return CE_String_1.StringCE(obj);\r\n        if (obj instanceof Date)\r\n            return CE_Others_1.DateCE(obj);\r\n        if (Types_1.IsFunction(obj))\r\n            return CE_Others_1.FunctionCE(obj);\r\n        if (Types_1.IsArray(obj))\r\n            return CE_Array_1.ArrayCE(obj);\r\n    }\r\n    if (obj instanceof Element)\r\n        return __1.ElementCE(obj);\r\n    /*if (IsObject(obj)) return ObjectCE(obj);\r\n    throw new Error(`Could not find class-extension helper for type \"${obj.constructor ? obj.constructor.name : \"n/a\"}\".`);*/\r\n    return CE_Object_1.ObjectCE(obj);\r\n}\r\nexports.CE = CE;\r\n//# sourceMappingURL=CE_Auto.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar General_1 = require(\"../Utils/General\");\r\nexports.ElementCE_funcs = {\r\n    GetParents: function (topDown) {\r\n        if (topDown === void 0) { topDown = false; }\r\n        var result = [];\r\n        var currentParent = this.parentElement;\r\n        while (currentParent) {\r\n            result.push(currentParent);\r\n            currentParent = currentParent.parentElement;\r\n        }\r\n        if (topDown)\r\n            result.reverse();\r\n        return result;\r\n    },\r\n    GetSelfAndParents: function (topDown) {\r\n        if (topDown === void 0) { topDown = false; }\r\n        var result = exports.ElementCE(this).GetParents(topDown);\r\n        return topDown ? result.concat([this]) : [this].concat(result);\r\n    },\r\n    /*QuerySelectorAll_BreadthFirst(this: HTMLElement, selector: string) {\r\n        var $found = [];\r\n        let currentSet = this.childNodes.ToArray();\r\n        while (currentSet.length) {\r\n            let found = currentSet.filter(a=>a.matches(selector));\r\n            if ($found.length) break;\r\n            // Get all children of the current set\r\n            $currentSet = $currentSet.children();\r\n        }\r\n        return $found.first(); // Return first match of the collection\r\n    }*/\r\n    QuerySelector_BreadthFirst: function (selector) {\r\n        var currentLayerElements = Array.from(this.childNodes);\r\n        while (currentLayerElements.length) {\r\n            var firstMatchInLayer = currentLayerElements.find(function (a) { return a[\"matches\"] && a[\"matches\"](selector); });\r\n            if (firstMatchInLayer)\r\n                return firstMatchInLayer;\r\n            //currentLayerElements = currentLayerElements.SelectMany(a=>[...a.childNodes]);\r\n            currentLayerElements = currentLayerElements.reduce(function (acc, item) { return acc.concat(Array.from(item.childNodes)); }, []);\r\n        }\r\n        return null;\r\n    },\r\n    $: function (queryStr) {\r\n        return Array.from(this.querySelectorAll(queryStr));\r\n    },\r\n};\r\nexports.ElementCE = General_1.CreateProxyForClassExtensions(exports.ElementCE_funcs);\r\n// maybe make ElementCE preserve the target-type, like ObjectCE and ArrayCE do (not needed atm, since the CE-methods don't make any/much use of the target's type-data)\r\n//export const ElementCE = CreateProxyForClassExtensions(ElementCE_funcs) as <T>(nextThis: T)=>ElementCEProxy;\r\nexports.ElementCES = General_1.WithFuncsStandalone(exports.ElementCE_funcs);\r\n//# sourceMappingURL=CE_Element.js.map","\"use strict\";\r\nvar __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar CE_String_1 = require(\"./CE_String\");\r\nvar General_1 = require(\"../Utils/General\");\r\nvar Types_1 = require(\"../Utils/Types\");\r\n// Note: Since JS coerces number primitives to the Number class when a property-access is attempted (https://javascriptrefined.io/the-wrapper-object-400311b29151)...\r\n// ...calling the functions below using, eg. \"(3).WrapToRange\" *should* make the \"this\" variable be a Number class within the WrapToRange function.\r\n// However, this is not the case! -- at least when I try it in the Chrome console, with the actual Webpack-added function. (if I add a function with the exact same source using the console, it is coerced to Number as expected)\r\n// I think it might be a Chrome optimization or something.\r\n// Anyway, the code below is based on how it *should* work, with the \"this\" var always being a Number wrapper. (we use \"as number\" in some places below, since valueOf gets auto-called to enable the primitive math ops anyway)\r\nexports.NumberCE_funcs = {\r\n    IfN1Then: function (valIfSelfIsNeg1) {\r\n        return this == -1 ? valIfSelfIsNeg1 : this;\r\n    },\r\n    NaNTo: function (valIfSelfIsNaN) {\r\n        return Types_1.IsNaN(this) ? valIfSelfIsNaN : this;\r\n    },\r\n    //RoundToMultipleOf(step) { return Math.round(new Number(this) / step) * step; }; //return this.lastIndexOf(str, 0) === 0; };\r\n    ToPercentStr: function (precision) {\r\n        var number = this * 100;\r\n        if (precision != null)\r\n            return number.toFixed(precision) + \"%\";\r\n        return number.toString() + \"%\";\r\n    },\r\n    IsMultipleOf: function (multipleOf, maxDistToBeMultiple) {\r\n        var valRoundedToMultiple = exports.NumberCE(this).RoundTo(multipleOf);\r\n        var distance = exports.NumberCE(valRoundedToMultiple).Distance(this);\r\n        return distance <= maxDistToBeMultiple;\r\n    },\r\n    RoundTo: function (multiple) {\r\n        //return Math.round(this / multiple) * multiple;\r\n        // Don't ask me why this works, but it does, and is faster. From: http://phrogz.net/round-to-nearest-via-modulus-division\r\n        /*var half = multiple / 2;\r\n        return (this + half) - ((this + half) % multiple);*/\r\n        // Realign/scale the possible values/multiples, so that each value is given an integer slot. Place the actual value (this) within the appropriate slot using Math.round() int-rounding, then reverse the scaling to get the true rounded value.\r\n        // (This version handles fractions better. Ex: (.2 + .1).RoundTo(.1) == .3 [NOT 0.3000000000000004, as the simpler approach gives])\r\n        var multiple_inverted = 1 / multiple;\r\n        return Math.round(this * multiple_inverted) / multiple_inverted;\r\n    },\r\n    RoundTo_Str: function (multipleOf, fractionDigits, removeEmptyFraction) {\r\n        if (fractionDigits === void 0) { fractionDigits = null; }\r\n        if (removeEmptyFraction === void 0) { removeEmptyFraction = true; }\r\n        var resultValue = exports.NumberCE(this).RoundTo(multipleOf);\r\n        var result = resultValue.toFixed(fractionDigits != null ? fractionDigits : multipleOf.toString().TrimStart(\"0\").length - 1); // - 0);\r\n        if (removeEmptyFraction && CE_String_1.StringCE(result).Contains(\".\")) {\r\n            result = CE_String_1.StringCE(CE_String_1.StringCE(result).TrimEnd(\"0\")).TrimEnd(\".\");\r\n        }\r\n        return result;\r\n    },\r\n    FloorTo: function (multipleOf) { return Math.floor(new Number(this) / multipleOf) * multipleOf; },\r\n    FloorTo_Str: function (multipleOf) {\r\n        var resultValue = exports.NumberCE(this).FloorTo(multipleOf);\r\n        var result = resultValue.toFixed(multipleOf.toString().TrimStart(\"0\").length); // - 1);\r\n        if (CE_String_1.StringCE(result).Contains(\".\"))\r\n            result = CE_String_1.StringCE(CE_String_1.StringCE(result).TrimEnd(\"0\")).TrimEnd(\".\");\r\n        return result;\r\n    },\r\n    CeilingTo: function (multipleOf) { return Math.ceil(new Number(this) / multipleOf) * multipleOf; },\r\n    CeilingTo_Str: function (multipleOf) {\r\n        var resultValue = exports.NumberCE(this).CeilingTo(multipleOf);\r\n        var result = resultValue.toFixed(multipleOf.toString().TrimStart(\"0\").length); // - 1);\r\n        if (CE_String_1.StringCE(result).Contains(\".\"))\r\n            result = CE_String_1.StringCE(CE_String_1.StringCE(result).TrimEnd(\"0\")).TrimEnd(\".\");\r\n        //result = TrimEnd(TrimEnd(result, \"0\"), \".\");\r\n        return result;\r\n    },\r\n    KeepAtLeast: function (min) {\r\n        return Math.max(min, this);\r\n    },\r\n    KeepAtMost: function (max) {\r\n        return Math.min(max, this);\r\n    },\r\n    KeepBetween: function (min, max, allowFixMinMax) {\r\n        var _a;\r\n        if (allowFixMinMax === void 0) { allowFixMinMax = true; }\r\n        if (min > max && allowFixMinMax) {\r\n            _a = __read([max, min], 2), min = _a[0], max = _a[1];\r\n        }\r\n        if (this < min)\r\n            return min;\r\n        if (this > max)\r\n            return max;\r\n        return this;\r\n    },\r\n    WrapToRange: function (min, max, maxOut) {\r\n        if (maxOut === void 0) { maxOut = true; }\r\n        var val = this;\r\n        var size = max - min;\r\n        while (val < min)\r\n            val += size;\r\n        while (maxOut ? val >= max : val > max)\r\n            val -= size;\r\n        return val;\r\n    },\r\n    Distance: function (other) {\r\n        return Math.abs(this - other);\r\n    },\r\n    ToPower: function (power) {\r\n        return Math.pow(this, power);\r\n    },\r\n};\r\nexports.NumberCE = General_1.CreateProxyForClassExtensions(exports.NumberCE_funcs);\r\nexports.NumberCES = General_1.WithFuncsStandalone(exports.NumberCE_funcs);\r\n//# sourceMappingURL=CE_Number.js.map","\"use strict\";\r\nvar __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nvar __values = (this && this.__values) || function(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar General_1 = require(\"../Utils/General\");\r\nvar CE_Array_1 = require(\"./CE_Array\");\r\nvar Types_1 = require(\"../Utils/Types\");\r\nvar CE_Others_1 = require(\"./CE_Others\");\r\n/*export type WithFuncThisArgsAsXOrWrapped_Type<Source> = {\r\n    [P in keyof Source]:\r\n        Source[P] extends (this: infer ThisArgType, ...args)=>any ? (this: XOrWrapped<ThisArgType>, ...args: Parameters<Source[P]>)=>ReturnType<Source[P]> :\r\n        Source[P];\r\n};\r\nexport function WithFuncThisArgsAsXOrWrapped<Source>(source: Source): WithFuncThisArgsAsXOrWrapped_Type<Source> {\r\n    return source as any;\r\n}*/\r\nexports.specialKeys = [\"_\", \"_key\", \"_id\"];\r\nexports.ObjectCE_funcs = {\r\n    // base\r\n    // ==========\r\n    /** Helps you do stuff like this:\r\n        Array.prototype._AddFunction(function AddX(value) { this.push(value); }); []._AddX(\"newItem\"); */\r\n    _AddItem: function (name, value, forceAdd) {\r\n        if (forceAdd === void 0) { forceAdd = false; }\r\n        if (name == null || name.length == 0)\r\n            throw new Error(\"No prop-name was specified for _AddItem() call.\");\r\n        if (name in this)\r\n            delete this[name];\r\n        if (name in this && !forceAdd)\r\n            return; // workaround for some properties not being deleted\r\n        Object.defineProperty(this, name, {\r\n            configurable: true,\r\n            enumerable: false,\r\n            value: value\r\n        });\r\n        /*if (this[name] == null)\r\n            throw new Error(`Failed to add property \"${name}\" to type \"${this}\".`);*/\r\n    },\r\n    _AddFunction: function (name, func) {\r\n        //this._AddItem(func.name || func.toString().match(/^function\\s*([^\\s(]+)/)[1], func);\r\n        exports.ObjectCES._AddItem(this, name, func);\r\n    },\r\n    // the below helps you do stuff like this:\r\n    //\t\tArray.prototype._AddGetterSetter(\"AddX\", null, function(value) { this.push(value); }); [].AddX = \"newItem\";\r\n    _AddGetterSetter: function (name, getter, setter) {\r\n        //var name = (getter || setter).name || (getter || setter).toString().match(/^function\\s*([^\\s(]+)/)[1];\r\n        if (name in this)\r\n            delete this[name];\r\n        if (name in this)\r\n            return; // workaround for some properties not being deleted\r\n        var info = { configurable: true, enumerable: false };\r\n        if (getter)\r\n            info.get = getter;\r\n        if (setter)\r\n            info.set = setter;\r\n        Object.defineProperty(this, name, info);\r\n    },\r\n    // the below helps you do stuff like this:\r\n    //\t\tArray.prototype._AddFunction_Inline = function AddX(value) { this.push(value); }; [].AddX = \"newItem\";\r\n    set _AddFunction_Inline(func) {\r\n        exports.ObjectCES._AddFunction(this, CE_Others_1.FunctionCE(func).GetName(), func);\r\n    },\r\n    set _AddGetter_Inline(func) {\r\n        exports.ObjectCES._AddGetterSetter(this, CE_Others_1.FunctionCE(func).GetName(), func, null);\r\n    },\r\n    set _AddSetter_Inline(func) {\r\n        exports.ObjectCES._AddGetterSetter(this, CE_Others_1.FunctionCE(func).GetName(), null, func);\r\n    },\r\n    // normal\r\n    // ==========\r\n    //Object.prototype._AddSetter_Inline = function ExtendWith_Inline(value) { this.ExtendWith(value); };\r\n    //ExtendWith(value) { $.extend(this, value); };\r\n    /*GetItem_SetToXIfNull(itemName, /*;optional:*#/ defaultValue) {\r\n        if (!this[itemName])\r\n            this[itemName] = defaultValue;\r\n        return this[itemName];\r\n    };*/\r\n    // must also do it on window/global, for some reason\r\n    /*g.Extend = function(x) {\r\n        for (var name in x) {\r\n            var value = x[name];\r\n            //if (value !== undefined)\r\n            this[name] = value;\r\n        }\r\n        return this;\r\n    };*/\r\n    Extend: function (x) {\r\n        for (var key in x) {\r\n            if (!x.hasOwnProperty(key))\r\n                continue;\r\n            var value = x[key];\r\n            //if (value !== undefined)\r\n            this[key] = value;\r\n        }\r\n        return this;\r\n    },\r\n    // as replacement for C#'s \"new MyClass() {prop = true}\"\r\n    /*VSet<T>(this: T, propName: string, propValue, options?: VSet_Options): TargetTFor<T>;\r\n    //VSet<T extends RealThis>(this: T, props: any, options?: VSet_Options): T; // variant for ObjectCE(obj).X calls (those types only uses the last declaration, and they need \"extend RealThis\" since we any-ify the this-param)\r\n    VSet<T>(this: T, props: any, options?: VSet_Options): TargetTFor<T>; // this one needs to be last (best override for the CE(...) wrapper, and it can only extract the last one)*/\r\n    VSet: (function () {\r\n        var _a, _b;\r\n        var _this = this;\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var props, options, propName, propValue;\r\n        if (typeof args[0] == \"object\")\r\n            _a = __read(args, 2), props = _a[0], options = _a[1];\r\n        else\r\n            _b = __read(args, 3), propName = _b[0], propValue = _b[1], options = _b[2];\r\n        options = options || {};\r\n        var SetProp = function (name, value) {\r\n            if (value === General_1.DEL || (value === undefined && options.deleteUndefined) || (value === null && options.deleteNull) || (value === \"\" && options.deleteEmpty)) {\r\n                delete _this[name];\r\n                return;\r\n            }\r\n            if (options.prop) {\r\n                Object.defineProperty(_this, name, Object.assign({ configurable: true }, options.prop, { value: value }));\r\n            }\r\n            else {\r\n                _this[name] = value;\r\n            }\r\n        };\r\n        if (props) {\r\n            for (var key in props) {\r\n                if (!props.hasOwnProperty(key))\r\n                    continue;\r\n                SetProp(key, props[key]);\r\n            }\r\n        }\r\n        else {\r\n            SetProp(propName, propValue);\r\n        }\r\n        return this;\r\n    }),\r\n    Extended: function (x) {\r\n        // maybe temp; explicit unwrapping, to fix odd \"instantiation is excessively deep\" ts-error (when calling .Extended from user project)\r\n        /*Extended<T, T2>(this: T, x: T2): T & T2;\r\n        Extended<T, T2>(this: ObjectCEProxy<T>, x: T2): T & T2;\r\n        Extended(x: any) {*/\r\n        //Extended<T, T2>(this: ObjectCEProxy<T> | T, x: T2): T & T2 {\r\n        var result = this instanceof Array ? [] : {};\r\n        for (var key in this) {\r\n            if (!this.hasOwnProperty(key))\r\n                continue;\r\n            result[key] = this[key];\r\n        }\r\n        if (x) {\r\n            for (var key in x) {\r\n                if (!x.hasOwnProperty(key))\r\n                    continue;\r\n                result[key] = x[key];\r\n            }\r\n        }\r\n        return result;\r\n    },\r\n    /*interface Object { Extended2<T>(this, x: T): T; }\r\n    Extended2(x) {\r\n        return this.Extended(x);\r\n    };*/\r\n    //E(x) { return this.Extended(x); };\r\n    SafeGet: (function (pathOrPathGetterFunc, resultIfNull) {\r\n        var pathSegments = typeof pathOrPathGetterFunc == \"string\" ? pathOrPathGetterFunc : General_1.ConvertPathGetterFuncToPropChain(pathOrPathGetterFunc);\r\n        return General_1.DeepGet(this, pathSegments, resultIfNull);\r\n    }),\r\n    VAct: function (func) {\r\n        func.call(this, this);\r\n        return this;\r\n    },\r\n    As: function (type) {\r\n        Object.setPrototypeOf(this, type.prototype);\r\n        return this;\r\n    },\r\n    Strip: function () {\r\n        Object.setPrototypeOf(this, Object.getPrototypeOf({}));\r\n        return this;\r\n    },\r\n    Including: function () {\r\n        var e_1, _a;\r\n        var keys = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            keys[_i] = arguments[_i];\r\n        }\r\n        var result = this instanceof Array ? [] : {};\r\n        try {\r\n            for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\r\n                var key = keys_1_1.value;\r\n                //if (!this.hasOwnProperty(key)) continue;\r\n                if (!(key in this))\r\n                    continue; // we include the value, even if from prototype (user wouldn't list in keys array if didn't want it)\r\n                result[key] = this[key];\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        return result;\r\n    },\r\n    Excluding: function () {\r\n        var e_2, _a;\r\n        var keys = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            keys[_i] = arguments[_i];\r\n        }\r\n        //var result = Clone(this); // doesn't work with funcs\r\n        var result = Object.assign(this instanceof Array ? [] : {}, this);\r\n        try {\r\n            for (var keys_2 = __values(keys), keys_2_1 = keys_2.next(); !keys_2_1.done; keys_2_1 = keys_2.next()) {\r\n                var key = keys_2_1.value;\r\n                delete result[key];\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (keys_2_1 && !keys_2_1.done && (_a = keys_2.return)) _a.call(keys_2);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        return result;\r\n    },\r\n    IsOneOf: function () {\r\n        var values = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            values[_i] = arguments[_i];\r\n        }\r\n        if (CE_Array_1.ArrayCE(values).Contains(this)) {\r\n            return true;\r\n        }\r\n        // if the value-list contains the primitive-version of self, consider it a match -- otherwise calling \"test1\".IsOneOf(\"test1\", \"test2\") would fail\r\n        var isObjectFormOfPrimitive = this instanceof Boolean || this instanceof Number || this instanceof String;\r\n        if (isObjectFormOfPrimitive && CE_Array_1.ArrayCE(values).Contains(this.valueOf())) {\r\n            return true;\r\n        }\r\n        return false;\r\n    },\r\n    // todo: probably remove Props(), and instead just use Pairs(), since Props() sounds odd when used on arrays\r\n    /*declare global {\r\n        interface Object {\r\n            Props<T>(this: {[key: number]: T} | {[key: string]: T}, excludeSpecialProps?: boolean): {index: number, name: string, value: T}[];\r\n            Props<T>(excludeSpecialProps?: boolean): {index: number, name: string, value: T}[];\r\n        }\r\n    }\r\n    //interface Object { Props<ValueType>(excludeSpecialProps?: boolean): {index: number, name: string, value: ValueType}[]; }\r\n    Props(excludeSpecialProps = false) {\r\n        var result = [];\r\n        var i = 0;\r\n        for (var propName in this) {\r\n            if (excludeSpecialProps && (propName == \"_\" || propName == \"_key\" || propName == \"_id\")) continue;\r\n            //result.push({index: i++, key: propName, name: propName, value: this[propName]});\r\n            result.push({index: i++, name: propName, value: this[propName]});\r\n        }\r\n        return result;\r\n    },*/\r\n    Pairs: (function (excludeSpecialKeys) {\r\n        var e_3, _a;\r\n        if (excludeSpecialKeys === void 0) { excludeSpecialKeys = false; }\r\n        var result = [];\r\n        var i = 0;\r\n        var keys = this instanceof Map ? Array.from(this.keys()) : Object.keys(this);\r\n        try {\r\n            for (var keys_3 = __values(keys), keys_3_1 = keys_3.next(); !keys_3_1.done; keys_3_1 = keys_3.next()) {\r\n                var key = keys_3_1.value;\r\n                if (excludeSpecialKeys && (key == \"_\" || key == \"_key\" || key == \"_id\"))\r\n                    continue;\r\n                var entry = { index: i++, key: key, keyNum: Number(key), value: this instanceof Map ? this.get(key) : this[key] };\r\n                if (Types_1.IsNaN(entry.keyNum))\r\n                    delete entry.keyNum;\r\n                result.push(entry);\r\n            }\r\n        }\r\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n        finally {\r\n            try {\r\n                if (keys_3_1 && !keys_3_1.done && (_a = keys_3.return)) _a.call(keys_3);\r\n            }\r\n            finally { if (e_3) throw e_3.error; }\r\n        }\r\n        return result;\r\n    }),\r\n    VKeys: (function (excludeSpecialKeys) {\r\n        if (excludeSpecialKeys === void 0) { excludeSpecialKeys = false; }\r\n        //if (excludeSpecialKeys) return this.Props(true).map(a=>a.name);\r\n        var keys = this instanceof Map ? Array.from(this.keys()) : Object.keys(this);\r\n        if (excludeSpecialKeys)\r\n            keys = CE_Array_1.ArrayCE(keys).Except(exports.specialKeys);\r\n        return keys;\r\n    }),\r\n    VValues: (function (excludeSpecialKeys) {\r\n        var _this = this;\r\n        if (excludeSpecialKeys === void 0) { excludeSpecialKeys = false; }\r\n        //if (excludeSpecialKeys) return this.Props(true).map(a=>a.value);\r\n        return exports.ObjectCES.VKeys(this, excludeSpecialKeys).map(function (key) { return _this instanceof Map ? _this.get(key) : _this[key]; });\r\n    }),\r\n    // for symbols\r\n    /*Pairs_Sym() {\r\n    };*/\r\n    Sym: function (symbolName) {\r\n        var symbols = Object.getOwnPropertySymbols(this);\r\n        var symbol = symbols.find(function (a) { return a.toString() == \"Symbol(\" + symbolName + \")\"; });\r\n        return this[symbol];\r\n    },\r\n};\r\n//export const ObjectCE = WithFuncsStandalone(ObjectCEProxy.prototype);\r\n//export const ObjectCE = CreateProxyForClassExtensions(ObjectCEProxy);\r\nexports.ObjectCE = General_1.CreateProxyForClassExtensions(exports.ObjectCE_funcs);\r\nexports.ObjectCES = General_1.WithFuncsStandalone(exports.ObjectCE_funcs);\r\n//# sourceMappingURL=CE_Object.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar General_1 = require(\"../Utils/General\");\r\n/*\r\nThere are two ways to make a class-extension<or>standalone-functions system:\r\n1) Define the functions as class methods, and create a typescript extractor that creates versions of those methods, with an added first parameter that is used as the this-arg.\r\n2) Define them as standalone functions, and create a typescript extractor that creates versions of those methods, with a real this-arg that is extracted and supplied as the first parameter.\r\nThe \"Extract\" function below shows how to do approach 2. (we currently instead use approach 1, since I use them as class methods more frequently, and only the source approach allows function overloads)\r\n*/\r\n/*function Test1(a, b: string, c) {}\r\n\r\n/*type ExtractArgs2Plus<T> = FirstParameterType<T>;\r\nexport function Extract(func: (...args: any[])=>any) {\r\n    return (...args: Parameters<typeof func>)=>any;\r\n}\r\nexport const Test1_Next = Extract(Test1);\r\ntype FirstParameterType<T> = T extends (a: infer U, ...args: infer T2) => any ? T2 : unknown;*#/\r\n\r\ntype Extract_Type<T> =\r\n        //T extends (...args)=>any ? (thisArg: Object, ...args: Parameters<T>)=>ReturnType<T> :\r\n        T extends (firstParam: infer FirstParam, ...args: infer RestOfParams)=>any ? (...args: RestOfParams)=>ReturnType<T> :\r\n        T;\r\nexport function Extract<T>(source: T): Extract_Type<T> {\r\n    return null as any;\r\n}\r\n\r\nconst Test2 = Extract(Test1);\r\nexport type exports1 = {Test2: typeof Test2};\r\n\r\ndeclare global {\r\n    interface String extends exports1 {}\r\n}\r\n\"\".Test2(\"\", 5);*/\r\nexports.FunctionCE_funcs = {\r\n    GetName: function () {\r\n        //return this.name_fake || this.name || this.toString().match(/^function\\s*([^\\s(]+)/)[1];\r\n        return this[\"name_fake\"] || this.name || (this.toString().match(/^function\\s*([^\\s(]+)/) || [])[1];\r\n    },\r\n    SetName: function (val) {\r\n        this[\"name_fake\"] = name;\r\n        return this;\r\n    },\r\n    AddTag: function (tag) {\r\n        if (this[\"tags\"] == null)\r\n            this[\"tags\"] = [];\r\n        this[\"tags\"].push(tag);\r\n        return this;\r\n    },\r\n    /*Function.prototype._AddFunction_Inline = function AddTags(/*o:*#/ tags___) { // (already implemented in VDF.js file)\r\n        if (this.tags == null)\r\n            this.tags = [];\r\n        for (var i in arguments)\r\n            this.tags.push(arguments[i]);\r\n        return this;\r\n    };*/\r\n    /*function AddTags() {\r\n        var tags = V.Slice(arguments, 0, arguments.length - 1);\r\n        var func = V.Slice(arguments).Last();\r\n        func.AddTags.apply(func, tags);\r\n    };*/\r\n    GetTags: function (type) {\r\n        return (this[\"tags\"] || []).Where(function (a) { return type == null || a instanceof type; });\r\n    },\r\n    //AsStr(...args) { return require(\"../../V/V\").Multiline(this, ...args); };\r\n    //AsStr(useExtraPreprocessing) { return require(\"../../V/V\").Multiline(this, useExtraPreprocessing); };\r\n    RunThenReturn: function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        this.apply(null, args);\r\n        return this;\r\n    },\r\n};\r\nexports.FunctionCE = General_1.CreateProxyForClassExtensions(exports.FunctionCE_funcs);\r\nexports.FunctionCES = General_1.WithFuncsStandalone(exports.FunctionCE_funcs);\r\nfunction isLeapYear(year) {\r\n    return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0));\r\n}\r\nfunction getDaysInMonth(year, month) {\r\n    return [31, (isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];\r\n}\r\nexports.DateCE_funcs = {\r\n    get MonthDate() {\r\n        return new Date(this.getFullYear(), this.getMonth(), 1);\r\n    },\r\n    IsLeapYear: function () {\r\n        return isLeapYear(this.getFullYear());\r\n    },\r\n    GetDaysInMonth: function () {\r\n        return getDaysInMonth(this.getFullYear(), this.getMonth());\r\n    },\r\n    AddMonths: function (value) {\r\n        var n = this.getDate();\r\n        this.setDate(1);\r\n        this.setMonth(this.getMonth() + value);\r\n        this.setDate(Math.min(n, exports.DateCE(this).GetDaysInMonth()));\r\n        return this;\r\n    },\r\n    Clone: function () {\r\n        return new Date(this.getTime());\r\n    },\r\n};\r\nexports.DateCE = General_1.CreateProxyForClassExtensions(exports.DateCE_funcs);\r\nexports.DateCES = General_1.WithFuncsStandalone(exports.DateCE_funcs);\r\n/*export class ErrorCEProxy {\r\n    get Stack() {\r\n        // this causes the full stack-trace to be attached to the Error object (in Chrome)\r\n        if ((Error as any).captureStackTrace) {\r\n            //(Error as any).captureStackTrace(instance, GetStackTraceStr);\r\n            (Error as any).captureStackTrace(this);\r\n        }\r\n        return this.stack;\r\n    }\r\n}\r\nexport const ErrorCE = CreateProxyForClassExtensions(ErrorCEProxy);*/ \r\n//# sourceMappingURL=CE_Others.js.map","\"use strict\";\r\nvar __values = (this && this.__values) || function(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar CE_Array_1 = require(\"./CE_Array\");\r\nvar General_1 = require(\"../Utils/General\");\r\nexports.StringCE_funcs = {\r\n    TrimStart: function () {\r\n        // fix for if called by VDF (which has a different signature)\r\n        //if (arguments[0] instanceof Array) chars = arguments[0];\r\n        var chars = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            chars[_i] = arguments[_i];\r\n        }\r\n        for (var iOfFirstToKeep = 0; iOfFirstToKeep < this.length && CE_Array_1.ArrayCE(chars).Contains(this[iOfFirstToKeep]); iOfFirstToKeep++)\r\n            ;\r\n        return this.slice(iOfFirstToKeep, this.length);\r\n    },\r\n    TrimEnd: function () {\r\n        var chars = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            chars[_i] = arguments[_i];\r\n        }\r\n        for (var iOfLastToKeep = this.length - 1; iOfLastToKeep >= 0 && CE_Array_1.ArrayCE(chars).Contains(this[iOfLastToKeep]); iOfLastToKeep--)\r\n            ;\r\n        return this.substr(0, iOfLastToKeep + 1);\r\n    },\r\n    Contains: function (str, startIndex) {\r\n        return this.indexOf(str, startIndex) !== -1;\r\n    },\r\n    hashCode: function () {\r\n        var hash = 0;\r\n        for (var i = 0; i < this.length; i++) {\r\n            var char = this.charCodeAt(i);\r\n            hash = ((hash << 5) - hash) + char;\r\n            hash |= 0; // convert to 32-bit integer\r\n        }\r\n        return hash;\r\n    },\r\n    Matches: function (strOrRegex) {\r\n        if (typeof strOrRegex == \"string\") {\r\n            var str = strOrRegex;\r\n            var result_1 = [];\r\n            var lastMatchIndex = -1;\r\n            while (true) {\r\n                var matchIndex = this.indexOf(str, lastMatchIndex + 1);\r\n                if (matchIndex == -1)\r\n                    break; // if another match was not found\r\n                result_1.push({ index: matchIndex });\r\n                lastMatchIndex = matchIndex;\r\n            }\r\n            return result_1;\r\n        }\r\n        var regex = strOrRegex;\r\n        if (!regex.global) {\r\n            throw new Error(\"Regex must have the 'g' flag added. (otherwise an infinite loop occurs)\"); // todo: make alternate solution, like setting flag ourselves\r\n        }\r\n        var result = [];\r\n        var match;\r\n        while (match = regex.exec(this)) {\r\n            result.push(match);\r\n        }\r\n        return result;\r\n    },\r\n    /*matches_group(regex, /*o:*#/ groupIndex) {\r\n        if (!regex.global)\r\n            throw new Error(\"Regex must have the 'g' flag added. (otherwise an infinite loop occurs)\");\r\n\r\n        groupIndex = groupIndex || 0; // default to the first capturing group\r\n        var matches = [];\r\n        var match;\r\n        while (match = regex.exec(this))\r\n            matches.push(match[groupIndex]);\r\n        return matches;\r\n    }*/\r\n    /** indexX is 0-based */\r\n    IndexOf_X: function (str, indexX) {\r\n        var currentPos = -1;\r\n        for (var i = 0; i <= indexX; i++) {\r\n            var subIndex = this.indexOf(str, currentPos + 1);\r\n            if (subIndex == -1)\r\n                return -1; // no such xth index\r\n            currentPos = subIndex;\r\n        }\r\n        return currentPos;\r\n    },\r\n    /** indexFromLastX is 0-based */\r\n    IndexOf_XFromLast: function (str, indexFromLastX) {\r\n        var currentPos = (this.length - str.length) + 1; // index just after the last-index-where-match-could-occur\r\n        for (var i = 0; i <= indexFromLastX; i++) {\r\n            var subIndex = this.lastIndexOf(str, currentPos - 1);\r\n            if (subIndex == -1)\r\n                return -1; // no such xth index\r\n            currentPos = subIndex;\r\n        }\r\n        return currentPos;\r\n    },\r\n    IndexOfAny: function () {\r\n        var e_1, _a;\r\n        var strings = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            strings[_i] = arguments[_i];\r\n        }\r\n        var lowestIndex = -1;\r\n        try {\r\n            for (var strings_1 = __values(strings), strings_1_1 = strings_1.next(); !strings_1_1.done; strings_1_1 = strings_1.next()) {\r\n                var str = strings_1_1.value;\r\n                var indexOfChar = this.indexOf(str);\r\n                if (indexOfChar != -1 && (indexOfChar < lowestIndex || lowestIndex == -1))\r\n                    lowestIndex = indexOfChar;\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (strings_1_1 && !strings_1_1.done && (_a = strings_1.return)) _a.call(strings_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        return lowestIndex;\r\n    },\r\n    LastIndexOfAny: function () {\r\n        var e_2, _a;\r\n        var strings = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            strings[_i] = arguments[_i];\r\n        }\r\n        var highestIndex = -1;\r\n        try {\r\n            for (var strings_2 = __values(strings), strings_2_1 = strings_2.next(); !strings_2_1.done; strings_2_1 = strings_2.next()) {\r\n                var str = strings_2_1.value;\r\n                var indexOfChar = this.lastIndexOf(str);\r\n                if (indexOfChar > highestIndex)\r\n                    highestIndex = indexOfChar;\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (strings_2_1 && !strings_2_1.done && (_a = strings_2.return)) _a.call(strings_2);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        return highestIndex;\r\n    },\r\n    StartsWithAny: function () {\r\n        var _this = this;\r\n        var strings = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            strings[_i] = arguments[_i];\r\n        }\r\n        return CE_Array_1.ArrayCE(strings).Any(function (str) { return _this.startsWith(str); });\r\n    },\r\n    EndsWithAny: function () {\r\n        var _this = this;\r\n        var strings = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            strings[_i] = arguments[_i];\r\n        }\r\n        return CE_Array_1.ArrayCE(strings).Any(function (str) { return _this.endsWith(str); });\r\n    },\r\n    ContainsAny: function () {\r\n        var _this = this;\r\n        var strings = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            strings[_i] = arguments[_i];\r\n        }\r\n        return CE_Array_1.ArrayCE(strings).Any(function (str) { return exports.StringCE(_this).Contains(str); });\r\n    },\r\n    /** Separator-strings must be escaped. (they're passed into a regular-expression) */\r\n    SplitByAny: function () {\r\n        var separators = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            separators[_i] = arguments[_i];\r\n        }\r\n        /*var splitStr = \"/\";\r\n        for (let sep of separators)\r\n            splitStr += (splitStr.length > 1 ? \"|\" : \"\") + sep;\r\n        splitStr += \"/\";\r\n        return this.split(splitStr);*/\r\n        var regex = new RegExp(separators.map(function (a) { return \"\\\\\" + a; }).join(\"|\"));\r\n        return this.split(regex);\r\n    },\r\n    SplitAt: function (index, includeCharAtIndex) {\r\n        if (includeCharAtIndex === void 0) { includeCharAtIndex = false; }\r\n        if (index == -1) // if no split-index, pass source-string as part2 (makes more sense for paths and such)\r\n            return [\"\", this];\r\n        var part1 = this.substr(0, index);\r\n        var part2 = includeCharAtIndex ? this.substr(index) : this.substr(index + 1);\r\n        return [part1, part2];\r\n    },\r\n    Splice: function (index, removeCount, insert) {\r\n        return this.slice(0, index) + insert + this.slice(index + Math.abs(removeCount));\r\n    },\r\n    Indent: function (indentCount) {\r\n        var indentStr = \"\\t\".repeat(indentCount);\r\n        return this.replace(/^|(\\n)/g, \"$1\" + indentStr);\r\n    },\r\n    KeepAtMost: function (maxLength, moreMarkerStr) {\r\n        if (moreMarkerStr === void 0) { moreMarkerStr = \"...\"; }\r\n        if (this.length <= maxLength)\r\n            return this;\r\n        return this.substr(0, maxLength - moreMarkerStr.length) + moreMarkerStr;\r\n    },\r\n    // for firebase entry keys\r\n    /*interface String { readonly KeyToInt: number; }\r\n    String.prototype._AddGetter_Inline = function KeyToInt() {\r\n        return parseInt((this as string).substr(1));\r\n    }\r\n    interface Number { readonly IntToKey: string; }\r\n    Number.prototype._AddGetter_Inline = function IntToKey() {\r\n        return \"e\" + this;\r\n    }*/\r\n    /** Creates a function from \"func\", setting its name to the \"this\" string's value. */\r\n    Func: function (func) {\r\n        func.SetName(this);\r\n        return func;\r\n    },\r\n    // special; creates a function with the given name, but also caches it per caller-line,\r\n    //   so every call from that line returns the same function instance\r\n    // REMOVED, because: we need to create new funcs to capture new closure values\r\n    /*var oneFuncCache = {};\r\n    OneFunc(func) {\r\n        var funcName = this;\r\n        var callerLineStr = new Error().stack.split(\"\\n\")[3];\r\n        var funcKey = `${funcName}@${callerLineStr}`;\r\n        if (oneFuncCache[funcKey] == null) {\r\n            func.SetName(this);\r\n            //func.cached = true;\r\n            oneFuncCache[funcKey] = func;\r\n        }\r\n        return oneFuncCache[funcKey];\r\n    }*/\r\n    /**\r\n     * Reformats a multi-line string to represent the actual intended \"block\" of text.\r\n     * @param desiredIndent How much to indent each line. (after removal of the first-non-empty-line indent-length from each of them)\r\n     * @param removeLineStr A special string which, if found in a line, will cause that line to be removed from the result.\r\n     */\r\n    AsMultiline: function (desiredIndent, removeLineStr) {\r\n        if (desiredIndent === void 0) { desiredIndent = null; }\r\n        if (removeLineStr === void 0) { removeLineStr = \"@RL\"; }\r\n        var result = this.substring(this.indexOf(\"\\n\") + 1, this.lastIndexOf(\"\\n\"));\r\n        if (desiredIndent != null) {\r\n            var firstLineIndent_1 = (result.match(/^\\t+/) || [\"\"])[0].length;\r\n            if (firstLineIndent_1) {\r\n                var lines = result.split(\"\\n\");\r\n                // remove X tabs from start of each line (where X is firstLineIndent)\r\n                lines = lines.map(function (line) { return line.replace(new RegExp(\"^\\t{0,\" + firstLineIndent_1 + \"}\"), \"\"); });\r\n                // add the desired indent\r\n                lines = lines.map(function (line) { return \"\\t\".repeat(desiredIndent) + line; });\r\n                // filter out lines with the special remove-line string\r\n                lines = lines.filter(function (a) { return !a.includes(removeLineStr); });\r\n                result = lines.join(\"\\n\");\r\n            }\r\n        }\r\n        return result;\r\n    },\r\n    Substring: function (start, end) {\r\n        if (end < 0)\r\n            end = this.length + end;\r\n        return this.substring(start, end);\r\n    },\r\n    ToInt: function () { return parseInt(Number(this) + \"\"); },\r\n    ToFloat: function () { return Number(this); },\r\n};\r\nexports.StringCE = General_1.CreateProxyForClassExtensions(exports.StringCE_funcs);\r\nexports.StringCES = General_1.WithFuncsStandalone(exports.StringCE_funcs);\r\n//# sourceMappingURL=CE_String.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar JSVE = /** @class */ (function () {\r\n    function JSVE() {\r\n    }\r\n    JSVE.logFunc = console.log;\r\n    return JSVE;\r\n}());\r\nexports.JSVE = JSVE;\r\n//# sourceMappingURL=JSVE.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar General_1 = require(\"./General\");\r\nvar JSVE_1 = require(\"../JSVE\");\r\nfunction Assert(condition, messageOrMessageFunc) {\r\n    if (condition)\r\n        return;\r\n    var message = messageOrMessageFunc instanceof Function ? messageOrMessageFunc() : messageOrMessageFunc;\r\n    JSVE_1.JSVE.logFunc(\"Assert failed) \" + message + \"\\n\\nStackTrace) \" + General_1.GetStackTraceStr());\r\n    console.error(\"Assert failed) \" + message);\r\n    var skipError = false; // add flag which you can use to skip the error, when paused in debugger\r\n    debugger;\r\n    if (!skipError)\r\n        throw new Error(\"Assert failed) \" + message);\r\n}\r\nexports.Assert = Assert;\r\nfunction AssertWarn(condition, messageOrMessageFunc) {\r\n    if (condition)\r\n        return;\r\n    var message = messageOrMessageFunc instanceof Function ? messageOrMessageFunc() : messageOrMessageFunc;\r\n    console.warn(\"Assert-warn failed) \" + message + \"\\n\\nStackTrace) \" + General_1.GetStackTraceStr());\r\n}\r\nexports.AssertWarn = AssertWarn;\r\n// this version throws an error with only the provided message -- for ones the user may well see, and which don't need the stack (or \"Assert failed) \" text)\r\n/*g.Extend({AssertSimple});\r\nexport function AssertSimple(condition, messageOrMessageFunc?: string | Function) {\r\n    if (condition) return;\r\n\r\n    var message = (messageOrMessageFunc as any) instanceof Function ? (messageOrMessageFunc as any)() : messageOrMessageFunc;\r\n\r\n    Log(`Assert failed) ${message}\\n\\nStackTrace) ${V.GetStackTraceStr()}`);\r\n    console.error(\"Assert failed) \" + message);\r\n    debugger;\r\n    throw new Error(message);\r\n}*/\r\nvar A = /** @class */ (function () {\r\n    function A() {\r\n    }\r\n    Object.defineProperty(A, \"NonNull_\", {\r\n        get: function () {\r\n            return function (value) {\r\n                Assert(value != null, function () { return \"Value cannot be null. (provided value: \" + value + \")\"; });\r\n                return value;\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(A, \"NonNull\", {\r\n        set: function (value) {\r\n            A.NonNull_(value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    A.NotEqualTo = function (val1) {\r\n        return new A_NotEqualTo_Wrapper(val1);\r\n    };\r\n    return A;\r\n}());\r\nexports.A = A;\r\nvar A_NotEqualTo_Wrapper = /** @class */ (function () {\r\n    function A_NotEqualTo_Wrapper(val1) {\r\n        this.val1 = val1;\r\n    }\r\n    Object.defineProperty(A_NotEqualTo_Wrapper.prototype, \"a\", {\r\n        set: function (val2) { Assert(val2 != this.val1); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return A_NotEqualTo_Wrapper;\r\n}());\r\nexports.A_NotEqualTo_Wrapper = A_NotEqualTo_Wrapper;\r\nvar A_OfType_Wrapper = /** @class */ (function () {\r\n    function A_OfType_Wrapper(type) {\r\n        this.type = type;\r\n    }\r\n    Object.defineProperty(A_OfType_Wrapper.prototype, \"a\", {\r\n        set: function (val) { Assert(val != null && val.GetType().IsDerivedFrom(this.type)); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return A_OfType_Wrapper;\r\n}());\r\nexports.A_OfType_Wrapper = A_OfType_Wrapper;\r\n//# sourceMappingURL=Assert.js.map","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nvar __spread = (this && this.__spread) || function () {\r\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n};\r\nvar __values = (this && this.__values) || function(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Timers_1 = require(\"./Timers\");\r\nvar __1 = require(\"..\");\r\nvar General_1 = require(\"./General\");\r\nvar BridgeMessage = /** @class */ (function () {\r\n    function BridgeMessage(initialData) {\r\n        __1.ObjectCE(this).Extend(initialData);\r\n    }\r\n    return BridgeMessage;\r\n}());\r\nexports.BridgeMessage = BridgeMessage;\r\n/*export class Bridge_Options {\r\n    receiveChannelMessageFunc_adder: (receiveDataFunc: (channelMessage: string | Object)=>any)=>any;\r\n    receiveChannelMessageFunc_addImmediately? = true;\r\n    sendChannelMessageFunc: (channelMessage: string | Object)=>any;\r\n    channel_wrapBridgeMessage? = true;\r\n    channel_stringifyChannelMessageObj? = true;\r\n    channel_safeCallbacks? = false;\r\n}*/\r\nvar Bridge = /** @class */ (function () {\r\n    /** Don't worry about having to discard some calls before receiveTextFunc receives it. We automatically discard entries that aren't valid bridge-messages. */\r\n    function Bridge(options) {\r\n        /** Useful to ensure we ignore non-jsve-bridge messages. (the channel might be used by other systems as well) */\r\n        this.channel_wrapBridgeMessage = true;\r\n        /** Needed if the channel only supports strings being sent/received. */\r\n        this.channel_stringifyChannelMessageObj = true;\r\n        /** Needed if the channel has >2 members; makes-so call-ids are random-numbers, and are filtered by each member to just the ones it knows it initiated. */\r\n        this.channel_safeCallbacks = false;\r\n        // for receiving function-calls (and callbacks) from external bridge\r\n        // ==========\r\n        this.functions = {};\r\n        this.ignoreMissingFunctions = false;\r\n        // callback system (for when passing a function as an argument, or awaiting the result of a remote call)\r\n        // ==========\r\n        this.lastCallbackID = -1;\r\n        this.callbacks = {};\r\n        __1.ObjectCE(this).Extend(__1.ObjectCE(options).Excluding(\"receiveChannelMessageFunc_addImmediately\"));\r\n        if (options.receiveChannelMessageFunc_addImmediately != false)\r\n            this.SetUpReceiver();\r\n    }\r\n    // low level data-transfer\r\n    // ==========\r\n    Bridge.prototype.SetUpReceiver = function () {\r\n        var _this = this;\r\n        // add our own receive-text-func right now\r\n        this.receiveChannelMessageFunc = function (channelMessage) {\r\n            var channelMessageObj;\r\n            if (_this.channel_stringifyChannelMessageObj && __1.IsString(channelMessage))\r\n                channelMessageObj = Timers_1.TryCall(function () { return __1.FromJSON(channelMessage); }) || {};\r\n            if (!_this.channel_stringifyChannelMessageObj && __1.IsObject(channelMessage))\r\n                channelMessageObj = channelMessage;\r\n            var bridgeMessage = _this.channel_wrapBridgeMessage ? channelMessageObj && channelMessageObj[\"JSVE_Bridge_message\"] : channelMessageObj;\r\n            if (!__1.IsObject(bridgeMessage))\r\n                return;\r\n            _this.DeserializeFuncsIn(bridgeMessage);\r\n            if (bridgeMessage.callFunction_name)\r\n                _this.OnReceiveFunctionCall(bridgeMessage);\r\n            if (bridgeMessage.callCallback_id != null)\r\n                _this.OnReceiveCallback(bridgeMessage);\r\n        };\r\n        this.receiveChannelMessageFunc_adder(this.receiveChannelMessageFunc);\r\n    };\r\n    Bridge.prototype.SendBridgeMessage = function (bridgeMessage) {\r\n        this.SerializeFuncsIn(bridgeMessage);\r\n        var channelMessageObj = this.channel_wrapBridgeMessage ? { JSVE_Bridge_message: bridgeMessage } : bridgeMessage;\r\n        var channelMessage = this.channel_stringifyChannelMessageObj ? __1.ToJSON(channelMessageObj) : channelMessageObj;\r\n        this.sendChannelMessageFunc(channelMessage);\r\n    };\r\n    Bridge.prototype.RegisterFunction = function (name, func) {\r\n        if (this.functions[name])\r\n            throw new Error(\"Cannot register the same function-name twice: \\\"\" + name + \"\\\"\");\r\n        this.functions[name] = func;\r\n    };\r\n    Bridge.prototype.UnregisterFunction = function (name) {\r\n        delete this.functions[name];\r\n    };\r\n    Bridge.prototype.OnReceiveFunctionCall = function (bridgeMessage) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var result;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.Local_CallFunc.apply(this, __spread([bridgeMessage.callFunction_name], bridgeMessage.callFunction_args))];\r\n                    case 1:\r\n                        result = _a.sent();\r\n                        this.CallCallback(bridgeMessage.callFunction_callbackID, result);\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    // we use async/await here, to support waiting for the registered function if it happens to be async (if it isn't, that's fine -- the async/await doesn't hurt anything)\r\n    Bridge.prototype.Local_CallFunc = function (funcName) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var func;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        func = this.functions[funcName];\r\n                        if (this.ignoreMissingFunctions && func == null)\r\n                            return [2 /*return*/];\r\n                        __1.Assert(func, \"Cannot find function \\\"\" + funcName + \"\\\".\");\r\n                        return [4 /*yield*/, func.apply(void 0, __spread(args))];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Bridge.prototype.OnReceiveCallback = function (bridgeMessage) {\r\n        this.Local_CallCallback(bridgeMessage.callCallback_id, bridgeMessage.callCallback_args);\r\n    };\r\n    Bridge.prototype.Local_CallCallback = function (callbackID, callbackArgs) {\r\n        var callback = this.callbacks[callbackID];\r\n        if (callback == null) {\r\n            if (this.channel_safeCallbacks)\r\n                return;\r\n            __1.Assert(false, \"Cannot find callback with id \" + callbackID + \"!\");\r\n        }\r\n        callback.apply(void 0, __spread(callbackArgs));\r\n    };\r\n    Bridge.prototype.RegisterCallback = function (callback) {\r\n        var callbackID = this.channel_safeCallbacks ? Math.random() : this.lastCallbackID + 1;\r\n        this.lastCallbackID = callbackID;\r\n        this.callbacks[callbackID] = callback;\r\n        return callbackID;\r\n    };\r\n    // technically, this just prepares the functions in the tree for serialization (by setting a toJSON key, which JSON.stringify uses)\r\n    Bridge.prototype.SerializeFuncsIn = function (argTree) {\r\n        var e_1, _a;\r\n        var nodes = General_1.GetTreeNodesInObjTree(argTree);\r\n        var _loop_1 = function (node) {\r\n            if (__1.IsFunction(node.Value)) {\r\n                var callbackID_1 = this_1.RegisterCallback(node.Value);\r\n                node.Value.toJSON = function () { return ({ serializedFunc_callbackID: callbackID_1 }); };\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        try {\r\n            for (var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {\r\n                var node = nodes_1_1.value;\r\n                _loop_1(node);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    };\r\n    Bridge.prototype.DeserializeFuncsIn = function (argTree) {\r\n        var e_2, _a;\r\n        var _this = this;\r\n        var nodes = General_1.GetTreeNodesInObjTree(argTree);\r\n        var _loop_2 = function (node) {\r\n            if (node.Value != null && node.Value.serializedFunc_callbackID != null) {\r\n                var callbackID_2 = node.Value.serializedFunc_callbackID;\r\n                var proxyFunc = function () {\r\n                    var args = [];\r\n                    for (var _i = 0; _i < arguments.length; _i++) {\r\n                        args[_i] = arguments[_i];\r\n                    }\r\n                    _this.CallCallback.apply(_this, __spread([callbackID_2], args));\r\n                };\r\n                node.Value = proxyFunc;\r\n            }\r\n        };\r\n        try {\r\n            for (var nodes_2 = __values(nodes), nodes_2_1 = nodes_2.next(); !nodes_2_1.done; nodes_2_1 = nodes_2.next()) {\r\n                var node = nodes_2_1.value;\r\n                _loop_2(node);\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (nodes_2_1 && !nodes_2_1.done && (_a = nodes_2.return)) _a.call(nodes_2);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n    };\r\n    // for sending function-calls to external bridge\r\n    // ==========\r\n    Bridge.prototype.Call = function (funcName) {\r\n        var _this = this;\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        return new Promise(function (resolve, reject) {\r\n            var awaitReturn_callbackID = _this.RegisterCallback(resolve);\r\n            var bridgeMessage = new BridgeMessage({ callFunction_callbackID: awaitReturn_callbackID, callFunction_name: funcName, callFunction_args: args });\r\n            _this.SendBridgeMessage(bridgeMessage);\r\n        });\r\n    };\r\n    Bridge.prototype.CallCallback = function (callbackID) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var bridgeMessage = new BridgeMessage({ callCallback_id: callbackID, callCallback_args: args });\r\n        this.SendBridgeMessage(bridgeMessage);\r\n    };\r\n    return Bridge;\r\n}());\r\nexports.Bridge = Bridge;\r\n//# sourceMappingURL=Bridge.js.map","\"use strict\";\r\nvar __values = (this && this.__values) || function(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar General_1 = require(\"./General\");\r\nfunction GetPropsChanged(oldObj, newObj, returnNullIfSame, useJSONCompare) {\r\n    var e_1, _a;\r\n    if (returnNullIfSame === void 0) { returnNullIfSame = true; }\r\n    if (useJSONCompare === void 0) { useJSONCompare = false; }\r\n    oldObj = oldObj || {}, newObj = newObj || {};\r\n    var keys = oldObj.VKeys().concat(newObj.VKeys()).Distinct();\r\n    var result = [];\r\n    try {\r\n        for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\r\n            var key = keys_1_1.value;\r\n            var newVal_forComparison = useJSONCompare ? General_1.ToJSON(newObj[key]) : newObj[key];\r\n            var oldVal_forComparison = useJSONCompare ? General_1.ToJSON(oldObj[key]) : oldObj[key];\r\n            if (newVal_forComparison !== oldVal_forComparison) {\r\n                result.push({ key: key, oldVal: oldObj[key], newVal: newObj[key] });\r\n            }\r\n        }\r\n    }\r\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n    finally {\r\n        try {\r\n            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);\r\n        }\r\n        finally { if (e_1) throw e_1.error; }\r\n    }\r\n    if (result.length == 0 && returnNullIfSame)\r\n        return null;\r\n    return result;\r\n}\r\nexports.GetPropsChanged = GetPropsChanged;\r\n/*export function GetUpdates(oldData, newData, useNullInsteadOfUndefined = true) {\r\n    const result = {};\r\n    for (const key of oldData.VKeys(true).concat(newData.VKeys(true))) {\r\n        if (newData[key] !== oldData[key]) {\r\n            result[key] = newData[key];\r\n            if (newData[key] === undefined && useNullInsteadOfUndefined) {\r\n                result[key] = null;\r\n            }\r\n        }\r\n    }\r\n    return RemoveHelpers(result);\r\n}*/ \r\n//# sourceMappingURL=Changes.js.map","\"use strict\";\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar __values = (this && this.__values) || function(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n};\r\nvar __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nvar __spread = (this && this.__spread) || function () {\r\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Types_1 = require(\"./Types\");\r\nvar __1 = require(\"..\");\r\nvar g = typeof window == \"object\" ? window : global;\r\nif (Number.MIN_SAFE_INTEGER == null) {\r\n    Number.MIN_SAFE_INTEGER = -9007199254740991;\r\n}\r\nif (Number.MAX_SAFE_INTEGER == null) {\r\n    Number.MAX_SAFE_INTEGER = 9007199254740991;\r\n}\r\ng[\"G\"] = G;\r\nfunction G() {\r\n    var e_1, _a;\r\n    var globalHolders = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        globalHolders[_i] = arguments[_i];\r\n    }\r\n    try {\r\n        for (var globalHolders_1 = __values(globalHolders), globalHolders_1_1 = globalHolders_1.next(); !globalHolders_1_1.done; globalHolders_1_1 = globalHolders_1.next()) {\r\n            var globalHolder = globalHolders_1_1.value;\r\n            Object.assign(g, globalHolder);\r\n        }\r\n    }\r\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n    finally {\r\n        try {\r\n            if (globalHolders_1_1 && !globalHolders_1_1.done && (_a = globalHolders_1.return)) _a.call(globalHolders_1);\r\n        }\r\n        finally { if (e_1) throw e_1.error; }\r\n    }\r\n}\r\nfunction DoNothing() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n}\r\nexports.DoNothing = DoNothing;\r\nfunction DN() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n}\r\nexports.DN = DN;\r\n//var quickIncrementValues = {};\r\n//export function QuickIncrement(name = new Error().stack.split(\"\\n\")[2]) { // this doesn't always work, fsr\r\nfunction QuickIncrement(name) {\r\n    if (name === void 0) { name = \"default\"; }\r\n    QuickIncrement[\"values\"][name] = (QuickIncrement[\"values\"][name] | 0) + 1;\r\n    return QuickIncrement[\"values\"][name];\r\n}\r\nexports.QuickIncrement = QuickIncrement;\r\nQuickIncrement[\"values\"] = [];\r\nexports.emptyObj = {};\r\nexports.eo = exports.emptyObj; // used for (maybeNullVar || eo).prop;\r\nexports.emptyArray = [];\r\nexports.emptyArray_forLoading = [];\r\nfunction E(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20) {\r\n    var e_2, _a;\r\n    var result = {};\r\n    try {\r\n        for (var _b = __values(Array.from(arguments)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n            var extend = _c.value;\r\n            Object.assign(result, extend);\r\n        }\r\n    }\r\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n    finally {\r\n        try {\r\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n        }\r\n        finally { if (e_2) throw e_2.error; }\r\n    }\r\n    // if result is empty, return the same empty-obj each time so it doesn't trigger react-js rerenders\r\n    if (exports.emptyObj && result.VKeys().length == 0) {\r\n        return exports.emptyObj;\r\n    }\r\n    return result;\r\n    //return StyleSheet.create(result);\r\n}\r\nexports.E = E;\r\nfunction WrapWithGo(func) {\r\n    Object.defineProperty(func, \"Go\", {\r\n        /*set: arg1=>{\r\n            func(arg1);\r\n        },*/\r\n        set: func,\r\n    });\r\n    return func;\r\n}\r\nexports.WrapWithGo = WrapWithGo;\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\n// Performs equality by iterating through keys on an object and returning false when any key has values which are not strictly equal between the arguments.\r\n// Returns true when the values of all keys are strictly equal.\r\nfunction ShallowEquals(objA, objB) {\r\n    if (Object.is(objA, objB))\r\n        return true;\r\n    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null)\r\n        return false;\r\n    var keysA = Object.keys(objA);\r\n    var keysB = Object.keys(objB);\r\n    if (keysA.length !== keysB.length)\r\n        return false;\r\n    // test for A's keys different from B\r\n    for (var i = 0; i < keysA.length; i++) {\r\n        if (!hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.ShallowEquals = ShallowEquals;\r\nfunction ShallowChanged(objA, objB) {\r\n    return !ShallowEquals(objA, objB);\r\n}\r\nexports.ShallowChanged = ShallowChanged;\r\nfunction CopyText(text) {\r\n    /*\r\n    //var note = $(`<input type=\"text\">`).appendTo(\"body\");\r\n    var note = document.createElement(\"textarea\");\r\n    document.body.appendChild(note);\r\n    note.innerHTML = text;\r\n\r\n    note.focus();\r\n    var range = document.createRange();\r\n    range.setStart(note, 0);\r\n    range.setEnd(note, 1);\r\n    //range.setEnd(note2, 0);\r\n\r\n    //range.setEnd(e(\"notesEnder\"), 0); // adds one extra new-line; that's okay, right?\r\n    var sel = window.getSelection();\r\n    sel.removeAllRanges();\r\n    sel.addRange(range);\r\n\r\n    document.execCommand(\"copy\");*/\r\n    document.oncopy = function (event) {\r\n        event.clipboardData.setData(\"text/plain\", text);\r\n        event.preventDefault();\r\n        document.oncopy = null;\r\n    };\r\n    document.execCommand(\"copy\", false, null);\r\n}\r\nexports.CopyText = CopyText;\r\n// methods: serialization\r\n// ==========\r\n// object-Json\r\nfunction FromJSON(json) { return JSON.parse(json); }\r\nexports.FromJSON = FromJSON;\r\n/*declare global { function ToJSON(obj, ...excludePropNames): string; } g.Extend({ToJSON});\r\nexport function ToJSON(obj, ...excludePropNames): string {\r\n    try {\r\n        if (arguments.length > 1) {\r\n            return JSON.stringify(obj, function(key, value) {\r\n                if (excludePropNames.Contains(key))\r\n                    return;\r\n                return value;\r\n            });\r\n        }\r\n        return JSON.stringify(obj);\r\n    }\r\n    catch (ex) {\r\n        if (ex.toString() == \"TypeError: Converting circular structure to JSON\")\r\n            return ToJSON_Safe.apply(this, arguments);\r\n        throw ex;\r\n    }\r\n}*/\r\nfunction ToJSON(obj, replacerFunc, spacing) {\r\n    try {\r\n        return JSON.stringify(obj, replacerFunc, spacing);\r\n    }\r\n    catch (ex) {\r\n        if (ex.toString() == \"TypeError: Converting circular structure to JSON\")\r\n            return ToJSON_Safe.apply(this, arguments);\r\n        throw ex;\r\n    }\r\n}\r\nexports.ToJSON = ToJSON;\r\nvar ToJSON_WithSpaces_Options = /** @class */ (function () {\r\n    function ToJSON_WithSpaces_Options() {\r\n        this.insideObjectBraces = false;\r\n        this.insideArrayBrackets = false;\r\n        this.betweenPropsOrItems = true;\r\n        this.betweenPropNameAndValue = true;\r\n    }\r\n    return ToJSON_WithSpaces_Options;\r\n}());\r\nexports.ToJSON_WithSpaces_Options = ToJSON_WithSpaces_Options;\r\nfunction ToJSON_WithSpaces(obj, options) {\r\n    options = E(new ToJSON_WithSpaces_Options(), options);\r\n    var result = JSON.stringify(obj, null, 1); // stringify, with line-breaks and indents\r\n    result = result.replace(/^ +/gm, \" \"); // remove all but the first space for each line\r\n    result = result.replace(/\\n/g, \"\"); // remove line-breaks\r\n    if (!options.insideObjectBraces)\r\n        result = result.replace(/{ /g, \"{\").replace(/ }/g, \"}\");\r\n    if (!options.insideArrayBrackets)\r\n        result = result.replace(/\\[ /g, \"[\").replace(/ \\]/g, \"]\");\r\n    if (!options.betweenPropsOrItems)\r\n        result = result.replace(/, /g, \",\");\r\n    if (!options.betweenPropNameAndValue)\r\n        result = result.replace(/\": /g, \"\\\":\");\r\n    return result;\r\n}\r\nexports.ToJSON_WithSpaces = ToJSON_WithSpaces;\r\nfunction ToJSON_Safe(obj) {\r\n    var excludePropNames = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        excludePropNames[_i - 1] = arguments[_i];\r\n    }\r\n    var cache = [];\r\n    var foundDuplicates = false;\r\n    var result = JSON.stringify(obj, function (key, value) {\r\n        if (__1.ArrayCE(excludePropNames).Contains(key))\r\n            return;\r\n        if (typeof value == 'object' && value !== null) {\r\n            // if circular reference found, discard key\r\n            if (cache.indexOf(value) !== -1) {\r\n                foundDuplicates = true;\r\n                return;\r\n            }\r\n            cache.push(value); // store value in our cache\r\n        }\r\n        return value;\r\n    });\r\n    //cache = null; // enable garbage collection\r\n    if (foundDuplicates)\r\n        result = \"[was circular]\" + result;\r\n    return result;\r\n}\r\nexports.ToJSON_Safe = ToJSON_Safe;\r\nfunction ToJSON_Try() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    try {\r\n        return ToJSON.apply(this, args);\r\n    }\r\n    catch (ex) { }\r\n    return \"[converting to JSON failed]\";\r\n}\r\nexports.ToJSON_Try = ToJSON_Try;\r\nfunction Clone(obj, keepPrototype) {\r\n    if (keepPrototype === void 0) { keepPrototype = false; }\r\n    if (obj == null)\r\n        return obj;\r\n    var result = FromJSON(ToJSON(obj));\r\n    if (keepPrototype == true) {\r\n        Object.setPrototypeOf(result, Object.getPrototypeOf(obj));\r\n    }\r\n    return result;\r\n}\r\nexports.Clone = Clone;\r\nfunction CloneWithPrototypes(originalObject, keepCircularLinks) {\r\n    if (keepCircularLinks === void 0) { keepCircularLinks = false; }\r\n    if (originalObject == null)\r\n        return originalObject;\r\n    var copies = [{\r\n            source: originalObject,\r\n            target: Array.isArray(originalObject) ? [] : Object.create(Object.getPrototypeOf(originalObject)),\r\n        }];\r\n    var cloneObject = copies[0].target;\r\n    var sourceReferences = [originalObject];\r\n    var targetReferences = [cloneObject];\r\n    // First in, first out\r\n    var current;\r\n    while (current = copies.shift()) {\r\n        var keys = Object.getOwnPropertyNames(current.source);\r\n        for (var propertyIndex = 0; propertyIndex < keys.length; propertyIndex++) {\r\n            // Save the source's descriptor\r\n            var descriptor = Object.getOwnPropertyDescriptor(current.source, keys[propertyIndex]);\r\n            if (!descriptor.value || typeof descriptor.value !== 'object') {\r\n                Object.defineProperty(current.target, keys[propertyIndex], descriptor);\r\n                continue;\r\n            }\r\n            var nextSource = descriptor.value;\r\n            descriptor.value = Array.isArray(nextSource) ? [] : Object.create(Object.getPrototypeOf(nextSource));\r\n            if (keepCircularLinks) {\r\n                var indexOf = sourceReferences.indexOf(nextSource);\r\n                if (indexOf !== -1) {\r\n                    // The source is already referenced, just assign reference\r\n                    descriptor.value = targetReferences[indexOf];\r\n                    Object.defineProperty(current.target, keys[propertyIndex], descriptor);\r\n                    continue;\r\n                }\r\n                sourceReferences.push(nextSource);\r\n                targetReferences.push(descriptor.value);\r\n            }\r\n            Object.defineProperty(current.target, keys[propertyIndex], descriptor);\r\n            copies.push({ source: nextSource, target: descriptor.value });\r\n        }\r\n    }\r\n    return cloneObject;\r\n}\r\nexports.CloneWithPrototypes = CloneWithPrototypes;\r\n/*export function Range(min, max, step = 1, includeMax = true) {\r\n    var result: number[] = [];\r\n    for (let i = min; includeMax ? i <= max : i < max; i += step)\r\n        result.push(i);\r\n    return result;\r\n}*/\r\n/**\r\n * Gets an array of the numbers between min and max.\r\n * @param min\r\n * @param max\r\n * @param step (default: 1)\r\n * @param includeMax (default: true)\r\n * @param roundToStep (default: true)\r\n */\r\nfunction Range(min, max, step, includeMax, roundToStep) {\r\n    if (step === void 0) { step = 1; }\r\n    if (includeMax === void 0) { includeMax = true; }\r\n    if (roundToStep === void 0) { roundToStep = true; }\r\n    var result = [];\r\n    for (var i = min; includeMax ? i <= max : i < max; i = roundToStep ? __1.NumberCE(i + step).RoundTo(step) : i + step) {\r\n        result.push(i);\r\n    }\r\n    return result;\r\n}\r\nexports.Range = Range;\r\nfunction Global(target) {\r\n    //var name = (target as any).GetName();\r\n    var name = target[\"name_fake\"] || target.name || (target.toString().match(/^function\\s*([^\\s(]+)/) || [])[1];\r\n    //console.log(\"Globalizing: \" + name);\r\n    g[name] = target;\r\n}\r\nexports.Global = Global;\r\nvar IDProvider = /** @class */ (function () {\r\n    function IDProvider() {\r\n        this.lastID = -1;\r\n    }\r\n    IDProvider.prototype.GetID = function () {\r\n        return ++this.lastID;\r\n    };\r\n    return IDProvider;\r\n}());\r\nexports.IDProvider = IDProvider;\r\nexports.nl = \"\\n\";\r\nfunction AsObj(obj) {\r\n    if (typeof obj == \"object\")\r\n        return obj;\r\n    if (obj != null)\r\n        return obj.Props().ToMap(function (a) { return a.name; }, function (a) { return a.value; });\r\n    return {};\r\n}\r\nexports.AsObj = AsObj;\r\nfunction AsArray(args) { return Slice(args, 0); }\r\nexports.AsArray = AsArray;\r\n;\r\n//s.ToArray = function(args) { return s.Slice(args, 0); };\r\nfunction Slice(args, start, end) { return Array.prototype.slice.call(args, start != null ? start : 0, end); }\r\nexports.Slice = Slice;\r\n;\r\n/*static startupInfo = null;\r\nstatic startupInfoRequested = false;\r\nstatic postStartupInfoReceivedFuncs = [];\r\nstatic WaitForStartupInfoThenRun(func) {\r\n    if (startupInfo)\r\n        func(startupInfo);\r\n    else\r\n        V.postStartupInfoReceivedFuncs.push(func);\r\n}*/\r\n// example:\r\n// var multilineText = V.Multiline(function() {/*\r\n//\t\tText that...\r\n//\t\tspans multiple...\r\n//\t\tlines.\r\n// */});\r\nfunction Multiline(functionWithInCommentMultiline, useExtraPreprocessing) {\r\n    useExtraPreprocessing = useExtraPreprocessing != null ? useExtraPreprocessing : true;\r\n    var text = functionWithInCommentMultiline.toString().replace(/\\r/g, \"\");\r\n    // some extra preprocessing\r\n    if (useExtraPreprocessing) {\r\n        text = text.replace(/@@.*/g, \"\"); // remove single-line comments\r\n        //text = text.replace(/@\\**?\\*@/g, \"\"); // remove multi-line comments\r\n        text = text.replace(/@\\*/g, \"/*\").replace(/\\*@/g, \"*/\"); // fix multi-line comments\r\n    }\r\n    var firstCharPos = text.indexOf(\"\\n\", text.indexOf(\"/*\")) + 1;\r\n    return text.substring(firstCharPos, text.lastIndexOf(\"\\n\"));\r\n}\r\nexports.Multiline = Multiline;\r\nfunction Multiline_NotCommented(functionWithCode) {\r\n    var text = functionWithCode.toString().replace(/\\r/g, \"\");\r\n    var firstCharOfSecondLinePos = text.indexOf(\"\\n\") + 1;\r\n    var enderOfSecondLastLine = text.lastIndexOf(\"\\n\");\r\n    var result = text.substring(firstCharOfSecondLinePos, enderOfSecondLastLine);\r\n    result = result.replace(/\\t/g, \"    \");\r\n    // replace the start and end tokens of special string-containers (used for keeping comments in-tact)\r\n    result = result.replace(/['\"]@((?:.|\\n)+)@['\"];(\\n(?=\\n))?/g, function (match, sub1) { return sub1.replace(/\\\\n/, \"\\n\"); });\r\n    return result;\r\n}\r\nexports.Multiline_NotCommented = Multiline_NotCommented;\r\nfunction StableSort(array, compare) {\r\n    var array2 = array.map(function (item, index) { return ({ index: index, item: item }); });\r\n    array2.sort(function (a, b) {\r\n        var r = compare(a.item, b.item, a.index, b.index);\r\n        return r != 0 ? r : Compare(a.index, b.index);\r\n    });\r\n    return array2.map(function (pack) { return pack.item; });\r\n}\r\nexports.StableSort = StableSort;\r\nfunction Compare(a, b, caseSensitive) {\r\n    if (caseSensitive === void 0) { caseSensitive = true; }\r\n    if (!caseSensitive && typeof a == \"string\" && typeof b == \"string\") {\r\n        a = a.toLowerCase();\r\n        b = b.toLowerCase();\r\n    }\r\n    return a < b ? -1 : (a > b ? 1 : 0);\r\n}\r\nexports.Compare = Compare;\r\n// just use the word 'percent', even though value is represented as fraction (e.g. 0.5, rather than 50[%])\r\nfunction Lerp(from, to, percentFromXToY, keepResultInRange) {\r\n    if (keepResultInRange === void 0) { keepResultInRange = true; }\r\n    var result = from + ((to - from) * percentFromXToY);\r\n    if (keepResultInRange)\r\n        result = __1.NumberCE(result).KeepBetween(from, to);\r\n    return result;\r\n}\r\nexports.Lerp = Lerp;\r\nfunction GetPercentFromXToY(start, end, val, keepResultInRange) {\r\n    if (keepResultInRange === void 0) { keepResultInRange = true; }\r\n    // distance-from-x / distance-from-x-required-for-result-'1'\r\n    var result = (val - start) / (end - start);\r\n    if (keepResultInRange)\r\n        result = __1.NumberCE(result).KeepBetween(0, 1);\r\n    return result;\r\n}\r\nexports.GetPercentFromXToY = GetPercentFromXToY;\r\nfunction GetXToY(minX, maxY, interval) {\r\n    if (interval === void 0) { interval = 1; }\r\n    var result = [];\r\n    for (var val = minX; val <= maxY; val += interval) {\r\n        result.push(val);\r\n    }\r\n    return result;\r\n}\r\nexports.GetXToY = GetXToY;\r\nfunction GetXToYOut(minX, maxOutY, interval) {\r\n    if (interval === void 0) { interval = 1; }\r\n    var result = [];\r\n    for (var val = minX; val < maxOutY; val += interval) {\r\n        result.push(val);\r\n    }\r\n    return result;\r\n}\r\nexports.GetXToYOut = GetXToYOut;\r\nfunction CloneObject(obj, propMatchFunc, depth) {\r\n    /*var Assert = require(\"../../Frame/General/Assert\").Assert;\r\n    Assert(depth < 100, \"CloneObject cannot work past depth 100! (probably circular ref)\");*/\r\n    var e_3, _a;\r\n    if (depth === void 0) { depth = 0; }\r\n    if (obj == null)\r\n        return null;\r\n    if (Types_1.IsPrimitive(obj))\r\n        return obj;\r\n    //if (obj.GetType() == Array)\r\n    if (obj.constructor == Array)\r\n        return CloneArray(obj);\r\n    /*if (obj instanceof List)\r\n        return List.apply(null, [obj.itemType].concat(V.CloneArray(obj)));\r\n        if (obj instanceof Dictionary) {\r\n            let result = new Dictionary(obj.keyType, obj.valueType);\r\n            for (let pair of obj.Pairs)\r\n                result.Add(pair.key, pair.value);\r\n            return result;\r\n        }*/\r\n    var result = {};\r\n    try {\r\n        for (var _b = __values(obj.Props()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n            var prop = _c.value;\r\n            if (!(prop.value instanceof Function) && (propMatchFunc == null || propMatchFunc.call(obj, prop.name, prop.value)))\r\n                result[prop.name] = CloneObject(prop.value, propMatchFunc, depth + 1);\r\n        }\r\n    }\r\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n    finally {\r\n        try {\r\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n        }\r\n        finally { if (e_3) throw e_3.error; }\r\n    }\r\n    return result;\r\n}\r\nexports.CloneObject = CloneObject;\r\nfunction CloneArray(array) {\r\n    //array.slice(0); //deep: JSON.parse(JSON.stringify(array));\r\n    return Array.prototype.slice.call(array, 0);\r\n}\r\nexports.CloneArray = CloneArray;\r\n/*static IsEqual(a, b) {\r\n    function _equals(a, b) { return JSON.stringify(a) === JSON.stringify($.extend(true, {}, a, b)); }\r\n    return _equals(a, b) && _equals(b, a);\r\n};*/\r\nfunction Bind(func, newThis) {\r\n    return func.bind(newThis);\r\n}\r\nexports.Bind = Bind;\r\n/*static ForEachChildInTreeXDoY(treeX: any, actionY: (value, key: string)=>void) {\r\n    for (let key in treeX) {\r\n        let value = treeX[key];\r\n        actionY(value, key);\r\n        if (typeof value == \"object\" || value instanceof Array)\r\n            V.ForEachChildInTreeXDoY(value, actionY);\r\n    }\r\n}*/\r\nfunction GetHiddenHolder() {\r\n    var holder = document.querySelector(\"#jsve_hiddenContainer\");\r\n    if (holder == null) {\r\n        holder = document.createElement(\"div\");\r\n        holder.id = \"jsve_hiddenContainer\";\r\n        __1.ObjectCE(holder.style).Extend({ position: \"absolute\", left: \"-1000px\", top: \"-1000px\", width: \"1000px\", height: \"1000px\", overflow: \"hidden\" });\r\n        document.body.appendChild(holder);\r\n    }\r\n    return holder;\r\n}\r\nvar GetContentSize_cache = {};\r\nfunction GetContentSize(content, includeMargin, createClone, allowCache) {\r\n    /*var holder = $(\"#jsve_hiddenContainer\");\r\n    var contentClone = content.clone();\r\n    holder.append(contentClone);\r\n    var width = contentClone.outerWidth();\r\n    var height = contentClone.outerHeight();\r\n    contentClone.remove();*/\r\n    if (includeMargin === void 0) { includeMargin = false; }\r\n    if (createClone === void 0) { createClone = false; }\r\n    if (allowCache === void 0) { allowCache = true; }\r\n    var cacheStore = Types_1.IsString(content) ? GetContentSize_cache : (content[\"GetContentSize_cache\"] = content[\"GetContentSize_cache\"] || {});\r\n    var currentHTML = Types_1.IsString(content) ? content : content.outerHTML;\r\n    var result = cacheStore[currentHTML];\r\n    if (result == null) {\r\n        var holder = GetHiddenHolder();\r\n        var testElement = Types_1.IsString(content) ? $(content) : (createClone ? $(content).clone() : $(content));\r\n        holder.appendChild(testElement[0]);\r\n        var width = testElement.outerWidth(includeMargin);\r\n        var height = testElement.outerHeight(includeMargin);\r\n        testElement.remove();\r\n        result = { width: width, height: height };\r\n        if (allowCache) {\r\n            cacheStore[currentHTML] = result;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.GetContentSize = GetContentSize;\r\nfunction GetContentWidth(content, includeMargin, createClone, allowCache) {\r\n    if (includeMargin === void 0) { includeMargin = false; }\r\n    if (createClone === void 0) { createClone = false; }\r\n    if (allowCache === void 0) { allowCache = true; }\r\n    return GetContentSize(content, includeMargin, createClone, allowCache).width;\r\n}\r\nexports.GetContentWidth = GetContentWidth;\r\nfunction GetContentHeight(content, includeMargin, createClone, allowCache) {\r\n    if (includeMargin === void 0) { includeMargin = false; }\r\n    if (createClone === void 0) { createClone = false; }\r\n    if (allowCache === void 0) { allowCache = true; }\r\n    return GetContentSize(content, includeMargin, createClone, allowCache).height;\r\n}\r\nexports.GetContentHeight = GetContentHeight;\r\nexports.autoElements = {};\r\nfunction GetAutoElement(startHTML) {\r\n    if (exports.autoElements[startHTML] == null) {\r\n        var holder = GetHiddenHolder();\r\n        var element = $(startHTML)[0];\r\n        holder.appendChild(element);\r\n        exports.autoElements[startHTML] = element;\r\n    }\r\n    return exports.autoElements[startHTML];\r\n}\r\nexports.GetAutoElement = GetAutoElement;\r\nvar TreeNode = /** @class */ (function () {\r\n    function TreeNode(ancestorNodes, obj, prop) {\r\n        this.ancestorNodes = ancestorNodes;\r\n        this.obj = obj;\r\n        this.prop = prop;\r\n    }\r\n    Object.defineProperty(TreeNode.prototype, \"PathNodes\", {\r\n        get: function () {\r\n            if (this.prop == \"_root\")\r\n                return [];\r\n            return __1.ArrayCE(this.ancestorNodes).Select(function (a) { return a.prop; }).concat(this.prop);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(TreeNode.prototype, \"PathStr\", {\r\n        get: function () {\r\n            return this.PathNodes.join(\"/\");\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(TreeNode.prototype, \"PathStr_Updeep\", {\r\n        get: function () {\r\n            return this.PathNodes.join(\".\");\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(TreeNode.prototype, \"Value\", {\r\n        //value;\r\n        get: function () {\r\n            if (this.obj == null)\r\n                return undefined;\r\n            return this.obj[this.prop];\r\n        },\r\n        set: function (newVal) {\r\n            this.obj[this.prop] = newVal;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return TreeNode;\r\n}());\r\nexports.TreeNode = TreeNode;\r\nfunction GetTreeNodesInObjTree(obj, includeRootNode, _ancestorNodes) {\r\n    if (includeRootNode === void 0) { includeRootNode = false; }\r\n    if (_ancestorNodes === void 0) { _ancestorNodes = []; }\r\n    __1.Assert(_ancestorNodes.length <= 300, \"Cannot traverse more than 300 levels into object tree. (probably circular)\");\r\n    var result = [];\r\n    if (includeRootNode)\r\n        result.push(new TreeNode([], { _root: obj }, \"_root\"));\r\n    for (var key in obj) {\r\n        if (!obj.hasOwnProperty(key))\r\n            continue;\r\n        var value = obj[key];\r\n        var currentNode = new TreeNode(_ancestorNodes, obj, key);\r\n        result.push(currentNode);\r\n        if (typeof value == \"object\") {\r\n            __1.ArrayCE(result).AddRange(GetTreeNodesInObjTree(value, false, _ancestorNodes.concat(currentNode)));\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.GetTreeNodesInObjTree = GetTreeNodesInObjTree;\r\n/*export function CloneTreeDownToXWhileReplacingXValue(treeRoot, pathToX: string, newValueForX) {\r\n    let pathNodes = pathToX.split(\"/\");\r\n    let currentPathNode = pathNodes[0];\r\n    let currentPathNode_newValue = pathNodes.length > 1\r\n        ? CloneTreeDownToXWhileReplacingXValue(treeRoot[currentPathNode], pathNodes.Skip(1).join(\"/\"), newValueForX)\r\n        : newValueForX;\r\n    return {...treeRoot, [currentPathNode]: currentPathNode_newValue};\r\n}*/\r\nfunction GetTreeNodesInPath(treeRoot, pathNodesOrStr, includeRootNode, _ancestorNodes) {\r\n    if (includeRootNode === void 0) { includeRootNode = false; }\r\n    if (_ancestorNodes === void 0) { _ancestorNodes = []; }\r\n    var descendantPathNodes = pathNodesOrStr instanceof Array ? pathNodesOrStr : pathNodesOrStr.split(\"/\");\r\n    var childTreeNode = new TreeNode(_ancestorNodes, treeRoot, descendantPathNodes[0]);\r\n    var result = [];\r\n    if (includeRootNode)\r\n        result.push(new TreeNode([], { _root: treeRoot }, \"_root\"));\r\n    result.push(childTreeNode);\r\n    if (descendantPathNodes.length > 1) // if the path goes deeper than the current child-tree-node\r\n        result.push.apply(// if the path goes deeper than the current child-tree-node\r\n        result, __spread(GetTreeNodesInPath(childTreeNode ? childTreeNode.Value : null, __1.ArrayCE(descendantPathNodes).Skip(1).join(\"/\"), false, _ancestorNodes.concat(childTreeNode))));\r\n    return result;\r\n}\r\nexports.GetTreeNodesInPath = GetTreeNodesInPath;\r\n/*export function GetTreeNodesInPath_WithRoot(treeRoot, path: string) {\r\n    return GetTreeNodesInPath({root: treeRoot}, \"root/\" + path).Skip(1);\r\n}*/\r\nfunction VisitTreeNodesInPath(treeRoot, pathNodesOrStr, visitFunc, visitRootNode, _ancestorNodes) {\r\n    if (visitRootNode === void 0) { visitRootNode = false; }\r\n    if (_ancestorNodes === void 0) { _ancestorNodes = []; }\r\n    if (visitRootNode)\r\n        visitFunc(new TreeNode([], { _root: treeRoot }, \"_root\"));\r\n    var descendantPathNodes = pathNodesOrStr instanceof Array ? pathNodesOrStr : pathNodesOrStr.split(\"/\");\r\n    var childTreeNode = new TreeNode(_ancestorNodes, treeRoot, descendantPathNodes[0]);\r\n    visitFunc(childTreeNode);\r\n    if (descendantPathNodes.length > 1) // if the path goes deeper than the current child-tree-node\r\n        VisitTreeNodesInPath(childTreeNode.Value, __1.ArrayCE(descendantPathNodes).Skip(1).join(\"/\"), visitFunc, false, _ancestorNodes.concat(childTreeNode));\r\n    return treeRoot;\r\n}\r\nexports.VisitTreeNodesInPath = VisitTreeNodesInPath;\r\n/*export function VisitTreeNodesInPath_WithRoot(treeRoot, path: string, visitFunc: (node: TreeNode)=>any) {\r\n    VisitTreeNodesInPath({root: treeRoot}, \"root/\" + path, visitFunc);\r\n    return treeRoot;\r\n}*/\r\nfunction ConvertPathGetterFuncToPropChain(pathGetterFunc) {\r\n    var funcStr = pathGetterFunc.toString();\r\n    __1.Assert(!funcStr.includes(\"[\"), \"State-getter-func cannot contain bracket-based property-access.\\n\" + exports.nl + \"For variable inclusion, use multiple segments as in: ...ToPropChain(\\\"main\\\", \\\"mapViews\\\", mapID)\");\r\n    /*const pathStr = funcStr.match(/return [^.]+\\.(.+?);/)[1] as string;\r\n    //let result = pathStr.replace(/\\./g, \"/\");\r\n    const result = pathStr.split(\".\");*/\r\n    var parts = funcStr.split(\".\").slice(1); // remove first segment, since it's just the \"return xxx.\" part\r\n    parts[parts.length - 1] = parts[parts.length - 1].match(/^([a-zA-Z0-9_$]+)/)[1]; // remove semicolon (or whatever else) at the end\r\n    return parts;\r\n}\r\nexports.ConvertPathGetterFuncToPropChain = ConvertPathGetterFuncToPropChain;\r\n/** @param sepChar Default: \"/\" */\r\nfunction DeepGet(obj, pathOrPathSegments, resultIfNull, sepChar) {\r\n    var e_4, _a;\r\n    if (resultIfNull === void 0) { resultIfNull = null; }\r\n    if (sepChar === void 0) { sepChar = \"/\"; }\r\n    var pathSegments = pathOrPathSegments instanceof Array ? pathOrPathSegments : pathOrPathSegments.split(sepChar);\r\n    var result = obj;\r\n    try {\r\n        for (var pathSegments_1 = __values(pathSegments), pathSegments_1_1 = pathSegments_1.next(); !pathSegments_1_1.done; pathSegments_1_1 = pathSegments_1.next()) {\r\n            var pathNode = pathSegments_1_1.value;\r\n            if (result == null)\r\n                break;\r\n            result = result[pathNode];\r\n        }\r\n    }\r\n    catch (e_4_1) { e_4 = { error: e_4_1 }; }\r\n    finally {\r\n        try {\r\n            if (pathSegments_1_1 && !pathSegments_1_1.done && (_a = pathSegments_1.return)) _a.call(pathSegments_1);\r\n        }\r\n        finally { if (e_4) throw e_4.error; }\r\n    }\r\n    if (result == null)\r\n        return resultIfNull;\r\n    return result;\r\n}\r\nexports.DeepGet = DeepGet;\r\n/** @param sepChar Default: \"/\" */\r\nfunction DeepSet(obj, pathOrPathSegments, newValue, sepChar, createPathSegmentsIfMissing, deleteUndefined) {\r\n    if (sepChar === void 0) { sepChar = \"/\"; }\r\n    if (createPathSegmentsIfMissing === void 0) { createPathSegmentsIfMissing = true; }\r\n    if (deleteUndefined === void 0) { deleteUndefined = false; }\r\n    var pathSegments = pathOrPathSegments instanceof Array ? pathOrPathSegments : pathOrPathSegments.split(sepChar);\r\n    var deepObj = obj;\r\n    // tunnel down to the object holding the path-specified prop\r\n    pathSegments.slice(0, -1).forEach(function (segment) {\r\n        if (deepObj[segment] == null) {\r\n            if (createPathSegmentsIfMissing) {\r\n                deepObj[segment] = {};\r\n            }\r\n            else {\r\n                __1.Assert(false, \"The given path (\" + pathSegments.join(\"/\") + \") had a missing segment (\" + segment + \"), so the deep-set failed.\");\r\n            }\r\n        }\r\n        deepObj = deepObj[segment];\r\n    });\r\n    if (newValue === undefined && deleteUndefined) {\r\n        delete deepObj[__1.ArrayCE(pathSegments).Last()];\r\n    }\r\n    else {\r\n        deepObj[__1.ArrayCE(pathSegments).Last()] = newValue;\r\n    }\r\n}\r\nexports.DeepSet = DeepSet;\r\n/** @param sepChar Default: \"/\" */\r\n/*export function WithDeepSet(baseObj, pathOrPathSegments: string | (string | number)[], newValue, sepChar = \"/\") {\r\n    let pathSegments = pathOrPathSegments instanceof Array ? pathOrPathSegments : pathOrPathSegments.split(sepChar);\r\n\r\n    let result;\r\n    let result_deep;\r\n    let baseObj_deep = baseObj;\r\n    // tunnel down to the given path, overwriting the result_deep and baseObj_deep variables along the way\r\n    pathSegments.forEach((segment, index)=> {\r\n        // initialize with correct constructor for special cases (there might be some others, but this is sufficient for now)\r\n        result_deep = baseObj_deep instanceof Array ? [...baseObj_deep] : {...baseObj_deep};\r\n        Object.setPrototypeOf(result_deep, Object.getPrototypeOf(baseObj_deep)); // set the prototype to match\r\n        result = result || result_deep;\r\n\r\n        if (index < pathSegments.length - 1) {\r\n            // tunnel down, for next iteration\r\n            result_deep = result_deep[segment];\r\n            baseObj_deep = baseObj_deep[segment];\r\n        } else {\r\n            result_deep[segment] = newValue;\r\n        }\r\n    });\r\n    return result;\r\n}*/\r\nfunction WithDeepSet(baseObj, pathOrPathSegments, newValue, sepChar) {\r\n    var _a;\r\n    if (sepChar === void 0) { sepChar = \"/\"; }\r\n    var pathSegments = pathOrPathSegments instanceof Array ? pathOrPathSegments : pathOrPathSegments.split(sepChar);\r\n    return __assign(__assign({}, baseObj), (_a = {}, _a[pathSegments[0]] = pathSegments.length > 1 ? WithDeepSet(baseObj[pathSegments[0]], pathSegments.slice(1), newValue) : newValue, _a));\r\n}\r\nexports.WithDeepSet = WithDeepSet;\r\n//@((()=> { if (g.onclick == null) g.onclick = ()=>console.log(V.GetStackTraceStr()); }) as any)\r\nfunction GetStackTraceStr() {\r\n    var _a, _b;\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    var stackTrace, sourceStackTrace = true;\r\n    if (Types_1.IsString(args[0]))\r\n        _a = __read(args, 2), stackTrace = _a[0], sourceStackTrace = _a[1];\r\n    else\r\n        _b = __read(args, 1), sourceStackTrace = _b[0];\r\n    //stackTrace = stackTrace || new Error()[sourceStackTrace ? \"Stack\" : \"stack\"];\r\n    //stackTrace = stackTrace || (sourceStackTrace ? StackTrace.get().then(stack=>stackTrace = stack.map(a=>a.toString()).join(\"\\n\")) : new Error().stack);\r\n    //stackTrace = stackTrace || new Error().stack;\r\n    if (stackTrace == null) {\r\n        //let fakeError = {}.VAct(a=>Error.captureStackTrace(a));\r\n        var oldStackLimit = Error.stackTraceLimit;\r\n        Error.stackTraceLimit = Infinity;\r\n        var fakeError = new Error();\r\n        stackTrace = fakeError.stack;\r\n        Error.stackTraceLimit = oldStackLimit;\r\n    }\r\n    return stackTrace.substr(__1.StringCE(stackTrace).IndexOf_X(\"\\n\", 1)); // remove \"Error\" line and first stack-frame (that of this method)\r\n}\r\nexports.GetStackTraceStr = GetStackTraceStr;\r\nfunction GetErrorMessagesUnderElement(element) {\r\n    //return element.querySelectorAll(\":invalid\").ToList().map(node=>node.validationMessage || `Invalid value.`);\r\n    return Array.from(element.querySelectorAll(\":invalid\")).map(function (node) { return node.validationMessage || \"Invalid value.\"; });\r\n}\r\nexports.GetErrorMessagesUnderElement = GetErrorMessagesUnderElement;\r\nexports.DEL = \"JS_VEXTENSIONS_SPECIAL_DELETE_KEY\";\r\nfunction FindDOM(selector) {\r\n    return document.querySelector(selector);\r\n}\r\nexports.FindDOM = FindDOM;\r\nfunction FindDOMAll(selector) {\r\n    return Array.from(document.querySelectorAll(selector));\r\n}\r\nexports.FindDOMAll = FindDOMAll;\r\nfunction WaitTillDataPathIsSet(dataPath) {\r\n    var _this = this;\r\n    return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {\r\n        var dataPathParts, currentParent, dataPathParts_1, dataPathParts_1_1, part, e_5_1;\r\n        var e_5, _a;\r\n        return __generator(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0:\r\n                    dataPathParts = dataPath.split(\".\");\r\n                    currentParent = g;\r\n                    _b.label = 1;\r\n                case 1:\r\n                    _b.trys.push([1, 8, 9, 10]);\r\n                    dataPathParts_1 = __values(dataPathParts), dataPathParts_1_1 = dataPathParts_1.next();\r\n                    _b.label = 2;\r\n                case 2:\r\n                    if (!!dataPathParts_1_1.done) return [3 /*break*/, 7];\r\n                    part = dataPathParts_1_1.value;\r\n                    _b.label = 3;\r\n                case 3:\r\n                    if (!(currentParent[part] == null)) return [3 /*break*/, 5];\r\n                    return [4 /*yield*/, WaitTillPropertyIsSet(currentParent, part)];\r\n                case 4:\r\n                    _b.sent();\r\n                    return [3 /*break*/, 3];\r\n                case 5:\r\n                    currentParent = currentParent[part];\r\n                    _b.label = 6;\r\n                case 6:\r\n                    dataPathParts_1_1 = dataPathParts_1.next();\r\n                    return [3 /*break*/, 2];\r\n                case 7: return [3 /*break*/, 10];\r\n                case 8:\r\n                    e_5_1 = _b.sent();\r\n                    e_5 = { error: e_5_1 };\r\n                    return [3 /*break*/, 10];\r\n                case 9:\r\n                    try {\r\n                        if (dataPathParts_1_1 && !dataPathParts_1_1.done && (_a = dataPathParts_1.return)) _a.call(dataPathParts_1);\r\n                    }\r\n                    finally { if (e_5) throw e_5.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 10:\r\n                    resolve();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    }); });\r\n}\r\nexports.WaitTillDataPathIsSet = WaitTillDataPathIsSet;\r\nfunction WaitTillPropertyIsSet(obj, prop) {\r\n    return new Promise(function (resolve, reject) {\r\n        __1.ObjectCE(obj)._AddGetterSetter(prop, function () { }, function (value) {\r\n            delete obj[prop]; // remove this hook\r\n            obj[prop] = value; // set to provided value\r\n            resolve();\r\n        });\r\n    });\r\n}\r\nexports.WaitTillPropertyIsSet = WaitTillPropertyIsSet;\r\nvar CapScheme;\r\n(function (CapScheme) {\r\n    /** examplePropNameWithDuoWord */ CapScheme[CapScheme[\"PropName\"] = 0] = \"PropName\";\r\n    /** Example Title With Duo-Word */ CapScheme[CapScheme[\"Title\"] = 1] = \"Title\";\r\n    /** Example sentence with duo-word */ CapScheme[CapScheme[\"Sentence\"] = 2] = \"Sentence\";\r\n})(CapScheme = exports.CapScheme || (exports.CapScheme = {}));\r\nfunction ChangeCapitalization(text, fromScheme, toScheme) {\r\n    var inStandardScheme = ConvertFromSchemeXToStandardScheme(text, fromScheme);\r\n    return ConvertFromStandardSchemeToSchemeX(inStandardScheme, toScheme);\r\n}\r\nexports.ChangeCapitalization = ChangeCapitalization;\r\n// \"standard scheme\" is currently CapitalizeScheme.Sentence\r\nfunction ConvertFromSchemeXToStandardScheme(text, fromScheme) {\r\n    if (fromScheme == CapScheme.PropName) {\r\n        // demo string: somePropName\r\n        return text\r\n            // somePropName -> some prop name\r\n            .replace(/[A-Z]/g, function (a) { return \" \" + a.toLowerCase(); })\r\n            // some prop name -> Some prop name\r\n            .replace(/^./, function (a) { return a.toUpperCase(); });\r\n    }\r\n    else if (fromScheme == CapScheme.Title) {\r\n        __1.Assert(false, \"Not yet implemented.\");\r\n    }\r\n    else if (fromScheme == CapScheme.Sentence) {\r\n        return text;\r\n    }\r\n}\r\nfunction ConvertFromStandardSchemeToSchemeX(text, toScheme) {\r\n    if (toScheme == CapScheme.PropName) {\r\n        __1.Assert(false, \"Not yet implemented.\");\r\n    }\r\n    else if (toScheme == CapScheme.Title) {\r\n        __1.Assert(false, \"Not yet implemented.\");\r\n    }\r\n    else if (toScheme == CapScheme.Sentence) {\r\n        return text;\r\n    }\r\n}\r\nfunction StartDownload(content, filename, dataTypeStr, encodeContentAsURIComp) {\r\n    if (dataTypeStr === void 0) { dataTypeStr = \"data:application/octet-stream,\"; }\r\n    if (encodeContentAsURIComp === void 0) { encodeContentAsURIComp = true; }\r\n    var link = document.createElement(\"a\");\r\n    Object.assign(link.style, { display: \"none\" });\r\n    link.innerText = \"Save to disk\";\r\n    link.setAttribute(\"href\", dataTypeStr + (encodeContentAsURIComp ? encodeURIComponent(content) : content));\r\n    link.setAttribute(\"download\", filename);\r\n    document.body.appendChild(link);\r\n    link.click();\r\n    link.remove();\r\n}\r\nexports.StartDownload = StartDownload;\r\nfunction StartUpload() {\r\n    return new Promise(function (resolve) {\r\n        var fileInput = document.createElement(\"input\");\r\n        fileInput.type = \"file\";\r\n        fileInput.style.display = \"none\";\r\n        fileInput.onchange = function (e) {\r\n            var file = e.target[\"files\"][0];\r\n            if (!file)\r\n                return;\r\n            var reader = new FileReader();\r\n            reader.onload = function (e) {\r\n                var contents = e.target[\"result\"];\r\n                //Assert(typeof contents == \"string\")\r\n                resolve(contents);\r\n            };\r\n            reader.readAsText(file);\r\n        };\r\n        document.body.appendChild(fileInput);\r\n        fileInput.click();\r\n    });\r\n}\r\nexports.StartUpload = StartUpload;\r\nfunction TransferPrototypeProps(target, source, descriptorBase, descriptorOverride) {\r\n    var e_6, _a;\r\n    try {\r\n        for (var _b = __values(Object.entries(Object.getOwnPropertyDescriptors(source))), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n            var _d = __read(_c.value, 2), name_1 = _d[0], descriptor = _d[1];\r\n            if (name_1 == \"constructor\")\r\n                continue;\r\n            Object.defineProperty(target, name_1, Object.assign({}, descriptorBase, descriptor, descriptorOverride));\r\n        }\r\n    }\r\n    catch (e_6_1) { e_6 = { error: e_6_1 }; }\r\n    finally {\r\n        try {\r\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n        }\r\n        finally { if (e_6) throw e_6.error; }\r\n    }\r\n}\r\nexports.TransferPrototypeProps = TransferPrototypeProps;\r\nfunction WithFuncsStandalone(source) {\r\n    var e_7, _a;\r\n    var result = {};\r\n    var _loop_1 = function (key) {\r\n        if (key == \"constructor\")\r\n            return \"continue\"; // no reason to call the wrapper's constructor\r\n        var descriptor = Object.getOwnPropertyDescriptor(source, key);\r\n        var newDescriptor = Object.assign({}, descriptor);\r\n        if (descriptor.value instanceof Function) {\r\n            var oldFunc_1 = descriptor.value;\r\n            newDescriptor.value = function (thisArg) {\r\n                var callArgs = [];\r\n                for (var _i = 1; _i < arguments.length; _i++) {\r\n                    callArgs[_i - 1] = arguments[_i];\r\n                }\r\n                return oldFunc_1.apply(thisArg, callArgs);\r\n            };\r\n        }\r\n        Object.defineProperty(result, key, newDescriptor);\r\n    };\r\n    try {\r\n        for (var _b = __values(Object.getOwnPropertyNames(source)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n            var key = _c.value;\r\n            _loop_1(key);\r\n        }\r\n    }\r\n    catch (e_7_1) { e_7 = { error: e_7_1 }; }\r\n    finally {\r\n        try {\r\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n        }\r\n        finally { if (e_7) throw e_7.error; }\r\n    }\r\n    return result;\r\n}\r\nexports.WithFuncsStandalone = WithFuncsStandalone;\r\n/*export type WithFuncThisArgsAsAny_Type<T> = {\r\n    [P in keyof T]:\r\n        T[P] extends (this: any, ...args)=>any ? (this: any, ...args: Parameters<T[P]>)=>ReturnType<T[P]> :\r\n        T[P];\r\n};\r\nexport function WithFuncThisArgsAsAny<T>(source: T): WithFuncThisArgsAsAny_Type<T> {\r\n    return source as any;\r\n}*/\r\n/*export type WithFuncThisArgTypesWrappedBy_Type<T> = {\r\n    [P in keyof T]:\r\n        T[P] extends (this: infer T2, ...args)=>any ? (this: T<T2>, ...args: Parameters<T[P]>)=>ReturnType<T[P]> :\r\n        T[P];\r\n};\r\nexport function WithFuncThisArgTypesWrappedBy<T>(source: T): WithFuncThisArgTypesWrappedBy_Type<T> {\r\n    return source as any;\r\n}*/\r\n// use this simpler variant for class-extensions of target-types, where the class-extension methods don't need the type-generics of the target-type\r\n/*export function CreateProxyForClassExtensions_ThisAsAny<T>(sourceClass: new(...args: any[])=>T) {\r\n    return CreateProxyForClassExtensions<WithFuncThisArgsAsAny_Type<T>>(sourceClass as any);\r\n}*/\r\n//export function CreateProxyForClassExtensions<T>(sourceClass: new(...args: any[])=>T) {\r\n//export function CreateProxyForClassExtensions(sourceClass_prototype: any) {\r\n// old comment: we don't use this (specifying types at time of proxy-creation), as it would cause loss/simplifying of type-data for function calls\r\nfunction CreateProxyForClassExtensions(sourceClass_prototype) {\r\n    // proxy approach; nicer, but I don't like potential slowdown from creating new proxy each time a class-extension method is called!\r\n    /*return (thisArg: any)=> {\r\n        return new Proxy({}, {\r\n            get(target, key, receiver?) {\r\n                if (key == \"constructor\") return Reflect.get(target, key, receiver); // no reason to call the wrapper's constructor\r\n                let descriptor = Object.getOwnPropertyDescriptor(sourceClass.prototype, key);\r\n                if (descriptor.value instanceof Function) {\r\n                    let oldFunc = descriptor.value as Function;\r\n                    return (...callArgs)=> {\r\n                        return oldFunc.apply(thisArg, callArgs);\r\n                    };\r\n                }\r\n            }\r\n        //}) as T;\r\n        }) as WithFuncThisArgsAsAny_Type<T>;\r\n    };*/\r\n    var e_8, _a;\r\n    // Static proxy approach -- a bit faster since it doesn't create any functions, closures, or proxies per wrap/CE-method-call.\r\n    //\t(Limitation: you can't store the result of \"ObjectCE(something)\" and call a method attached to it more than once, since each method-call removes the supplied this-arg from the stack.)\r\n    /*let proxy = {} as any;\r\n    const thisArgStack = [];*/\r\n    var proxy = {};\r\n    var thisArgStack = [];\r\n    var _loop_2 = function (key) {\r\n        if (key == \"constructor\")\r\n            return \"continue\"; // no reason to call the wrapper's constructor\r\n        var descriptor = Object.getOwnPropertyDescriptor(sourceClass_prototype, key);\r\n        var newDescriptor = Object.assign({}, descriptor);\r\n        if (descriptor.value instanceof Function) {\r\n            var oldFunc_2 = descriptor.value;\r\n            newDescriptor.value = function () {\r\n                var callArgs = [];\r\n                for (var _i = 0; _i < arguments.length; _i++) {\r\n                    callArgs[_i] = arguments[_i];\r\n                }\r\n                var thisArg = thisArgStack[thisArgStack.length - 1];\r\n                var result = oldFunc_2.apply(thisArg, callArgs);\r\n                //thisArgStack.length--;\r\n                thisArgStack.splice(thisArgStack.length - 1, 1);\r\n                return result;\r\n            };\r\n        }\r\n        Object.defineProperty(proxy, key, newDescriptor);\r\n    };\r\n    try {\r\n        for (var _b = __values(Object.getOwnPropertyNames(sourceClass_prototype)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n            var key = _c.value;\r\n            _loop_2(key);\r\n        }\r\n    }\r\n    catch (e_8_1) { e_8 = { error: e_8_1 }; }\r\n    finally {\r\n        try {\r\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n        }\r\n        finally { if (e_8) throw e_8.error; }\r\n    }\r\n    //return (nextThis: any)=> {\r\n    return function (nextThis) {\r\n        thisArgStack.push(nextThis);\r\n        return proxy;\r\n    };\r\n}\r\nexports.CreateProxyForClassExtensions = CreateProxyForClassExtensions;\r\n//# sourceMappingURL=General.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __values = (this && this.__values) || function(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n};\r\nvar __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nvar __spread = (this && this.__spread) || function () {\r\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar __1 = require(\"..\");\r\nvar TimerContext = /** @class */ (function () {\r\n    function TimerContext() {\r\n        this.timers = [];\r\n    }\r\n    TimerContext.prototype.Reset = function () {\r\n        var e_1, _a;\r\n        try {\r\n            for (var _b = __values(this.timers), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var timer = _c.value;\r\n                timer.Stop();\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        this.timers = [];\r\n    };\r\n    // Can be useful on platforms (eg. Android) where setInterval() and setTimeout() stop working when the screen is off.\r\n    // Just have the Android code call the js every second or so, running this method; this will force the timer-functions to be manually triggered once they've passed the expected tick-time.\r\n    TimerContext.prototype.ManuallyTriggerOverdueTimers = function () {\r\n        var e_2, _a;\r\n        try {\r\n            for (var _b = __values(this.timers), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var timer = _c.value;\r\n                if (timer.NextTickFuncOverdue) {\r\n                    timer.nextTickFunc();\r\n                }\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n    };\r\n    TimerContext.default = new TimerContext();\r\n    TimerContext.default_autoAddAll = false;\r\n    return TimerContext;\r\n}());\r\nexports.TimerContext = TimerContext;\r\n// methods\r\n// ==========\r\nfunction TryCall(func) {\r\n    var args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        args[_i - 1] = arguments[_i];\r\n    }\r\n    //if (!(func instanceof Function)) return;\r\n    if (typeof func != \"function\")\r\n        return;\r\n    try {\r\n        return func.apply(this, args);\r\n    }\r\n    catch (ex) { }\r\n}\r\nexports.TryCall = TryCall;\r\nfunction TryCall_OnX(obj, func) {\r\n    var args = [];\r\n    for (var _i = 2; _i < arguments.length; _i++) {\r\n        args[_i - 2] = arguments[_i];\r\n    }\r\n    if (typeof func != \"function\")\r\n        return;\r\n    try {\r\n        return func.apply(obj, args);\r\n    }\r\n    catch (ex) { }\r\n}\r\nexports.TryCall_OnX = TryCall_OnX;\r\n/*let oldTimeout = setTimeout;\r\ng.setTimeout = function(func: Function, delayInMS = 0, ...args) {\r\n    // setTimeout can take really long on Chrome mobile (eg. while scrolling), for some reason (like, 1.5 seconds)\r\n    // on desktop, setImmediate is better as well, since it takes ~0ms instead of 1-15ms\r\n    if (delayInMS == 0)\r\n        return setImmediate(func, ...args);\r\n    return oldTimeout(func, delayInMS, ...args);\r\n}*/\r\n/*export function Sleep(ms) {\r\n    var startTime = new Date().getTime();\r\n    while (new Date().getTime() - startTime < ms) {}\r\n}*/\r\nvar maxTimeoutLength = 0x7FFFFFFF; // setTimeout limit is MAX_INT32=(2^31-1)\r\nfunction WaitXThenRun(delayInMS, func) {\r\n    var args = [];\r\n    for (var _i = 2; _i < arguments.length; _i++) {\r\n        args[_i - 2] = arguments[_i];\r\n    }\r\n    __1.Assert(delayInMS <= maxTimeoutLength, \"Cannot wait for longer than \" + maxTimeoutLength + \" ms. (use WaitUntilXThenRun, if a long-delay is needed)\");\r\n    // setTimeout can take really long on Chrome mobile (eg. while scrolling), for some reason (like, 1.5 seconds)\r\n    // on desktop, setImmediate is better as well, since it takes ~0ms instead of 1-15ms\r\n    if (delayInMS == 0) {\r\n        return window[\"setImmediate\"].apply(window, __spread([func], args)); // same as below\r\n    }\r\n    return setTimeout.apply(void 0, __spread([func, delayInMS], args)); // \"as any\": maybe temp; used to allow source-importing from NodeJS\r\n}\r\nexports.WaitXThenRun = WaitXThenRun;\r\nfunction WaitUntilXThenRun(targetDateTimeInMS, func) {\r\n    var args = [];\r\n    for (var _i = 2; _i < arguments.length; _i++) {\r\n        args[_i - 2] = arguments[_i];\r\n    }\r\n    var now = Date.now();\r\n    var diff = __1.NumberCE(targetDateTimeInMS - now).KeepAtLeast(0);\r\n    if (diff > maxTimeoutLength) {\r\n        WaitXThenRun(maxTimeoutLength, function () { return WaitUntilXThenRun(targetDateTimeInMS, func); });\r\n    }\r\n    else {\r\n        WaitXThenRun(diff, func);\r\n    }\r\n}\r\nexports.WaitUntilXThenRun = WaitUntilXThenRun;\r\nfunction SleepAsync(timeMS) {\r\n    return new Promise(function (resolve, reject) {\r\n        WaitXThenRun(timeMS, resolve);\r\n    });\r\n}\r\nexports.SleepAsync = SleepAsync;\r\nfunction SleepAsyncUntil(targetDateTimeInMS) {\r\n    return new Promise(function (resolve, reject) {\r\n        WaitUntilXThenRun(targetDateTimeInMS, resolve);\r\n    });\r\n}\r\nexports.SleepAsyncUntil = SleepAsyncUntil;\r\nvar DoNothingXTimesThenDoY_counters = {};\r\nfunction DoNothingXTimesThenDoY(doNothingCount, func, key) {\r\n    if (key === void 0) { key = \"default\"; }\r\n    if (DoNothingXTimesThenDoY_counters[key] == null) {\r\n        DoNothingXTimesThenDoY_counters[key] = 0;\r\n    }\r\n    if (DoNothingXTimesThenDoY_counters[key] >= doNothingCount) {\r\n        func();\r\n    }\r\n    DoNothingXTimesThenDoY_counters[key]++;\r\n}\r\nexports.DoNothingXTimesThenDoY = DoNothingXTimesThenDoY;\r\n// interval is in seconds (can be decimal)\r\nvar Timer = /** @class */ (function () {\r\n    function Timer(intervalInMS, func, maxCallCount) {\r\n        if (maxCallCount === void 0) { maxCallCount = -1; }\r\n        this.timerID = -1;\r\n        this.callCount_thisRun = 0;\r\n        this.callCount_total = 0;\r\n        __1.Assert(__1.IsNumber(intervalInMS), \"Interval must be a number.\");\r\n        this.intervalInMS = intervalInMS;\r\n        this.func = func;\r\n        this.maxCallCount = maxCallCount;\r\n        if (TimerContext.default_autoAddAll) {\r\n            TimerContext.default.timers.push(this);\r\n        }\r\n    }\r\n    Timer.prototype.SetContext = function (timerContext) {\r\n        __1.Assert(timerContext, \"TimerContext cannot be null.\");\r\n        this.timerContexts = (this.timerContexts || []).concat(timerContext);\r\n        timerContext.timers.push(this);\r\n        return this;\r\n    };\r\n    Timer.prototype.RemoveFromContext = function (timerContext) {\r\n        __1.ArrayCE(this.timerContexts).Remove(timerContext);\r\n        __1.ArrayCE(timerContext.timers).Remove(this);\r\n    };\r\n    Timer.prototype.ClearContexts = function () {\r\n        var e_3, _a;\r\n        try {\r\n            for (var _b = __values(this.timerContexts), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var context = _c.value;\r\n                this.RemoveFromContext(context);\r\n            }\r\n        }\r\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_3) throw e_3.error; }\r\n        }\r\n    };\r\n    Object.defineProperty(Timer.prototype, \"IsRunning\", {\r\n        get: function () { return this.timerID != -1; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Timer.prototype, \"NextTickFuncOverdue\", {\r\n        get: function () {\r\n            return this.nextTickTime != null && Date.now() > this.nextTickTime && this.nextTickFunc != null;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Timer.prototype.Start = function (initialDelayOverride) {\r\n        var _this = this;\r\n        if (initialDelayOverride === void 0) { initialDelayOverride = null; }\r\n        // if start is called when it's already running, stop the timer first (thus we restart the timer instead of causing overlapping setIntervals/delayed-func-calls)\r\n        if (this.IsRunning)\r\n            this.Stop();\r\n        this.startTime = Date.now();\r\n        var StartRegularInterval = function () {\r\n            _this.nextTickTime = _this.startTime + _this.intervalInMS;\r\n            _this.timerID = setInterval(_this.nextTickFunc = function () {\r\n                _this.callCount_thisRun++;\r\n                _this.callCount_total++;\r\n                _this.func();\r\n                if (_this.maxCallCount != -1 && _this.callCount_thisRun >= _this.maxCallCount) {\r\n                    _this.Stop();\r\n                }\r\n                else {\r\n                    //this.nextTickTime += this.intervalInMS;\r\n                    _this.nextTickTime = Date.now() + _this.intervalInMS; // using Date.now() prevents the prop from getting out-of-sync (from sleep-mode)\r\n                }\r\n            }, _this.intervalInMS); // \"as any\": maybe temp; used to allow source-importing from NodeJS\r\n        };\r\n        if (initialDelayOverride != null) {\r\n            this.nextTickTime = this.startTime + initialDelayOverride;\r\n            this.timerID = setTimeout(this.nextTickFunc = function () {\r\n                _this.callCount_thisRun++;\r\n                _this.callCount_total++;\r\n                _this.func();\r\n                if (_this.maxCallCount != -1 && _this.callCount_thisRun >= _this.maxCallCount) {\r\n                    _this.Stop();\r\n                }\r\n                else {\r\n                    StartRegularInterval();\r\n                }\r\n            }, initialDelayOverride); // \"as any\": maybe temp; used to allow source-importing from NodeJS\r\n        }\r\n        else {\r\n            StartRegularInterval();\r\n        }\r\n        return this; // enable chaining, for SetContext() call\r\n    };\r\n    Timer.prototype.Stop = function () {\r\n        clearInterval(this.timerID);\r\n        //this.startTime = null;\r\n        this.nextTickTime = null;\r\n        this.nextTickFunc = null;\r\n        this.timerID = -1;\r\n        this.callCount_thisRun = 0;\r\n    };\r\n    return Timer;\r\n}());\r\nexports.Timer = Timer;\r\nvar TimerS = /** @class */ (function (_super) {\r\n    __extends(TimerS, _super);\r\n    function TimerS(interval_decimal, func, maxCallCount) {\r\n        if (maxCallCount === void 0) { maxCallCount = -1; }\r\n        return _super.call(this, interval_decimal * 1000, func, maxCallCount) || this;\r\n    }\r\n    return TimerS;\r\n}(Timer));\r\nexports.TimerS = TimerS;\r\nvar funcLastScheduledRunTimes = {};\r\nfunction BufferAction() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    if (args.length == 2)\r\n        var _a = __read(args, 2), minInterval = _a[0], func = _a[1], key = null;\r\n    else if (args.length == 3)\r\n        var _b = __read(args, 3), key = _b[0], minInterval = _b[1], func = _b[2];\r\n    var lastScheduledRunTime = funcLastScheduledRunTimes[key] || 0;\r\n    var now = new Date().getTime();\r\n    var timeSinceLast = now - lastScheduledRunTime;\r\n    if (timeSinceLast >= minInterval) { // if we've waited enough since last run, run right now\r\n        func();\r\n        funcLastScheduledRunTimes[key] = now;\r\n    }\r\n    else {\r\n        var waitingForNextRunAlready = lastScheduledRunTime > now;\r\n        if (!waitingForNextRunAlready) { // else, if we're not already waiting for next-run, schedule next-run\r\n            var nextRunTime = lastScheduledRunTime + minInterval;\r\n            var timeTillNextRun = nextRunTime - now;\r\n            WaitXThenRun(timeTillNextRun, func);\r\n            funcLastScheduledRunTimes[key] = nextRunTime;\r\n        }\r\n    }\r\n}\r\nexports.BufferAction = BufferAction;\r\n//# sourceMappingURL=Timers.js.map","\"use strict\";\r\n// standard types\r\n// ----------\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*export class bool extends Boolean {}\r\nexport class int extends Number {}\r\nexport class double extends Number {}\r\nexport var string = \"string\" as any as (new(..._)=>string);*/\r\nexports.bool = function () { return \"bool\"; };\r\nexports.int = function () { return \"int\"; };\r\nexports.double = function () { return \"double\"; };\r\nexports.string = function () { return \"string\"; };\r\nfunction IsNaN(obj) { return typeof obj == \"number\" && obj != obj; }\r\nexports.IsNaN = IsNaN;\r\nfunction IsPrimitive(obj) { return IsBool(obj) || IsNumber(obj) || IsString(obj); }\r\nexports.IsPrimitive = IsPrimitive;\r\nfunction IsBool(obj) { return typeof obj == \"boolean\"; } //|| obj instanceof Boolean\r\nexports.IsBool = IsBool;\r\nfunction ToBool(boolStr) { return boolStr == \"true\" ? true : false; }\r\nexports.ToBool = ToBool;\r\nfunction IsArray(obj) { return Array.isArray(obj); } // for briefness and/or consistency\r\nexports.IsArray = IsArray;\r\nfunction IsObject(obj) { return typeof obj == \"object\"; }\r\nexports.IsObject = IsObject;\r\n//export function IsObjectOf<T>(obj) : obj is T { return typeof obj == \"object\"; }\r\n//export function IsOfType<T>(obj, typeConstructor: new()=>T) : obj is T { return obj.constructor.name == typeConstructor.name; }\r\nfunction IsTypeX(obj, typeConstructor) { return obj instanceof typeConstructor; }\r\nexports.IsTypeX = IsTypeX;\r\nfunction IsNumberString(obj, allowNaN) {\r\n    if (allowNaN === void 0) { allowNaN = false; }\r\n    return IsString(obj) && obj.length && IsNumber(Number(obj), false, allowNaN);\r\n}\r\nexports.IsNumberString = IsNumberString;\r\nfunction IsNumber(obj, allowNumberObj, allowNaN) {\r\n    if (allowNumberObj === void 0) { allowNumberObj = false; }\r\n    if (allowNaN === void 0) { allowNaN = false; }\r\n    if (!allowNaN && IsNaN(obj))\r\n        return false;\r\n    return typeof obj == \"number\" || (allowNumberObj && obj instanceof Number);\r\n}\r\nexports.IsNumber = IsNumber;\r\n/** Basically the same as Number(...), accepting numbers, and converting number-strings of these forms:\r\n1) \"010\" -> 10 [ES5+], 8 [<ES5]\r\n2) \"0x10\" -> 16\r\n3) \"5e3\" -> 5000\r\nDoes *not* convert values of these forms (instead returns valIfConversionFails -- by default NaN):\r\n4) null -> ?\r\n5) \"\" -> ?*/\r\nfunction ToNumber(stringOrFloatVal, valIfConversionFails) {\r\n    if (valIfConversionFails === void 0) { valIfConversionFails = NaN; }\r\n    if (!IsString(stringOrFloatVal) && !IsNumber(stringOrFloatVal))\r\n        return valIfConversionFails;\r\n    if (IsString(stringOrFloatVal) && stringOrFloatVal.length == 0)\r\n        return valIfConversionFails;\r\n    return Number(stringOrFloatVal);\r\n}\r\nexports.ToNumber = ToNumber;\r\nfunction IsInt(obj) { return IsNumber(obj) && parseInt(obj) == obj; }\r\nexports.IsInt = IsInt;\r\nfunction ToInt(stringOrFloatVal, valIfConversionFails) {\r\n    if (valIfConversionFails === void 0) { valIfConversionFails = NaN; }\r\n    return parseInt(ToNumber(stringOrFloatVal, valIfConversionFails) + \"\");\r\n}\r\nexports.ToInt = ToInt;\r\n/*export function IsFloat(obj) : obj is number { return typeof obj == \"number\" && parseFloat(obj as any) != parseInt(obj as any); }\r\nexport function ToFloat(stringOrIntVal) { return parseFloat(stringOrIntVal); }*/\r\nfunction IsString(obj, allowStringObj) {\r\n    if (allowStringObj === void 0) { allowStringObj = false; }\r\n    return typeof obj == \"string\" || (allowStringObj && obj instanceof String);\r\n}\r\nexports.IsString = IsString;\r\nfunction ToString(val) { return \"\" + val; }\r\nexports.ToString = ToString;\r\nfunction IsFunction(obj) {\r\n    //return obj instanceof Function;\r\n    return typeof obj == \"function\";\r\n}\r\nexports.IsFunction = IsFunction;\r\nfunction IsConstructor(obj) {\r\n    //return obj instanceof Function && obj.name;\r\n    return typeof obj == \"function\" && obj.name;\r\n}\r\nexports.IsConstructor = IsConstructor;\r\n/*function TypeOrNameOrGetter_ToName<T>(typeOrNameOrGetter?: string | (new(..._)=>T) | ((_?)=>new(..._)=>T)): string {\r\n    return typeOrNameOrGetter instanceof Function && typeOrNameOrGetter.name ? typeOrNameOrGetter.name :\r\n        typeOrNameOrGetter instanceof Function ? (typeOrNameOrGetter as any)().name :\r\n        typeOrNameOrGetter;\r\n}*/\r\n// classes/enums\r\n// ==========\r\n/*var constructorHelper = function() {};\r\nexport function CreateClass(baseClass, classMembers) {\r\n    baseClass = baseClass || Object;\r\n\r\n    var result;\r\n\r\n    if (classMembers && classMembers.hasOwnProperty(\"constructor\"))\r\n        result = classMembers.constructor;\r\n    else\r\n        result = function () { return baseClass.apply(this, arguments); };\r\n\r\n    constructorHelper.prototype = baseClass.prototype;\r\n    result.prototype = new constructorHelper();\r\n\r\n    if (classMembers)\r\n        result.prototype.Extend(classMembers);\r\n\r\n    result.prototype.constructor = result;\r\n    result.__super__ = baseClass.prototype;\r\n\r\n    return result;\r\n}*/\r\n// enums\r\n// ==========\r\n/**\r\n * Typescript enums compile to an object with each `key = value` pair converted into two props: key->value, value->key\r\n * This function returns just the key->value pairs. (with each entry having the form {name: string, value: number | null})\r\n */\r\nfunction GetEntries(enumType, nameModifierFunc) {\r\n    //let entryNames = Object.keys(enumType).filter(a=>a.match(/^\\D/) != null);\r\n    // valid enum values are numbers and null, so any props other than those are the name->value props we want\r\n    /*let nameValuePairs = enumType.Pairs().filter(pair=>!IsNumberString(pair.key) && pair.key != \"null\");\r\n    return nameValuePairs.map(pair=>({name: nameModifierFunc ? nameModifierFunc(pair.key) : pair.key, value: pair.value as number}));*/\r\n    // valid enum values are numbers and null, so any keys other than those are the ones we want (they're the keys for the key->value pairs)\r\n    var entryNames = Object.keys(enumType).filter(function (key) { return !IsNumberString(key) && key != \"null\"; });\r\n    return entryNames.map(function (name) { return ({ name: nameModifierFunc ? nameModifierFunc(name) : name, value: enumType[name] }); });\r\n}\r\nexports.GetEntries = GetEntries;\r\nfunction GetValues(enumType) {\r\n    return GetEntries(enumType).map(function (a) { return a.value; });\r\n}\r\nexports.GetValues = GetValues;\r\nfunction GetValues_ForSchema(enumType) {\r\n    return GetValues(enumType).map(function (value) { return ({ const: value }); });\r\n}\r\nexports.GetValues_ForSchema = GetValues_ForSchema;\r\n//# sourceMappingURL=Types.js.map","\"use strict\";\r\nvar __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nvar __spread = (this && this.__spread) || function () {\r\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n};\r\nvar __values = (this && this.__values) || function(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar __1 = require(\"..\");\r\nfunction ToAbsoluteUrl(url) {\r\n    // Handle absolute URLs (with protocol-relative prefix)\r\n    // Example: //domain.com/file.png\r\n    if (url.search(/^\\/\\//) != -1) {\r\n        return window.location.protocol + url;\r\n    }\r\n    // Handle absolute URLs (with explicit origin)\r\n    // Example: http://domain.com/file.png\r\n    if (url.search(/:\\/\\//) != -1) {\r\n        return url;\r\n    }\r\n    // Handle absolute URLs (without explicit origin)\r\n    // Example: /file.png\r\n    if (url.search(/^\\//) != -1) {\r\n        return window.location.origin + url;\r\n    }\r\n    // Handle relative URLs\r\n    // Example: file.png\r\n    var base = window.location.href.match(/(.*\\/)/)[0];\r\n    return base + url;\r\n}\r\nexports.ToAbsoluteUrl = ToAbsoluteUrl;\r\nfunction JumpToHash(hashStr) {\r\n    var url = location.href; // Save down the URL without hash.\r\n    location.href = \"#\" + hashStr; // Go to the target element.\r\n    history.replaceState(null, null, url); // Don't like hashes. Changing it back.\r\n    //document.getElementById(hashStr).scrollIntoView(); //Even IE6 supports this\r\n}\r\nexports.JumpToHash = JumpToHash;\r\n/** Returns [domainStr, pathStr, varsStr, hashStr], without the separator-chars. */\r\nfunction GetCurrentURLString() {\r\n    return window.location.href.replace(/%22/, \"\\\"\");\r\n}\r\nexports.GetCurrentURLString = GetCurrentURLString;\r\nfunction GetUrlParts(url) {\r\n    var _a, _b, _c;\r\n    url = url || GetCurrentURLString();\r\n    var _d = __read(Array(4).fill(0).map(function (a) { return \"\"; }), 4), domainStr = _d[0], pathStr = _d[1], varsStr = _d[2], hashStr = _d[3];\r\n    var urlToProcess = url;\r\n    if (urlToProcess.includes(\"#\") && !varsStr.includes(\"runJS=\")) {\r\n        _a = __read(__1.StringCE(urlToProcess).SplitAt(urlToProcess.indexOf(\"#\")), 2), urlToProcess = _a[0], hashStr = _a[1];\r\n    }\r\n    if (urlToProcess.includes(\"?\")) {\r\n        _b = __read(__1.StringCE(urlToProcess).SplitAt(urlToProcess.indexOf(\"?\")), 2), urlToProcess = _b[0], varsStr = _b[1];\r\n    }\r\n    //if (urlToProcess.Matches(\"/\").length == )\r\n    var splitAtSlash_pos = __1.NumberCE(__1.StringCE(urlToProcess).IndexOf_X(\"/\", 2)).IfN1Then(urlToProcess.length);\r\n    _c = __read(__1.StringCE(urlToProcess).SplitAt(splitAtSlash_pos), 2), domainStr = _c[0], pathStr = _c[1];\r\n    return [domainStr, pathStr, varsStr, hashStr];\r\n}\r\nexports.GetUrlParts = GetUrlParts;\r\nfunction GetUrlPath(url, fromDomain) {\r\n    if (fromDomain === void 0) { fromDomain = true; }\r\n    /*let [pathStr, varsStr, hashStr] = GetUrlParts(url);\r\n    if (fromDomain)\r\n        pathStr = pathStr.SplitAt(pathStr.IndexOf_X(\"/\", 2).IfN1Then(pathStr.length))[1];\r\n    if (pathStr.endsWith(\"/\"))\r\n        pathStr = pathStr.substr(0, pathStr.length - 1);*/\r\n    var _a = __read(GetUrlParts(url), 2), _ = _a[0], pathStr = _a[1];\r\n    if (pathStr.endsWith(\"/\"))\r\n        pathStr = pathStr.slice(0, -1);\r\n    return pathStr;\r\n}\r\nfunction GetUrlVars(url, allowQuestionMarkAsVarSep) {\r\n    var _a, e_1, _b;\r\n    if (allowQuestionMarkAsVarSep === void 0) { allowQuestionMarkAsVarSep = true; }\r\n    var varSeparators = allowQuestionMarkAsVarSep ? [\"&\", \"?\"] : [\"&\"];\r\n    var _c = __read(GetUrlParts(url), 3), _ = _c[0], __ = _c[1], varsStr = _c[2];\r\n    var vars = {}; //{[key: string]: string};\r\n    var parts = (_a = __1.StringCE(varsStr)).SplitByAny.apply(_a, __spread(varSeparators)).filter(function (a) { return a; });\r\n    try {\r\n        for (var parts_1 = __values(parts), parts_1_1 = parts_1.next(); !parts_1_1.done; parts_1_1 = parts_1.next()) {\r\n            var part = parts_1_1.value;\r\n            var _d = __read(__1.StringCE(part).SplitAt(part.indexOf(\"=\")), 2), key = _d[0], value = _d[1];\r\n            vars[key] = value;\r\n        }\r\n    }\r\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n    finally {\r\n        try {\r\n            if (parts_1_1 && !parts_1_1.done && (_b = parts_1.return)) _b.call(parts_1);\r\n        }\r\n        finally { if (e_1) throw e_1.error; }\r\n    }\r\n    return vars;\r\n}\r\n/*export function GetCurrentURL(fromAddressBar = false) {\r\n    return fromAddressBar ? URL.Parse(GetCurrentURLString()) : URL.FromState(State(\"router\"));\r\n}*/\r\nvar VURL = /** @class */ (function () {\r\n    function VURL(domain, pathNodes, queryVars, hash) {\r\n        if (domain === void 0) { domain = \"\"; }\r\n        if (pathNodes === void 0) { pathNodes = []; }\r\n        if (queryVars === void 0) { queryVars = []; }\r\n        if (hash === void 0) { hash = \"\"; }\r\n        this.domain = domain;\r\n        this.pathNodes = pathNodes;\r\n        this.queryVars = queryVars;\r\n        this.hash = hash;\r\n    }\r\n    VURL.Parse = function (urlStr, useCurrentDomainIfMissing, allowQuestionMarkAsVarSep) {\r\n        var e_2, _a;\r\n        if (useCurrentDomainIfMissing === void 0) { useCurrentDomainIfMissing = true; }\r\n        if (allowQuestionMarkAsVarSep === void 0) { allowQuestionMarkAsVarSep = true; }\r\n        if (useCurrentDomainIfMissing && !urlStr.startsWith(\"http\"))\r\n            urlStr = window.location.origin + (urlStr.startsWith(\"/\") ? \"\" : \"/\") + urlStr;\r\n        var _b = __read(GetUrlParts(urlStr), 4), domainStr = _b[0], pathStr = _b[1], varsStr = _b[2], hashStr = _b[3];\r\n        var queryVarsMap = GetUrlVars(urlStr, allowQuestionMarkAsVarSep);\r\n        var result = new VURL();\r\n        result.domain = domainStr;\r\n        result.pathNodes = pathStr.length ? pathStr.split(\"/\") : [];\r\n        try {\r\n            for (var _c = __values(Object.keys(queryVarsMap)), _d = _c.next(); !_d.done; _d = _c.next()) {\r\n                var key = _d.value;\r\n                result.queryVars.push(new QueryVar(key, queryVarsMap[key]));\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        result.hash = hashStr;\r\n        return result;\r\n    };\r\n    VURL.FromLocationObject = function (location) {\r\n        // todo: have this support all Location properties, not just those used by connected-react-router\r\n        var result = VURL.Parse(location ? (location.pathname || \"\") + (location.search || \"\") + (location.hash || \"\") : \"\");\r\n        //if (normalize) result = result.Normalized();\r\n        return result;\r\n    };\r\n    // doesn't supply all the properties of a Location object, but supplies the most common\r\n    VURL.prototype.ToLocationObject = function () {\r\n        return {\r\n            pathname: this.toString({ domain: false, path: true, queryVars: false, hash: false }),\r\n            search: this.toString({ domain: false, pathStartSlash: false, path: false, queryVars: true, hash: false }),\r\n            hash: this.toString({ domain: false, pathStartSlash: false, path: false, queryVars: false, hash: true }),\r\n            key: \"URLKey_\" + Date.now(),\r\n        };\r\n    };\r\n    VURL.prototype.DomainStr = function (withProtocol) {\r\n        if (withProtocol === void 0) { withProtocol = true; }\r\n        return withProtocol ? this.domain : this.DomainWithoutProtocol;\r\n    };\r\n    Object.defineProperty(VURL.prototype, \"Protocol\", {\r\n        get: function () { return this.domain && __1.StringCE(this.domain).Contains(\"://\") ? this.domain.substr(0, this.domain.indexOf(\"://\")) : null; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(VURL.prototype, \"DomainWithoutProtocol\", {\r\n        get: function () { return this.domain && __1.StringCE(this.domain).Contains(\"://\") ? this.domain.substr(this.domain.indexOf(\"://\") + 3) : this.domain; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    VURL.prototype.PathStr = function (pathStartSlash) {\r\n        var result = \"\";\r\n        if (pathStartSlash) {\r\n            result += \"/\";\r\n        }\r\n        // path-nodes\r\n        if (this.pathNodes.length)\r\n            result += this.pathNodes.join(\"/\");\r\n        return result;\r\n    };\r\n    Object.defineProperty(VURL.prototype, \"QueryStr\", {\r\n        get: function () {\r\n            var e_3, _a;\r\n            var result = \"\";\r\n            try {\r\n                for (var _b = __values(this.queryVars.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var _d = __read(_c.value, 2), index = _d[0], queryVar = _d[1];\r\n                    result += (index == 0 ? \"?\" : \"&\") + queryVar.name + \"=\" + queryVar.value;\r\n                }\r\n            }\r\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_3) throw e_3.error; }\r\n            }\r\n            return result;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    VURL.prototype.GetQueryVar = function (name) {\r\n        var entry = this.queryVars.find(function (a) { return a.name == name; });\r\n        return entry ? entry.value : undefined;\r\n    };\r\n    VURL.prototype.SetQueryVar = function (name, value) {\r\n        var existingEntry = this.queryVars.find(function (a) { return a.name == name; });\r\n        if (existingEntry) {\r\n            existingEntry.value = value;\r\n        }\r\n        else {\r\n            this.queryVars.push(new QueryVar(name, value));\r\n        }\r\n    };\r\n    Object.defineProperty(VURL.prototype, \"HashStr\", {\r\n        get: function () {\r\n            if (!this.hash)\r\n                return \"\";\r\n            return \"#\" + this.hash;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    VURL.prototype.Clone = function () {\r\n        return new VURL(this.domain, this.pathNodes.slice(), this.queryVars.map(function (a) { return a.Clone(); }), this.hash);\r\n    };\r\n    /*Normalized() {\r\n        let result = this.Clone();\r\n        if (!rootPages.Contains(result.pathNodes[0])) {\r\n            result.pathNodes.Insert(0, \"home\");\r\n        }\r\n        if (result.pathNodes[1] == null && rootPageDefaultChilds[result.pathNodes[0]]) {\r\n            result.pathNodes.Insert(1, rootPageDefaultChilds[result.pathNodes[0]]);\r\n        }\r\n        return result;\r\n    }*/\r\n    VURL.prototype.toString = function (options) {\r\n        options = __1.E({ domain: true, domain_protocol: true, pathStartSlash: \"auto\", path: true, queryVars: true, hash: true }, options);\r\n        var result = \"\";\r\n        // domain\r\n        if (options.domain)\r\n            result += this.DomainStr(options.domain_protocol);\r\n        //if (options.forceSlashAfterDomain || (options.path && this.pathNodes.length) || (options.queryVars && this.queryVars.length) || (options.hash && this.hash))\r\n        var pathStartSlash_auto = result.length == 0 || (options.path && this.pathNodes.length) || (options.queryVars && this.queryVars.length) || (options.hash && this.hash);\r\n        var pathStartSlash = options.pathStartSlash == true || (options.pathStartSlash == \"auto\" && pathStartSlash_auto);\r\n        if (pathStartSlash) {\r\n            result += \"/\";\r\n        }\r\n        if (options.path)\r\n            result += this.PathStr(false);\r\n        if (options.queryVars)\r\n            result += this.QueryStr;\r\n        if (options.hash)\r\n            result += this.HashStr;\r\n        __1.Assert(!result.startsWith(\"//\"), \"URL toString() result cannot start with \\\"//\\\". (it's probably an error)\");\r\n        return result;\r\n    };\r\n    VURL.prototype.toString_OptIn = function (options) {\r\n        options = __1.E({ domain: false, path: false, queryVars: false, hash: false }, options);\r\n        return this.toString(options);\r\n    };\r\n    return VURL;\r\n}());\r\nexports.VURL = VURL;\r\nfunction AsPartial(obj) { return obj; }\r\nvar QueryVar = /** @class */ (function () {\r\n    function QueryVar(name, value) {\r\n        this.name = name;\r\n        this.value = value;\r\n    }\r\n    QueryVar.prototype.Clone = function () {\r\n        return new QueryVar(this.name, this.value);\r\n    };\r\n    return QueryVar;\r\n}());\r\nexports.QueryVar = QueryVar;\r\n// todo: merge this functionality into the URL class\r\n/*export function GetPathNodes(path = GetUrlPath(), makeFull = true) {\r\n    /*let location = State().router;\r\n    if (location == null) return \"/\";\r\n    return location.pathname.split(\"/\")[1];*#/\r\n    \r\n    let pathNodes = path.split(\"/\").Where(a=>a.length > 0);\r\n    if (makeFull) {\r\n        if (!rootPages.Contains(pathNodes[0]))\r\n            pathNodes.Insert(0, \"home\");\r\n        if (pathNodes[1] == null)\r\n            pathNodes.Insert(1, rootPageDefaultChilds[pathNodes[0]]);\r\n    }\r\n    return pathNodes;\r\n}\r\nexport function GetPath(path = GetUrlPath(), makeFull = true) {\r\n    return GetPathNodes(path, makeFull).join(\"/\");\r\n}*/ \r\n//# sourceMappingURL=URLs.js.map","\"use strict\";\r\nvar __values = (this && this.__values) || function(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n};\r\nvar __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar General_1 = require(\"./General\");\r\nvar Storage = /** @class */ (function () {\r\n    function Storage() {\r\n        this.resultUpdateCount = 0;\r\n    }\r\n    return Storage;\r\n}());\r\nexports.Storage = Storage;\r\nexports.storages = {};\r\nfunction GetStorageForCachedTransform(transformType, staticProps) {\r\n    //let storageKey = transformType + \"|\" + JSON.stringify(staticProps);\r\n    var storageKey = transformType + \"|\" + staticProps.join(\"|\");\r\n    var storage = exports.storages[storageKey] || (exports.storages[storageKey] = new Storage());\r\n    return storage;\r\n}\r\nexports.GetStorageForCachedTransform = GetStorageForCachedTransform;\r\n/**\r\n * Basically, by wrapping code in this function, you're saying:\r\n *\t\t\"Do not re-evaluate the code below unless the dynamic-props have changed since the last time we were here.\"\r\n *\t\t(with the transformType and staticProps defining what \"here\" means)\r\n * @param transformType The name of the transformation; usually a function-name like \"GetSomeThing\", or \"connectProp_processX\". (used, along with static-props, to form a \"storage key\", where cache is checked for and stored)\r\n * @param staticProps An array.\r\n * @param dynamicProps Can be either an object or array.\r\n * @param transformFunc The data-transformer. Whenever a dynamic-prop changes, this will be called, and the new result will be cached.\r\n */\r\n//export function CachedTransform<T, T2, T3>(transformType: string, staticProps: T, dynamicProps: T2, transformFunc: (staticProps: T, dynamicProps: T2)=>T3): T3 {\r\nfunction CachedTransform(transformType, staticProps, dynamicProps, transformFunc) {\r\n    //Assert(dynamicProps != null);\r\n    var storage = GetStorageForCachedTransform(transformType, staticProps);\r\n    if (!General_1.ShallowEquals(dynamicProps, storage.lastDynamicProps) || storage.resultUpdateCount == 0) {\r\n        /*MaybeLog(a=>a.cacheUpdates,\r\n            ()=>`Recalculating cache. @Type:${transformType} @StaticProps:${ToJSON(staticProps)} @DynamicProps:${ToJSON(dynamicProps)} @TransformFunc:${transformFunc}`);*/\r\n        storage.lastDynamicProps = dynamicProps;\r\n        storage.lastDebugInfo = {};\r\n        storage.lastResult = transformFunc(storage.lastDebugInfo, staticProps, dynamicProps);\r\n        storage.resultUpdateCount++;\r\n    }\r\n    return storage.lastResult;\r\n}\r\nexports.CachedTransform = CachedTransform;\r\nfunction CombineDynamicPropMaps() {\r\n    var e_1, _a;\r\n    var maps = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        maps[_i] = arguments[_i];\r\n    }\r\n    var result = {};\r\n    try {\r\n        for (var _b = __values(maps.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n            var _d = __read(_c.value, 2), mapIndex = _d[0], map = _d[1];\r\n            for (var key in map) {\r\n                if (!map.hasOwnProperty(key))\r\n                    continue;\r\n                result[mapIndex + \"_\" + key] = map[key];\r\n            }\r\n        }\r\n    }\r\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n    finally {\r\n        try {\r\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n        }\r\n        finally { if (e_1) throw e_1.error; }\r\n    }\r\n    return result;\r\n}\r\nexports.CombineDynamicPropMaps = CombineDynamicPropMaps;\r\n//# sourceMappingURL=VCache.js.map","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nvar __spread = (this && this.__spread) || function () {\r\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar General_1 = require(\"./General\");\r\nvar __1 = require(\"..\");\r\nfunction IsNullOrNaN(value) {\r\n    return value === null || __1.IsNaN(value);\r\n}\r\nfunction IsVector2iShape(obj) {\r\n    return obj.hasOwnProperty(\"x\") && obj.hasOwnProperty(\"y\");\r\n}\r\nexports.IsVector2iShape = IsVector2iShape;\r\nvar Vector2i = /** @class */ (function () {\r\n    function Vector2i() {\r\n        var _a, _b, _c;\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var x = 0, y = 0;\r\n        if (typeof args[0] == \"number\")\r\n            _a = __read(args, 2), x = _a[0], y = _a[1];\r\n        else if (args[0] && args[0].x != null)\r\n            _b = __read([args[0].x, args[0].y], 2), x = _b[0], y = _b[1];\r\n        else if (args[0] && args[0].left != null)\r\n            _c = __read([args[0].left, args[0].top], 2), x = _c[0], y = _c[1];\r\n        __1.Assert(!IsNullOrNaN(x) && !IsNullOrNaN(y), \"Cannot initialize Vector2i's x/y to null/NaN. (if needed, initialize to undefined)\");\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    Vector2i_1 = Vector2i;\r\n    Object.defineProperty(Vector2i, \"zero\", {\r\n        get: function () { return new Vector2i_1(0, 0); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Vector2i, \"one\", {\r\n        get: function () { return new Vector2i_1(1, 1); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /*@_VDFDeserialize() Deserialize(node) {\r\n        var strParts = node.primitiveValue.split(\" \");\r\n        this.x = parseInt(strParts[0]);\r\n        this.y = parseInt(strParts[1]);\r\n    }\r\n    @_VDFSerialize() Serialize() { return new VDFNode(this.toString()); }*/\r\n    Vector2i.prototype.toString = function () { return this.x + \" \" + this.y; };\r\n    Vector2i.prototype.Equals = function (other) { return other && this.toString() == other.toString(); };\r\n    Vector2i.prototype.NewX = function (xOrFunc) { return new Vector2i_1(xOrFunc instanceof Function ? xOrFunc(this.x) : xOrFunc, this.y); };\r\n    Vector2i.prototype.NewY = function (yOrFunc) { return new Vector2i_1(this.x, yOrFunc instanceof Function ? yOrFunc(this.y) : yOrFunc); };\r\n    Vector2i.prototype.Plus = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var _a = __read(IsVector2iShape(args[0]) ? [args[0].x, args[0].y] : args, 2), x = _a[0], y = _a[1];\r\n        return new Vector2i_1(this.x + x, this.y + y);\r\n    };\r\n    Vector2i.prototype.Minus = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var _a = __read(IsVector2iShape(args[0]) ? [args[0].x, args[0].y] : args, 2), x = _a[0], y = _a[1];\r\n        return new Vector2i_1(this.x - x, this.y - y);\r\n    };\r\n    Vector2i.prototype.Times = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var _a = __read(IsVector2iShape(args[0]) ? [args[0].x, args[0].y] :\r\n            args.length == 1 ? [args[0], args[0]] :\r\n                args, 2), x = _a[0], y = _a[1];\r\n        return new Vector2i_1(this.x * x, this.y * y);\r\n    };\r\n    Vector2i.prototype.DividedBy = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var _a = __read(IsVector2iShape(args[0]) ? [args[0].x, args[0].y] :\r\n            args.length == 1 ? [args[0], args[0]] :\r\n                args, 2), x = _a[0], y = _a[1];\r\n        return new Vector2i_1(this.x / x, this.y / y);\r\n    };\r\n    Vector2i.prototype.DistanceTo = function (other) {\r\n        return Math.sqrt(__1.NumberCE(other.x - this.x).ToPower(2) + __1.NumberCE(other.y - this.y).ToPower(2));\r\n    };\r\n    var Vector2i_1;\r\n    Vector2i = Vector2i_1 = __decorate([\r\n        General_1.Global\r\n    ], Vector2i);\r\n    return Vector2i;\r\n}());\r\nexports.Vector2i = Vector2i;\r\nfunction IsVector3iShape(obj) {\r\n    return obj.hasOwnProperty(\"x\") && obj.hasOwnProperty(\"y\") && obj.hasOwnProperty(\"z\");\r\n}\r\nexports.IsVector3iShape = IsVector3iShape;\r\nvar Vector3i = /** @class */ (function () {\r\n    function Vector3i(x, y, z) {\r\n        if (x === void 0) { x = null; }\r\n        if (y === void 0) { y = null; }\r\n        if (z === void 0) { z = null; }\r\n        __1.Assert(!IsNullOrNaN(x) && !IsNullOrNaN(y) && !IsNullOrNaN(z), \"Cannot initialize Vector3i's x/y/z to null/NaN. (if needed, initialize to undefined)\");\r\n        this.x = x != null ? x : 0;\r\n        this.y = y != null ? y : 0;\r\n        this.z = z != null ? z : 0;\r\n    }\r\n    Vector3i_1 = Vector3i;\r\n    Object.defineProperty(Vector3i, \"zero\", {\r\n        get: function () { return new Vector3i_1(0, 0, 0); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Vector3i, \"one\", {\r\n        get: function () { return new Vector3i_1(1, 1, 1); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /*@_VDFDeserialize() Deserialize(node) {\r\n        var strParts = node.primitiveValue.split(\" \");\r\n        this.x = parseInt(strParts[0]);\r\n        this.y = parseInt(strParts[1]);\r\n        this.z = parseInt(strParts[2]);\r\n    }\r\n    //VDFSerialize() { return this.toString(); } //Swapped().toString(); }\r\n    @_VDFSerialize() Serialize() { return new VDFNode(this.toString()); }*/\r\n    Vector3i.prototype.toString = function () { return this.x + \" \" + this.y + \" \" + this.z; };\r\n    Vector3i.prototype.NewX = function (xOrFunc) { return new Vector3i_1(xOrFunc instanceof Function ? xOrFunc(this.x) : xOrFunc, this.y, this.z); };\r\n    Vector3i.prototype.NewY = function (yOrFunc) { return new Vector3i_1(this.x, yOrFunc instanceof Function ? yOrFunc(this.y) : yOrFunc, this.z); };\r\n    Vector3i.prototype.NewZ = function (zOrFunc) { return new Vector3i_1(this.x, this.y, zOrFunc instanceof Function ? zOrFunc(this.z) : zOrFunc); };\r\n    Vector3i.prototype.Minus = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var _a = __read(IsVector3iShape(args[0]) ? [args[0].x, args[0].y, args[0].z] : args, 3), x = _a[0], y = _a[1], z = _a[2];\r\n        return new Vector3i_1(this.x - x, this.y - y, this.z - z);\r\n    };\r\n    Vector3i.prototype.Plus = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var _a = __read(IsVector3iShape(args[0]) ? [args[0].x, args[0].y, args[0].z] : args, 3), x = _a[0], y = _a[1], z = _a[2];\r\n        return new Vector3i_1(this.x + x, this.y + y, this.z + z);\r\n    };\r\n    Vector3i.prototype.Times = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var _a = __read(IsVector3iShape(args[0]) ? [args[0].x, args[0].y, args[0].z] :\r\n            args.length == 1 ? [args[0], args[0], args[0]] :\r\n                args, 3), x = _a[0], y = _a[1], z = _a[2];\r\n        return new Vector3i_1(this.x * x, this.y * y, this.z * z);\r\n    };\r\n    var Vector3i_1;\r\n    Vector3i = Vector3i_1 = __decorate([\r\n        General_1.Global\r\n    ], Vector3i);\r\n    return Vector3i;\r\n}());\r\nexports.Vector3i = Vector3i;\r\nfunction IsVRectShape(obj) {\r\n    return obj.hasOwnProperty(\"x\") && obj.hasOwnProperty(\"y\") && obj.hasOwnProperty(\"width\") && obj.hasOwnProperty(\"height\");\r\n}\r\nexports.IsVRectShape = IsVRectShape;\r\nvar VRect = /** @class */ (function () {\r\n    function VRect() {\r\n        var _a, _b;\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var x, y, width, height, y0IsBottom;\r\n        if (args.length == 2 || args.length == 3)\r\n            _a = __read([args[0].x, args[0].y, args[1].x, args[1].y, args[2]], 5), x = _a[0], y = _a[1], width = _a[2], height = _a[3], y0IsBottom = _a[4];\r\n        else\r\n            _b = __read(args, 5), x = _b[0], y = _b[1], width = _b[2], height = _b[3], y0IsBottom = _b[4];\r\n        __1.Assert(!IsNullOrNaN(x) && !IsNullOrNaN(y) && !IsNullOrNaN(width) && !IsNullOrNaN(height), \"Cannot initialize VRect's x/y/width/height to null/NaN. (if needed, initialize to undefined)\");\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width != null ? width : 0;\r\n        this.height = height != null ? height : 0;\r\n        //this.y0IsBottom = y0IsBottom != null ? y0IsBottom : false;\r\n        if (y0IsBottom)\r\n            this.y0IsBottom = y0IsBottom;\r\n    }\r\n    VRect_1 = VRect;\r\n    VRect.FromLTWH = function (rect, y0IsBottom) {\r\n        if (y0IsBottom === void 0) { y0IsBottom = false; }\r\n        return new VRect_1(rect.left, rect.top, rect.width, rect.height, y0IsBottom);\r\n    };\r\n    Object.defineProperty(VRect.prototype, \"Left\", {\r\n        get: function () { return this.x; },\r\n        set: function (val) {\r\n            var oldRight = this.Right;\r\n            this.x = val;\r\n            this.Right = oldRight;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(VRect.prototype, \"Right\", {\r\n        get: function () { return this.x + this.width; },\r\n        set: function (val) { this.width = val - this.x; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(VRect.prototype, \"Bottom\", {\r\n        get: function () { return this.y0IsBottom ? this.y : this.y + this.height; },\r\n        set: function (val) {\r\n            if (this.y0IsBottom) {\r\n                var oldTop = this.Top;\r\n                this.y = val;\r\n                this.Top = oldTop;\r\n            }\r\n            else {\r\n                this.height = val - this.y;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(VRect.prototype, \"Top\", {\r\n        get: function () { return this.y0IsBottom ? this.y + this.height : this.y; },\r\n        set: function (val) {\r\n            if (this.y0IsBottom) {\r\n                this.height = val - this.y;\r\n            }\r\n            else {\r\n                var oldBottom = this.Bottom;\r\n                this.y = val;\r\n                this.Bottom = oldBottom;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(VRect.prototype, \"Position\", {\r\n        get: function () { return new Vector2i(this.x, this.y); },\r\n        set: function (val) {\r\n            this.x = val.x;\r\n            this.y = val.y;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(VRect.prototype, \"Size\", {\r\n        get: function () { return new Vector2i(this.width, this.height); },\r\n        set: function (val) {\r\n            this.width = val.x;\r\n            this.height = val.y;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(VRect.prototype, \"Center\", {\r\n        get: function () { return new Vector2i(this.x + (this.width / 2), this.y + (this.height / 2)); },\r\n        set: function (val) {\r\n            var offset = val.Minus(this.Center);\r\n            this.Position = this.Position.Plus(offset);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /*@_VDFDeserialize() Deserialize(node) {\r\n        var strParts = node.primitiveValue.split(\" \");\r\n        this.x = parseInt(strParts[0]);\r\n        this.y = parseInt(strParts[1]);\r\n        this.width = parseInt(strParts[2]);\r\n        this.height = parseInt(strParts[3]);\r\n    }\r\n    @_VDFSerialize() Serialize() { return new VDFNode(this.toString()); }*/\r\n    VRect.prototype.toString = function () { return this.x + \" \" + this.y + \" \" + this.width + \" \" + this.height; };\r\n    VRect.prototype.Equals = function (other) {\r\n        if (!(other instanceof VRect_1))\r\n            return false;\r\n        return this.toString() == other.toString();\r\n    };\r\n    VRect.prototype.NewX = function (valOrFunc) {\r\n        return __1.ObjectCE(this.Clone()).VSet({ x: valOrFunc instanceof Function ? valOrFunc(this.x) : valOrFunc });\r\n    };\r\n    VRect.prototype.NewLeft = function (valOrFunc) {\r\n        return __1.ObjectCE(this.Clone()).VSet({ Left: valOrFunc instanceof Function ? valOrFunc(this.Left) : valOrFunc });\r\n    };\r\n    VRect.prototype.NewRight = function (valOrFunc) {\r\n        return __1.ObjectCE(this.Clone()).VSet({ Right: valOrFunc instanceof Function ? valOrFunc(this.Right) : valOrFunc });\r\n    };\r\n    VRect.prototype.NewY = function (valOrFunc) {\r\n        return __1.ObjectCE(this.Clone()).VSet({ y: valOrFunc instanceof Function ? valOrFunc(this.y) : valOrFunc });\r\n    };\r\n    VRect.prototype.NewBottom = function (valOrFunc) {\r\n        return __1.ObjectCE(this.Clone()).VSet({ Bottom: valOrFunc instanceof Function ? valOrFunc(this.Bottom) : valOrFunc });\r\n    };\r\n    VRect.prototype.NewTop = function (valOrFunc) {\r\n        return __1.ObjectCE(this.Clone()).VSet({ Top: valOrFunc instanceof Function ? valOrFunc(this.Top) : valOrFunc });\r\n    };\r\n    VRect.prototype.NewPosition = function (valOrFunc) {\r\n        return __1.ObjectCE(this.Clone()).VSet({ Position: valOrFunc instanceof Function ? valOrFunc(this.Position) : valOrFunc });\r\n    };\r\n    VRect.prototype.NewWidth = function (valOrFunc) {\r\n        return __1.ObjectCE(this.Clone()).VSet({ width: valOrFunc instanceof Function ? valOrFunc(this.width) : valOrFunc });\r\n    };\r\n    VRect.prototype.NewHeight = function (valOrFunc) {\r\n        return __1.ObjectCE(this.Clone()).VSet({ height: valOrFunc instanceof Function ? valOrFunc(this.height) : valOrFunc });\r\n    };\r\n    VRect.prototype.NewSize = function (valOrFunc) {\r\n        return __1.ObjectCE(this.Clone()).VSet({ Size: valOrFunc instanceof Function ? valOrFunc(this.Size) : valOrFunc });\r\n    };\r\n    VRect.prototype.Grow = function (amountOnEachSide) {\r\n        return new VRect_1(this.x - amountOnEachSide, this.y - amountOnEachSide, this.width + (amountOnEachSide * 2), this.height + (amountOnEachSide * 2));\r\n    };\r\n    VRect.prototype.Encapsulating = function (rect) {\r\n        var posX = Math.min(this.x, rect.x);\r\n        var posY = Math.min(this.y, rect.y);\r\n        return new VRect_1(posX, posY, Math.max(this.x + this.width, rect.x + rect.width) - posX, Math.max(this.y + this.height, rect.y + rect.height) - posY);\r\n    };\r\n    VRect.prototype.Encapsulate = function (rect) {\r\n        var oldRight = this.x + this.width;\r\n        var oldBottom = this.y + this.height;\r\n        this.x = Math.min(this.x, rect.x);\r\n        this.y = Math.min(this.y, rect.y);\r\n        this.width = Math.max(oldRight, rect.x + rect.width) - this.x;\r\n        this.height = Math.max(oldBottom, rect.y + rect.height) - this.y;\r\n    };\r\n    VRect.prototype.Intersects = function (other) {\r\n        return this.Right > other.Left && this.Left < other.Right && this.Bottom > other.Top && this.Top < other.Bottom;\r\n    };\r\n    /** Returns true if rect would intersect the other, when wrapped to the 2/8 potential \"other-sides\" of given frame/backdrop. (-x, +x, -y, +y, -x -y, -x +y, +x -y, +x +y)\r\n     * (note that it does the checks \"stupidly\", ie. just checking all possible switch-side variants, without checking if \"switched side\" version is actually on or even near the actual frame/backdrop) */\r\n    VRect.prototype.Intersects_Advanced = function (other, options) {\r\n        var variantsToCompare = [this];\r\n        if (options.xWrappedBy) {\r\n            variantsToCompare.push.apply(variantsToCompare, __spread(__1.ArrayCE(variantsToCompare).SelectMany(function (base) {\r\n                return [base, base.NewX(function (x) { return x - options.xWrappedBy; }), base.NewX(function (x) { return x + options.xWrappedBy; })];\r\n            })));\r\n        }\r\n        if (options.yWrappedBy) {\r\n            variantsToCompare.push.apply(variantsToCompare, __spread(__1.ArrayCE(variantsToCompare).SelectMany(function (base) {\r\n                return [base, base.NewY(function (y) { return y - options.yWrappedBy; }), base.NewY(function (y) { return y + options.yWrappedBy; })];\r\n            })));\r\n        }\r\n        return __1.ArrayCE(variantsToCompare).Any(function (a) { return a.Intersects(other); });\r\n    };\r\n    VRect.prototype.Clone = function () {\r\n        return new VRect_1(this.x, this.y, this.width, this.height);\r\n    };\r\n    var VRect_1;\r\n    VRect = VRect_1 = __decorate([\r\n        General_1.Global\r\n    ], VRect);\r\n    return VRect;\r\n}());\r\nexports.VRect = VRect;\r\nvar VBounds = /** @class */ (function () {\r\n    function VBounds(position, size) {\r\n        this.position = position;\r\n        this.size = size;\r\n    }\r\n    /*@_VDFDeserialize() Deserialize(node) {\r\n        var parts = node.primitiveValue.split(\"|\");\r\n        var posParts = parts[0].split(\" \");\r\n        this.position = new VVector3(parseFloat(posParts[0]), parseFloat(posParts[1]), parseFloat(posParts[2]));\r\n        var sizeParts = parts[1].split(\" \");\r\n        this.size = new VVector3(parseFloat(sizeParts[0]), parseFloat(sizeParts[1]), parseFloat(sizeParts[2]));\r\n    }\r\n    @_VDFSerialize() Serialize() { return new VDFNode(this.toString()); }*/\r\n    VBounds.prototype.toString = function () { return this.position.x + \" \" + this.position.y + \" \" + this.position.z + \"|\" + this.size.x + \" \" + this.size.y + \" \" + this.size.z; };\r\n    VBounds = __decorate([\r\n        General_1.Global\r\n    ], VBounds);\r\n    return VBounds;\r\n}());\r\nexports.VBounds = VBounds;\r\n//# sourceMappingURL=VectorStructs.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//import \"./ClassExtensions\";\r\n//export * from \"./ClassExtensions/@ApplyCode\";\r\n//export * from \"./ClassExtensions/@ApplyTypes\"; // if desired, user project should import directly (from Source folder)\r\n__export(require(\"./ClassExtensions/CE_Array\"));\r\n__export(require(\"./ClassExtensions/CE_Element\"));\r\n__export(require(\"./ClassExtensions/CE_Number\"));\r\n__export(require(\"./ClassExtensions/CE_Object\"));\r\n__export(require(\"./ClassExtensions/CE_Others\"));\r\n__export(require(\"./ClassExtensions/CE_String\"));\r\n__export(require(\"./ClassExtensions/CE_Auto\"));\r\n__export(require(\"./JSVE\"));\r\n__export(require(\"./Utils/General\"));\r\n__export(require(\"./Utils/Changes\"));\r\n__export(require(\"./Utils/Assert\"));\r\n__export(require(\"./Utils/Timers\"));\r\n__export(require(\"./Utils/Types\"));\r\n__export(require(\"./Utils/VectorStructs\"));\r\n__export(require(\"./Utils/URLs\"));\r\n__export(require(\"./Utils/VCache\"));\r\n__export(require(\"./Utils/Bridge\"));\r\n//# sourceMappingURL=index.js.map","// @ts-check\r\n\r\nconst {TransferPrototypeProps} = require(\"../Dist\");\r\nconst {ArrayCE_funcs} = require(\"../Dist/ClassExtensions/CE_Array\");\r\nconst {ElementCE_funcs} = require(\"../Dist/ClassExtensions/CE_Element\");\r\nconst {NumberCE_funcs} = require(\"../Dist/ClassExtensions/CE_Number\");\r\nconst {ObjectCE_funcs} = require(\"../Dist/ClassExtensions/CE_Object\");\r\nconst {DateCE_funcs, FunctionCE_funcs} = require(\"../Dist/ClassExtensions/CE_Others\");\r\nconst {StringCE_funcs} = require(\"../Dist/ClassExtensions/CE_String\");\r\n\r\nfunction ClassExtensions_ApplyCode() {\r\n\tTransferPrototypeProps(Array.prototype, ArrayCE_funcs, {}, {configurable: true, enumerable: false});\r\n\tif (typeof Element != \"undefined\") {\r\n\t\tTransferPrototypeProps(Element.prototype, ElementCE_funcs, {}, {configurable: true, enumerable: false});\r\n\t}\r\n\tTransferPrototypeProps(Number.prototype, NumberCE_funcs, {}, {configurable: true, enumerable: false});\r\n\tTransferPrototypeProps(Object.prototype, ObjectCE_funcs, {}, {configurable: true, enumerable: false});\r\n\tTransferPrototypeProps(Function.prototype, FunctionCE_funcs, {}, {configurable: true, enumerable: false});\r\n\tTransferPrototypeProps(Date.prototype, DateCE_funcs, {}, {configurable: true, enumerable: false});\r\n\t//TransferPrototypeProps(Error.prototype, ErrorCE_funcs, {}, {configurable: true, enumerable: false});\r\n\tTransferPrototypeProps(String.prototype, StringCE_funcs, {}, {configurable: true, enumerable: false});\r\n}\r\n\r\n// this file is only imported if user manually imports it; if so, apply immediately when imported\r\nClassExtensions_ApplyCode();","module.exports = require(\"babel-polyfill\");","module.exports = require(\"death\");","module.exports = require(\"ffi\");","module.exports = require(\"iohook\");","module.exports = require(\"js-vextensions\");","module.exports = require(\"process\");","module.exports = require(\"ref\");","module.exports = require(\"ref-struct\");","module.exports = require(\"win32-api\");"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;ACLA;AAAA;AAAA;AACA;AAGA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAAA;;;;;;;;AAOA;AAEA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;AACA;AACA;AAEA;AAJA;AAAA;AAAA;AACA;AADA;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AAbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AAEA;;;;;;AAMA;AACA;AAAA;;;;;;;;AAQA;AACA;;;;;;;;;;;;;;;;AACA;AA0FA;AACA;AACA;AAFA;AAUA;AACA;AACA;AACA;AACA;AAJA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAUA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAXA;AAcA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5TA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAnDA;AACA;AAsDA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAGA;AAEA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAGA;AACA;AACA;AAAA;AACA;AAKA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;;;;;;;AAQA;AACA;AAAA;;AAEA;AAEA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAhDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAgDA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;;;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;AC7HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACxBA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;A","sourceRoot":""}